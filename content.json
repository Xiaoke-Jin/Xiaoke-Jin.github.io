{"meta":{"title":"Cloud","subtitle":"Just for fun!","description":"Welcome To The World Of Algorithm","author":"A Cloud","url":"http://Xiaoke-Jin.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-07-30T09:43:50.000Z","updated":"2021-08-01T04:28:40.966Z","comments":true,"path":"about/index.html","permalink":"http://xiaoke-jin.github.io/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2021-07-29T14:53:49.000Z","updated":"2021-08-01T04:28:40.971Z","comments":true,"path":"categories/index.html","permalink":"http://xiaoke-jin.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-01T07:35:22.898Z","updated":"2021-08-01T07:35:22.898Z","comments":true,"path":"manifest.json","permalink":"http://xiaoke-jin.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"link","date":"2021-07-30T09:05:40.000Z","updated":"2021-08-01T04:28:40.976Z","comments":true,"path":"link/index.html","permalink":"http://xiaoke-jin.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T04:53:46.000Z","updated":"2021-08-01T04:28:40.981Z","comments":true,"path":"tags/index.html","permalink":"http://xiaoke-jin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Github访问优化","slug":"Github/Github访问加速","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-10T08:35:56.086Z","comments":true,"path":"20201/08/01/Github/Github访问加速/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Github/Github%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/","excerpt":"","text":"Sky03’ Blog: Github访问优化","categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/tags/Github/"}]},{"title":"一个开源博客项目","slug":"Hexo/一个开源项目","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-08T14:33:30.122Z","comments":true,"path":"20201/08/01/Hexo/一个开源项目/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Hexo/%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"Hexo+Github博客搭建完全教程","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"静态博客访问优化","slug":"Hexo/静态博客访问优化","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-10T08:36:58.317Z","comments":true,"path":"20201/08/01/Hexo/静态博客访问优化/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Hexo/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96/","excerpt":"","text":"Sky03’ Blog: 静态博客访问优化","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"Butterfly主题及其美化","slug":"Hexo/Butterfly主题及其美化","date":"+020201-07-29T16:00:00.000Z","updated":"2021-08-10T08:37:25.035Z","comments":true,"path":"20201/07/30/Hexo/Butterfly主题及其美化/","link":"","permalink":"http://xiaoke-jin.github.io/20201/07/30/Hexo/Butterfly%E4%B8%BB%E9%A2%98%E5%8F%8A%E5%85%B6%E7%BE%8E%E5%8C%96/","excerpt":"","text":"官方文档 Butterfly官方文档 卷二兔 图片自适应 webp 及全站 CDN 加速 更换博客背景图片及图片压缩","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"","slug":"读书笔记/初等数论及其应用/第二章 整数的表示法和运算","date":"2021-08-23T03:26:59.246Z","updated":"2021-08-27T13:32:00.426Z","comments":true,"path":"2021/08/23/读书笔记/初等数论及其应用/第二章 整数的表示法和运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/初等数论及其应用/第三章 素数和最大公因子","date":"2021-08-22T16:00:00.000Z","updated":"2021-08-29T05:22:06.366Z","comments":true,"path":"2021/08/23/读书笔记/初等数论及其应用/第三章 素数和最大公因子/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B4%A0%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/","excerpt":"","text":"大纲 尽管数学家做了几百年的努力，仍有关于素数的许多问题未被解决。 我们将选取讨论其中的一些，包括最著名的两个：孪生素数猜想和哥德巴赫（Goldbach）猜想。 在数论中常常研究具有特殊形式的数。本章中，我们将介绍费马数，即形如 2n+12^n+12n+1 的整数。（费马猜想它们都是素数，但是这被证明是不对的）。 最后，我们将介绍丢番图方程，它是只考虑整数解的方程。 我们将证明如何用最大公因子来帮助求解线性丢番图方程。 与其他丢番图方程不同，线性丢番图方程能够容易地系统解决。 素数 定义：素数是大于 111 的正整数，并且除了 111 和它本身外不能被其他正整数所整除。 定义：大于 111 的不是素数的正整数称为合数。 本节将讨论给定正整数集中素数的分布并证明该分布的一些基础性质。 同时还将讨论关于素数分布的一些更强的结论。 在我们将要介绍的定理中包含了数论中一些最著名的结论。 「素数的无限性」：我们从证明有无穷多个素数开始，为此需要下面的引理。 我们将在本章的后面介绍一些证明素数无穷性的其他方法。（见这一节末尾的习题8以及3.3、3.5和3.6节的习题）。 引理3.1-每个大于 111 的正整数都有一个素因子 引理3.1：每个大于 111 的正整数都有一个素因子。 证明： 定理3.1-素数无限性 定理3.1：存在无穷多个素数。 证明： 证毕。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理3.1的证明过程不是构造性的，因为我们在证明中构造的整数 QnQ_nQn​，（由前 nnn 个素数的积加得到）可以是素数也可以不是（见习题11）。因此，在证明过程中我们只是知道存在一个新的素数但是并没有求得它。 求素数：在下面的章节中，我们将把兴趣放在如何求大素数和使用大素数上。 定理3.2-合数必有一个不超过 n\\sqrt{n}n​ 的素因子 将素数和合数加以区分的测试是至关重要的，这种测试叫做素性检验。 最基本的素性检验是「试除法」。 bool is_prime()&#123; for(int i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false; &#125; return true;&#125; 定理3.2：如果 nnn 是一个合数，那么 nnn 一定有一个不超过 n\\sqrt{n}n​ 的素因子。 证明： 既然 nnn 是合数，那么 nnn 可以写成 n=a∗bn=a*bn=a∗b，其中 a, b 为整数且 1&lt;a≤b&lt;n1&lt;a≤b&lt;n1&lt;a≤b&lt;n 。 我们一定有 a≤na\\le \\sqrt{n}a≤n​ ，否则若 b≥a&gt;nb\\ge a&gt;\\sqrt{n}b≥a&gt;n​，那么有 a∗b&gt;n∗n=na*b&gt;\\sqrt{n}*\\sqrt{n}=na∗b&gt;n​∗n​=n 。(至此，aaa 可能是合数，也可能是质数)。 由引理3.1，aaa 至少有一个素因子，再由定理1.8，aaa 的因子一定也是 nnn 的因子，显然这个因子小于等于 n\\sqrt{n}n​ 。 证毕。 ■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 给定一个正整数 nnn ，使用定理3.2可以找到所有小于等于 nnn 的素数。这种方法就是「埃拉托色尼斯筛法」。 int primes[1000], cnt;bool is_prime[1000];for(int i = 2; i &lt;= n; i++)&#123; if(is_primes[i]) continue; primes[++cnt] = i; if(i &lt;= sqrt(n))&#123; // 使用小于等于sqrt(n)的所有质数即可 for(int j = i + i; j &lt;= n; j += i) is_primes[j] = true; &#125;&#125; 对于一个特定的整数 nnn ，我们将在后面给出一个更好的方法来判断一个整数是否是素数，即定理6.11。 定理3.3 定理3.3（狄利克雷关于「等差数列中素数的定理」）：假设 a,ba,ba,b 是互素的整数，那么等差数列 an+b(n=1,2,3,⋯ )an+b(n=1,2,3,\\cdots)an+b(n=1,2,3,⋯) 包含了无穷多的素数。 目前为止狄利克雷定理没有简单的证法。（狄利克雷的原始证明使用了复变量。后来爱尔迪希 (Erdos) 和塞尔伯格 (Selberg) 在20世纪50年代给出了一个初等但较复杂的证明）。 但是狄利克雷定理的一些特例很容易证。我们将通过在3.5节中证明有无穷多个 4n+34n+34n+3 型的素数来说明这一点。 素数公式 是否有一个公式只产生素数呢？ 关于一个变元的多项式没有这种性质，习题23证明了这一点。同样，关于 nnn 个变元的多项式不能只产生素数，其中 nnn 是一个正整数（这个结论超出了本书的范围）。 有一些可以只产生素数的公式但是不实用。例如，米尔斯（Mills）证明了存在一个常数 素性证明 在广义黎曼猜想成立的条件下，米勒（G. L. Miller）于1975年给出了一个可用 O((log⁡n)5)O((\\log{n})^5)O((logn)5) 次位运算来证明一个整数是素数的算法。但可惜的是，广义黎曼猜想到现在尚未被证明。 ★\\bigstar★ 由于广义黎曼猜想并没有被证明，其后由Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。 在1983年，Leonard Adleman、Carl Pomerance和Robert Rumely建立了一个计算复杂度为 的算法，其中 是常数。 虽然他们的算法不是多项式时间，但是它已经接近多项式时间了，因为 增长得非常慢。 使用他们的算法结合现在的计算机确定一个100位的整数是否为素数只需几毫秒，确定一个400位的整数是否为素数用时不超过 秒，而确定一个1000位的整数是否为素数用时少于一个小时。（关于他们的算法的更多内容参见 [AdPoRu83] 和 [Ru83] ） 素性验证的多项式时间算法 2002年，一位印度计算机教授 我们现在只是讨论了素性检验中的「确定性算法」（deterministic algorithms），即用来确定一个整数是否为素数的算法。 在第6章中我们将讨论概率素性检验法，即米勒-拉宾算法，定理6.11。这个测试将告诉我们一个整数有很高的可能性是素数，但并不确定其为素数。 素数的分布 定理3.4-素数定理 定义：函数 π(x)\\pi(x)π(x) 表示不超过 xxx 的素数的个数，其中 xxx 是正实数。 素数定理：不超过 n\\sqrt{n}n​ 的素数个数大约为 nlog⁡n=2nlog⁡n\\dfrac{\\sqrt{n}}{\\log{\\sqrt{n}}}=\\dfrac{2\\sqrt{n}}{\\log{n}}logn​n​​=logn2n​​ 。 定理3.4(素数定理)：随着 xxx 的无限增长，π(x)\\pi(x)π(x) 和 xlog⁡x\\dfrac{x}{\\log{x}}logxx​ 的比趋于 111。这里，log⁡x\\log{x}logx 是 xxx 的自然对数 ln⁡x\\ln{x}lnx 。 如果用极限的语言来表述，我们有 lim⁡x→∞π(x)(x/log⁡x)=1\\lim\\limits_{x \\to \\infty} \\dfrac{\\pi(x)}{(x/\\log x)}=1x→∞lim​(x/logx)π(x)​=1。 用一个简单的方法来表述素数定理是写成 π(x)∽xlog⁡x\\pi(x)\\backsim\\dfrac{x}{\\log{x}}π(x)∽logxx​。这里符号~表示渐进于。 推论3.4.1 推论3.4.1： 定理3.5 如果随机地选择一个正整数，那么它是素数的概率有多大呢？ 定理3.5：对于任意的正整数 nnn，存在至少 nnn 个连续的正合数。 证明： 关于素数的猜想 伯兰特猜想； 「孪生素数猜想」； 「哥德巴赫猜想」：每个大于 222 的正偶数可以写成两个素数的和。 素数等差数列的「厄尔多斯猜想」：对任意的正整数 n≥3n\\ge 3n≥3，有一个由素数组成的长度为 nnn 的等差数列。 2006年Ben Green和陶哲轩取得了突破性进展从而证明了该猜想。 n2+1n^2+1n2+1 猜想：存在无穷多个形如 n2+1n^2+1n2+1 的素数，其中 nnn 是正整数。 勒让德猜想 最大公因子及其性质 定理3.6 定理3.6 ：a,ba,ba,b是整数，且 (a,b)=d(a,b)=d(a,b)=d ，那么 (ad,bd)=1(\\dfrac{a}{d},\\dfrac{b}{d})=1(da​,db​)=1 。（换言之，a/da/da/d 与 b/db/db/d 互素）。 证明： 我们将证明 a/d,b/da/d,b/da/d,b/d 除了 111 之外没有其他的公因子。 如果 (p,q)=1(p,q)=1(p,q)=1 ，则分数 p/qp/qp/q 被称为既约分数。 推论3.6.1 如果 (p,q)=1(p,q)=1(p,q)=1 ，则分数 p/qp/qp/q 被称为既约分数。 下面的推论告诉我们每一个分数都与另一个既约分数相等。 推论3.6.1：如果 a,ba,ba,b 为整数，且 b≠0b\\neq 0b=0 ，则 ab=pq\\dfrac{a}{b}=\\dfrac{p}{q}ba​=qp​ ，其中 p,qp,qp,q 为整数，且 (p,q)=1,q≠0(p,q)=1,q\\neq 0(p,q)=1,q=0 。 证明： 定理3.7 定理3.7：令 a,b,ca,b,ca,b,c 是整数，那么 (a,b)=(a+bc,b)(a,b)=(a+bc,b)(a,b)=(a+bc,b) 。 证明： 定理3.8 定义：如果 a,ba,ba,b 是整数，那么它们的线性组合具有形式 ma+nbma+nbma+nb ，其中 m,nm,nm,n 都是整数。 定理3.8：两个不全为零的整数 a,ba,ba,b 的最大公因子是 a,ba,ba,b 的线性组合中最小的正整数。 证明： 令 ddd 是 a,ba,ba,b 的线性组合中最小的正整数。（因为当 a≠0a\\neq 0a=0 时，两个线性组合 1×a+0×b1\\times a+0\\times b1×a+0×b 和 0×a+1×b0\\times a+1\\times b0×a+1×b 中必有一个为正，因此根据良序性，存在最小的正整数）。 我们有 d=ma+nbd=ma+nbd=ma+nb ，其中 m,nm,nm,n 是整数 。\\qquad\\qquad （1） 我们将证明 d∣a,d∣bd\\mid a,d\\mid bd∣a,d∣b 。 由带余除法，得到 a=dq+ra=dq+ra=dq+r，0≤r&lt;d0\\le r&lt;d0≤r&lt;d 。由这个方程和（1）可以得到 r=a−dq=a−q(ma+nb)=(1−mq)a−qnbr=a-dq=a-q(ma+nb)=(1-mq)a-qnbr=a−dq=a−q(ma+nb)=(1−mq)a−qnb 。这就证明了整数 rrr 是 a,ba,ba,b 的线性组合。因为 0≤r&lt;d0\\le r&lt;d0≤r&lt;d ，因为 ddd 是 a,ba,ba,b 的线性组合中最小的正整数，于是我们得到 r=0r=0r=0，因此 d∣ad\\mid ad∣a 。同理可得 d∣bd\\mid bd∣b 。 接下来证明它是 a,ba,ba,b 的最大公因子。为此只需证明 a,ba,ba,b 所有的公因子 ccc 都可整除 ddd 。 由于 d=ma+nbd=ma+nbd=ma+nb ，因此如果 c∣ac\\mid ac∣a 且 c∣bc\\mid bc∣b ，那么由定理1.9有 c∣dc\\mid dc∣d ，因此 d≥cd\\ge cd≥c 。 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 推论3.8.1-贝祖定理 推论3.8.1（Bezout，贝祖定理）：如果 a,ba,ba,b 均为整数，则有整数 m,nm,nm,n ，使得 ma+nb=gcd(a,b)ma+nb=gcd(a,b)ma+nb=gcd(a,b) 。 方程 ma+nb=(a,b)ma+nb=(a,b)ma+nb=(a,b) 被称为 Bezout 等式，对给定的整数 a,ba,ba,b 满足该等式的整数 m,nm,nm,n 被称为是 a,ba,ba,b 的 Bezout 系数或 Bezout 数。 推论3.8.2 推论3.8.2：整数 a,ba,ba,b 互素当且仅当存在整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 。 证明： 定理3.9 定理3.9：如果 a,ba,ba,b 是正整数，那么所有 a,ba,ba,b 的线性组合构成的集合与所有 (a,b)(a,b)(a,b) 的倍数构成的集合相同。 证明： 假设 d=(a,b)d=(a,b)d=(a,b) ， 我们首先证明每个 a,ba,ba,b 的线性组合是 ddd 的倍数。 我们现在证明每一个 ddd 的倍数也是 a,ba,ba,b 的线性组合。 证毕。 定理3.10 定理3.10：如果 a,ba,ba,b 是不全为 000 的整数，那么正整数 ddd 是 a,ba,ba,b 的最大公因子，当且仅当 \\qquad\\qquad（i） d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b； \\qquad\\qquad（ii） 如果 ccc 是整数且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b ，那么 c∣dc\\mid dc∣d； 证明：\\qquad假设 d=(a,b)d=(a,b)d=(a,b) ， 证毕。 不依赖于整数的有序性定义最大公因子。 定义：令 是不全为零的整数。这些整数的公因子中最大的整数就是最大公因子。 的最大公因子记为 。(注意 在这里面出现的顺序不影响结果) 引理3.2 引理3.2：如果 是不全为零的整数，那么 。 欧几里得算法 引理3.3 - (a，b) = (b，a%b) 引理3.3 如果 是整数且 ，其中 是整数，那么 。 证明：在定理3.7中，取 ，即得到该引理。 定理3.11（欧几里得） 定理3.11(欧几里得算法) 证明：令 是正整数且满足 ，那么通过连续运用带余除法，我们求得 . 可以确定最后一定会有一个余数为零，这是因为余数组成的序列 所包含的项的个数不会大于 (因为每个余数都是整数)，由引理3.3，我们得到 ，因此 ，这是最后一个非零余数。 欧几里得算法是一种快速地求最大公因子的方法。接下来，当我们用欧几里得算法求两个正整数的最大公因子来估算除法的最大步数时会看到这一点。 int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 定理3.12-斐波那契与欧几里得 定理3.12：令 和 是斐波那契数列中连续的两项，那么用欧几里得算法证明 一共需要 步除法。 证明： 证毕。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 欧几里得算法的计算复杂度 定理3.13-拉梅定理 定理3.13（拉梅定理）：用欧几里得算法计算两个正整数的最大公因子时，所需的除法次数不会超过两个整数中较小的那个十进制的位数的5倍。 证明： 推论3.13.1 求两个正整数 的最大公因子需要 次的位运算。 拉梅定理的推论，它告诉我们欧几里得算法是非常高效的。 证明： 定理3.14（扩欧） 用线性组合的方式来表示最大公因子 如果已经求得 ，那么因为 ， 我们有 从 到 ，最终 这显示了如何沿着欧几里得算法产生的等式递进最终使得 的最大公因子 可以表示为 的线性组合。 自底向上计算 扩展欧几里得算法只需用一次欧几里得算法就能计算出 。 然而写算法时，由于使用递归，倒推回去也可。 若使用以下方法。若输入数据不满足被除数大于除数，答案错误。 扩展欧几里得算法(自顶向下计算) 定理3.14 令 是正整数，那么 ， 其中 是下面定义的递归序列的第 项： 且 ， 其中 ，而 是欧几里得算法求 时每一步的商。 证明：我们将证明 ​ ， (3.2) 因为 ，一旦等式(3.2)成立，我们就有 。 我们用第二数学归纳原理来证明。 对于 ，有 。因此对 成立。类似地， ，所以对于 成立。 现在假设 ， 对于 成立。那么由欧几里得算法的第 步，我们有 ， 由归纳假设，得到 * * * 。 证毕。 算术基本定理 引理3.4 引理3.4 如果 是正整数，满足 且 ，则 。 证明：由于 ，存在整数 使得 。等式两边同时乘以 ，得 。根据定理1.9， ，这是因为这是 的线性组合，而它们都可以被 整除。因此 。 引理3.5 引理3.5：如果 整除 ，其中 为素数，且 是正整数，则存在整数 ，使得 p∣aip\\mid a_ip∣ai​ 。 证明：我们通过数学归纳法证明。①当 时，显然成立。②假定结果对 成立。考虑 个整数的乘积 ，它是能够被素数 整除的(这是如果，我们要证明的是 则，，，)。对于 的其中 项，要么是 ，要么是 。若 ，则由引理3.4， 。若 ，由归纳假设， 。因此存在整数 ，使得 。这样就证明了这个结果。 定理3.15-算术基本定理 定理3.15（算术基本定理）：每个大于 111 的正整数都可以被唯一地写成素数的乘积，在乘积中的素因子按照非降序排列。 证明： ①我们采用反证法：证明：每个大于 111 的数必能写成素数的乘积。 假定某正整数不能被写成素数的乘积。设 是这样的整数中最小的(良序性)。如果 是素数，那么它显然是素数的乘积，即一个素数 。所以 一定是合数。设 ，其中 。但是由于 都比 小，因此它们一定可以写成素数的乘积(良序性)。又由于 ，我们得到 也是素数的乘积。这个矛盾说明每个正整数都可以写成素数的乘积。 ②我们现在通过证明这个分解的唯一性来完成算术基本定理的证明。 假定整数 有两种不同的素数分解形式： ，其中 和 为素数，且 。 在这两个分解式中约去相同的素数，得到 *。*其中等式左边的素数与右边的不同， 。 然而，这导致了与引理3.5的矛盾。由该引理，一定存在某一个 使得 整除 ，这是不可能的，因为每个 都是与 不同的素数。 因此，正整数 nnn 的素因子分解是唯一的。■\\qquad\\qquad\\qquad\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 整数分解中把素因子组合成幂的形式被称为素幂因子分解（prime-power factorization）。 唯一因子分解在哪里不成立：每个正整数有唯一的素因子分解这个事实是整数集合与其他一些集合共有的一个特殊性质，但并非所有的数系都有这个性质。 素因子分解的应用 用素因子分解描述最大公因子 求两个正整数的最小公倍数。 定义：两个非零整数 的最小公倍数（lcm）是能够被 整除的最小正整数。 的最小公倍数记为 。也可用记号 。 如果 其中 是 的素因子。 其中 是 的素因子。 则 ，其中 是 素因子的并集 。 求解大整数的素因子分解比较耗费时间。因此，我们想要一种求两个整数的最小公倍数但却不使用整数的素因子分解的方法。 引理3.6 证明：分类讨论。 定理3.16 定理3.16 如果 是正整数，则 ，其中 分别是 的最小公倍数和最大公因子。 证明： 下述推论将在后面用到。 引理3.7 证明： 狄利克雷定理中一种特殊情形的证明。 关于无理数的结果 因子分解法和费马数 线性丢番图方程","categories":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"初等数论及其应用","slug":"数论/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E8%AE%BA/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"读书笔记/初等数论及其应用/第一章 整数","date":"2021-08-22T16:00:00.000Z","updated":"2021-08-30T11:19:11.767Z","comments":true,"path":"2021/08/23/读书笔记/初等数论及其应用/第一章 整数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B4%E6%95%B0/","excerpt":"","text":"[TOC] 大纲 在最一般的意义下，数论研究各种数集合的性质。 在本章中我们讨论某些特别重要的 数的集合 ，包括整数、有理数和代数数集合。 我们将简单介绍 用有理数逼近实数 的概念，也介绍 序列 (特别是整数序列)的概念，包括古希腊人所研究的一些 垛积数序列 。 一个常见问题是如何由一些初始项来判定一个特别的整数序列。我们将简单讨论一下如何解决这种问题。 利用序列概念，我们定义 可数集合 并且证明 有理数集合是可数的 。我们还引进了求和符号 和 求积符号 ，并建立一些有用的求和公式。 数学归纳法 是数论(和许多数学分支)中最重要的证明方法之一。我们讨论数学归纳法的两种形式，说明如何用它们来证明各种结果，并且解释数学归纳法为什么是一种有效的证明手段。 然后我们介绍著名的 斐波那契 (Fibonacci)数序列，讲述引出这种数的原始问题。 我们将建立与斐波那契数有关的一些恒等式和不等式，其中有些证明就使用了数学归纳法。 本章最后一节讲述数论的一个基本概念：整除性 。 我们将建立整数除法的基本性质，包括带余除法，还将解释如何用 最大整数函数 来表示一个整数去除另一个整数的商和余数。（也讲述了最大整数函数许多有用的性质） 数和序列 本节将介绍一些基础知识，它们在本书中通篇使用。 特别地，我们将涉及数论中所研究的重要的数集合、整数序列的概念、求和与求积符号。 良序性质 良序性质：每个非空的正整数集合都有一个最小元。 良序性质可以作为定义正整数集合的公理，或者由一组公理推导出来。 正整数集合 定理1.1-2\\sqrt{2}2​ 是无理数 定理1.1： 2\\sqrt{2}2​ 是无理数。 证明1：设 2=pq\\sqrt{2}=\\dfrac{p}{q}2​=qp​ 互质，证明 p,qp,qp,q 为偶数。 证明2：使用良序性。 定义：如果存在整数 ，使得 ，则称实数 是有理数。否则 为无理数。 整数集合、正整数集合、有理数集合和实数集合通常分别记为。我们也用来表示 属于集合S。 「最大整数函数」： 中的最大整数记为，是小于或等于 的最大整数，即 是满足 的整数。 最大整数函数也被称为取整函数(floor function)。在计算机科学中通常用记号 代替 。 「上整数函数」：记为 ，是大于或等于 的最小整数。 例1.4：证明如果 是整数，则对于任意实数 ，都有 。 定义：实数 的分数部分(fractional part)记为 ，是 与 的差，即 。 丢番图逼近 我们知道一个实数和与之最接近的整数的距离不超过 12\\dfrac{1}{2}21​ 。但我们可否证明一个实数的前 kkk 个倍数中的某一个一定更接近某个整数？ 数论中一个很重要的部分称为丢番图逼近，它正是研究这类问题的。特别地，丢番图逼近着重研究用有理数逼近实数的问题。 我们将要证明在实数 $\\alpha $ 的前 nnn 个倍数中至少有一个实数与最接近它的整数的距离小于 1n\\dfrac{1}{n}n1​ 。 这个证明是基于德国数学家狄利克雷(Dirichlet)提出的鸽笼原理。 定理1.2-鸽笼原理 定理1.2 鸽笼原理：如果把 个或者更多的物体放入 个盒子中，那么至少有一个盒子中有两个或更多的物体。 证明： 如果 k 个盒子中的任何一个中都没有多于一个的物体，那么所有物体的总数至多为 k 。这个矛盾说明有一个盒子中至少有两个或者更多的物体。 定理1.3-狄利克雷逼近原理 现在我们来叙述并证明狄利克雷逼近定理，它能够保证一个实数的前 n 个倍数之一必定在某个整数的 邻域内。 定理1.3（狄利克雷逼近定理）：如果 是一个实数，n 是一个正整数，则存在整数 和 ，使得 考虑 个数 。这 个数是数 的分数部分，所以 。这 个数中的每一个都位于 个互不相交的区间中的一个。 对于定理1.3我们采取的是狄利克雷1834年的原始证明。把定理1.3中的 替换为 ,可以得到一个更强的结论。它的证明并不困难(见习题32)。进一步，在习题34中我们展示如何用狄利克雷逼近定理来证明对于一个无理数 ，存在无数多个不同的有理数 使得 。这是丢番图逼近定理中的一个重要结果。我们将在第12章再回到这个话题 序列：序列 {an}\\{ a_n\\}{an​} 是一列数 a1,a2,a3,⋯a_1,a_2,a_3,\\cdotsa1​,a2​,a3​,⋯ 。 数论中的一个常见问题是如何寻找构造序列的通项公式或者规则。 我们现在定义什么是可数集，并且证明：当且仅当一个集合的元素可以被列为一个序列时，它是可数的。 定义一个集合可数（countable），如果它是有限的或者是无穷的但与正整数集合之间存在一个一一映射。如果一个集合不是可数的，则称为不可数（uncountable）。 一个无穷集合是可数的当且仅当其中的元素可以被列为一个由正整数标记的序列。为了看到这一点，只需注意从正整数集合到一个集合 sss 的一一映射 fff 其实就是把集合中的元素列成序列 a1,a2,⋯ ,an,⋯a_1,a_2,\\cdots,a_n,\\cdotsa1​,a2​,⋯,an​,⋯ ，其中 ai=f(i)a_i=f(i)ai​=f(i) 。 定理1.4-有理数集合是可数的 定理1.4：有理数集合是可数的。 习题45将会证明实数集合不可数。 和与积 和的记号： ∑k=1nak=a1+a2+⋯+an\\sum_{k=1}^{n}a_k=a_1+a_2+\\cdots+a_n∑k=1n​ak​=a1​+a2​+⋯+an​ 。字母 kkk 称为求和下标（index of summation）。 三个和式 ∑j=mncaj=c∑j=mnaj\\sum_{j=m}^{n}ca_j=c\\sum_{j=m}^{n}a_j∑j=mn​caj​=c∑j=mn​aj​ ； ∑j=mn(aj+bj)=∑j=mnaj+∑j=mnbj\\sum_{j=m}^{n}(a_j+b_j)=\\sum_{j=m}^{n}a_j+\\sum_{j=m}^{n}b_j∑j=mn​(aj​+bj​)=∑j=mn​aj​+∑j=mn​bj​ ； ∑i=mn∑j=pqaibj=(∑i=mnai)(∑j=pqbj)=∑j=pq∑i=mnaibj\\sum_{i=m}^{n}\\sum_{j=p}^{q}a_ib_j= \\left(\\sum_{i=m}^{n}a_i \\right )\\left(\\sum_{j=p}^{q}b_j \\right)=\\sum_{j=p}^{q}\\sum_{i=m}^{n}a_ib_j∑i=mn​∑j=pq​ai​bj​=(∑i=mn​ai​)(∑j=pq​bj​)=∑j=pq​∑i=mn​ai​bj​ 例1.15 求等比数列 的前 n+1n+1n+1 项的和。 推导出 当 。 例1.17 证明：的前 个连续方幂之和比的下一个方幂小1。 即 形如 的和被称为是叠进的。其中 是一数列。 。 例1.18 三角数是一个数列，其中 为第 行有 个点的 行三角阵列中点的个数。 推导 的另一种求法见习题7。 与求和类似，我们也给乘积定义一个记号。数 的积记为 字母 为虚变量，可以用任意字母代替。 阶乘函数在数论中通篇出现。从这里开始，补充笔记 定义： 数学归纳法 定理1.5-数学归纳原理 使用数学归纳法证明一个特定命题对所有正整数都成立必须实现「两步」。 第一，设 为我们认为命题成立的那个正整数集合，必须说明1属于 ；即命题对整数1为真。这叫做基础步骤。 第二，必须证明对每个正整数 ，如果 属于 则 也属于 ；即如果这个命题对 为真，则对 也为真。这被称为归纳步骤。 一旦这两步都完成了，我们就可以由数学归纳原理得到结论：命题对所有正整数为真。 定理1.5（数学归纳原理）：一个包含整数 的正整数集合如果具有如下性质，即若其包含整数 ,则其也包含整数 ,那么这个集合一定是所有正整数的集合。 证明 ：设 是包含整数 的正整数集合，并且如果它包含整数 ，则一定包含 。假定(为了推出矛盾) 不是所有正整数的集合。因此有某个正整数不包含在集合 中。由「良序性质」，由于不包含在 中的正整数集合是非空的，所以不包含于 中的所有正整数中存在一个最小的正整数，记为 。注意由于 在中，故 。 现在，由于 (因为不存在正整数 满足 )，故 是小于 的正整数，并且 一定在集合 中。但是因为包含 ，从而一定包含 。这与假定为不包含于 中的最小整数矛盾。这说明 一定是所有正整数的集合。 例：证明 : 对于正整数，有 基础步骤 :，所以这一步成立。 归纳步骤 :我们的归纳假设为公式对于 成立，即假定 .使用归纳假设，我们有 由于基础步骤和归纳步骤都完成了，我们知道结果成立。 例：证明 :，对任意正整数 成立。 基础步骤 归纳步骤 定理1.6-第二数学归纳原理 定理1.6（第二数学归纳原理）：对于包含 的正整数集合，如果它具有下述性质：对每一个正整数 。如果它包含全体正整数 ，则它也包含整数 ，那么这个集合一定是由所有正整数构成的集合。 证明：设是一个包含的整数集合，并且对任意正整数 ，如果它包含，则它也包含 。设 是所有正整数 的集合， 满足：小于等于 的正整数都在 中。则 在 中，并且，根据假设，我们看到如果 在 中，则 在 中。因此，由数学归纳法原理，必为所有正整数的集合，故显然 也是所有正整数的集合，因为 是 的一个子集。 1能使命题成立。 若 均使命题成立，则可推出 也使命题成立。 为了区别于数学归纳原理，第二数学归纳原理有时也称为强归纳，而数学归纳原理也 称为弱归纳。 递归定义 数学归纳原理提供了一种方法来定义函数在正整数处的值。我们不用明确给出函数在 处的值，而是给出其在 处的值，并且给出对于任意正整数 ，从函数在 处的值来寻找在 处的值的规则。 2. 定义：我们说函数 fff 是递归定义的，如果指定了 在 处的值，而且对于任意正整数 ，都提供了一个规则来根据 确定 。 数学归纳原理可以用来证明递归定义的函数在每个正整数上都是唯一定义的（参看本节末尾的习题25）。 第二数学归纳原理也可以作为递归定义的基础。我们可以如下定义一个定义域为正整数集合的函数：首先指定它在 处的值，并且对每个正整数 ，给定一个根据 的值求 的规则。这将是在1.4节中讨论的斐波那契数序列的定义的基础。 斐波那契数 例1.27 证明： 叠进和 数学归纳原理 例1.28 用第二数学归纳原理证明对 我们用第 nnn 个斐波那契数的一个显式计算公式来结束本节。我们在正文中不给出证明，但是在本节末的习题41和习题42中概述了如何分别利用线性齐次递归关系和母函数来求这个公式。进一步，习题40要求通过说明这些项满足与斐波那契数相同的递归定义来证明这个恒等式，习题45要求用数学归纳法来证明。前两个方法的优点是它们可以用来发现公式，而后两个方法却不能。 定理1.7 定理1.7 设 整除性 一个整数可以被另一个整数整除的概念在数论中处于中心地位。 定义：如果 为整数且 ，我们说 整除 是指存在整数 使得 。如果 整除 ，我们还称 是 的因子，且称 是 的倍数。 定理1.8 定理1.8：如果 是整数，且 ，则 。 证明： 定理1.9 定理1.9：如果 a,b,m,na,b,m,na,b,m,n 是整数，且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b，则 c∣(ma+nb)c\\mid (ma+nb)c∣(ma+nb) 。 定理1.10 定理1.10（带余除法）：如果 a,ba,ba,b 是整数且 b&gt;0b&gt;0b&gt;0 ，则存在唯一的整数 q,rq,rq,r ，使得 a=bq+ra=bq+ra=bq+r ，0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。 用良序性证明带余除法 证明： 例1.36 证明 给定一个正整数 ，可以根据整数被 除的余数把它们分类。 定义：奇数，偶数 我们将在第4章继续讨论这个问题。 最大公因子 定义：不全为零的整数 a,ba,ba,b 的最大公因子是指能同时整除 a,ba,ba,b 的最大整数。 a,ba,ba,b 的最大公因子记为 (a,b)(a,b)(a,b) ，有时也记为 gcd(a,b)gcd(a,b)gcd(a,b) 。 注意当 nnn 为正整数时， (0,n)=(n,0)=n(0,n)=(n,0)=n(0,n)=(n,0)=n 。 利用整数的有序性定义了整数的最大公因子。 定义：设 a,ba,ba,b 均为非零整数，如果 a,ba,ba,b 的最大公因子 (a,b)=1(a,b)=1(a,b)=1 ，则称 a,ba,ba,b 互素 。 约定 (0,0)=0(0,0)=0(0,0)=0 。 \\begin{align*}\\label{2} & X(0) = x(0)W_{N}^{0\\cdot0} + x(1)W_{N}^{0\\cdot1} + \\cdots + x(N-1)W_{N}^{0\\cdot(N-1)}\\\\ & X(1) = x(0)W_{N}^{1\\cdot0} + x(1)W_{N}^{1\\cdot1} + \\cdots + x(N-1)W_{N}^{1\\cdot(N-1)} \\\\ & \\cdots \\\\ & X(N-1) = x(0)W_{N}^{(N-1)\\cdot0} + x(1)W_{N}^{(N-1)\\cdot1} + \\cdots + x(N-1)W_{N}^{(N-1)\\cdot(N-1)} \\\\ \\end{align*} 定义、概念","categories":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"初等数论及其应用","slug":"数论/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E8%AE%BA/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/BFS-最小步数模型","date":"2021-08-22T06:23:46.074Z","updated":"2021-08-22T06:26:39.703Z","comments":true,"path":"2021/08/22/DS_Algorithm证明与讲解/搜索/BFS-最小步数模型/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/22/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"八数码 判重 康托展开 unordered_map 状态存储","categories":[],"tags":[]},{"title":"贪心算法的证明","slug":"DS_Algorithm证明与讲解/贪心/贪心算法的证明","date":"2021-08-21T16:00:00.000Z","updated":"2021-08-22T09:45:55.046Z","comments":true,"path":"2021/08/22/DS_Algorithm证明与讲解/贪心/贪心算法的证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/22/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E/","excerpt":"","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"离散化","slug":"DS_Algorithm证明与讲解/基础算法/离散化","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-16T09:31:22.872Z","comments":true,"path":"2021/08/16/DS_Algorithm证明与讲解/基础算法/离散化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/","excerpt":"","text":"思路 将所有值排序 去重 二分查找","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford","date":"2021-08-15T03:19:20.673Z","updated":"2021-08-15T03:19:38.275Z","comments":true,"path":"2021/08/15/DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/Bellman-Ford/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BFS","slug":"题目/搜索/BFS","date":"2021-08-14T16:00:00.000Z","updated":"2021-08-15T02:43:06.537Z","comments":true,"path":"2021/08/15/题目/搜索/BFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/BFS/","excerpt":"","text":"多源BFS AcWing 173. 矩阵距离 最小步数模型 AcWing 1107. 魔板 双端队列广搜 AcWing 175. 电路维修 洛谷 P1948 [USACO08JAN]Telephone Lines S 洛谷 CF1063B Labyrinth 洛谷 CF1031D Minimum path","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Dijkstra","slug":"DS_Algorithm证明与讲解/图论/最短路/Dijkstra","date":"2021-08-14T16:00:00.000Z","updated":"2021-08-15T03:18:54.880Z","comments":true,"path":"2021/08/15/DS_Algorithm证明与讲解/图论/最短路/Dijkstra/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/Dijkstra/","excerpt":"","text":"Dijkstra证明 朴素版Dijkstra 堆优化版 Dijkstra","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://xiaoke-jin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"BFS求单源最短路证明","slug":"DS_Algorithm证明与讲解/搜索/BFS求单源最短路证明","date":"2021-08-13T16:00:00.000Z","updated":"2021-08-15T02:29:07.251Z","comments":true,"path":"2021/08/14/DS_Algorithm证明与讲解/搜索/BFS求单源最短路证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/14/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS%E6%B1%82%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AF%81%E6%98%8E/","excerpt":"","text":"BFS求单源最短路证明 2021-08-15 算法导论 P364 挖个坑，日后补充。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"搜索讲解","slug":"DS_Algorithm证明与讲解/搜索/BFS&DFS","date":"2021-08-12T16:00:00.000Z","updated":"2021-08-15T02:23:59.450Z","comments":true,"path":"2021/08/13/DS_Algorithm证明与讲解/搜索/BFS&DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/13/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS&DFS/","excerpt":"","text":"四联通与八联通 「四联通」 int dx[5] = &#123;-1, 0, 1, 0&#125;, dy[5] = &#123;0, 1, 0, -1&#125;;for(int i = 0; i &lt; 4; i++) for(int j = 0; j &lt; 4; j++)&#123; int nx = x + dx[i], ny = y + dy[j]; &#125; 「八连通」 // 1int dx[10] = &#123;-1, -1, 0, 1, 1, 1, 0, -1&#125;, dy[10] = &#123;0, 1, 1, 1, 0, -1, -1, -1&#125;;// 2for(int i = x - 1; i &lt;= x + 1; i++) for(int j = y - 1; j &lt;= y + 1; j++)&#123; if(i == x &amp;&amp; j == y)continue; // 遍历到自己，跳过&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS求最短路","slug":"DS_Algorithm证明与讲解/搜索/BFS大纲","date":"2021-08-12T16:00:00.000Z","updated":"2021-08-15T02:23:30.640Z","comments":true,"path":"2021/08/13/DS_Algorithm证明与讲解/搜索/BFS大纲/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/13/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"本质：转换为Dijkstra 扩展 多源BFS 最小步数模型 双端队列广搜","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"高精度板子","slug":"DS_Algorithm证明与讲解/基础算法/高精度板子","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:21:53.095Z","comments":true,"path":"2021/08/12/DS_Algorithm证明与讲解/基础算法/高精度板子/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%9D%BF%E5%AD%90/","excerpt":"","text":"加 ​ 减 ​ 乘 ​ 除 ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://xiaoke-jin.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"RMQ题目","slug":"题目/基础算法/RMQ","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:23:31.923Z","comments":true,"path":"2021/08/12/题目/基础算法/RMQ/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/RMQ/","excerpt":"","text":"AcWing 1273. 天才的记忆 离线算法 预处理：O(nlog⁡n)O(n\\log{n})O(nlogn)，查询：O(1)O(1)O(1)。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"}]},{"title":"并查集题目","slug":"题目/数据结构/并查集","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:32:57.133Z","comments":true,"path":"2021/08/12/题目/数据结构/并查集/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"基础操作：查询，合并 AcWing 836. 合并集合 并查集扩展版 维护集合中元素数量的并查集 AcWing 837. 连通块中点的数量 进阶题目 AcWing 240. 食物链 普通做法：扩展域 带权并查集的做法：AcWing 240. 食物链(带权并查集) Kruskal","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"数据结构","slug":"题目/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://xiaoke-jin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"STL","slug":"DS_Algorithm证明与讲解/基础算法/STL","date":"2021-08-10T16:00:00.000Z","updated":"2021-08-22T09:35:19.144Z","comments":true,"path":"2021/08/11/DS_Algorithm证明与讲解/基础算法/STL/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/11/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/STL/","excerpt":"","text":"sort pair 基本操作 pair&lt;int, int&gt; p;p.first; // 第一个元素p.second; // 第二个元素// 初始化pair&lt;int, int&gt; p = (1, 1);p = make_pair(10, &quot;yxc&quot;);p = (20, &quot;abc&quot;);// 使用 &#123;&#125;快速构造一个pairq.push_back(&#123;1, 1&#125;); 支持比较运算 以first为第一关键字，以second为第二关键字（字典序）。 vector 初始化 vector&lt;int&gt; a; // 定义一个vectorvector&lt;int&gt; a(n); // 定义一个长度为 n的vectorvector&lt;int&gt; a(10, 3); // 定义一个长度为 10,且每个元素值为 3的vectorvector&lt;int&gt; a[10]; // 定义 10个vector 函数 size(); // 返回vector中元素个数empty(); // 若vector为空,返回true; 否则返回 falseclear(); // 清空vectorpush_back()/pop_back(); // 在末尾插入/删除一个元素front()/begin(); // 返回第一个/最后一个元素// 返回向量头指针,指向第一个元素/返回向量尾指针,指向向量最后一个元素的「下一个位置」begin()/end();[]; // 支持数组操作; 下标从0开始 三种遍历方式 for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;// vector&lt;int&gt;::iterator可用 auto代替for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;for(auto x : a) cout &lt;&lt; x &lt;&lt; &quot; &quot;;cout &lt;&lt; endl; 支持比较运算 vector&lt;int&gt; a(4, 3), b(3, 4);// 按字典序比较if(a &lt; b) puts(&quot;a &lt; b&quot;); string 函数 size()/length() // 字母个数empty() // 是否为空clear() // 清空substr(n) // 返回从下标 n开始的子串substr(n, m) // 返回从下标 n开始, 长度为 m的子串; 若越界的话, 会输出到最后一个字符为止。printf(&quot;%s\\n&quot;, a.c_str()); // 使用 %s输出字符串 操作 string a = &quot;yxc&quot;;a += &quot;nb&quot;; queue 函数 size()empty()push()pop()front()back()q = queue&lt;int&gt;();// 重新构造一次即可清空队列; 没有 clear函数 priority_queue 定义 // 默认定义大根堆priority_queue&lt;int&gt; heap;// 定义小根堆// 1.插入负数// 2.priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; 函数 push()top()pop()// 无 clear() stack 函数 size()empty()push()pop()top() deque 函数 size()empty()clear()front()back()push_back()/pop_back()push_front()/pop_front()begin()/end()[] set 不能有重复元素 map multiset 可以有重复元素 multimap unordered_set unordered_map unordered_multiset unordered_multimap bitset bitset&lt;n&gt; s; // 定义长度为 n的bool数组/* 支持位运算：~ &amp; | ^ &lt;&lt; &gt;&gt; * ==, != * [] */count() // 返回有多少个 1any() // 判断是否至少有一个 1none() // 判断是否全为 0set() // 把所有位置为 1set(k, v) // 将第k位变为 vreset() // 把所有位变成 0 flip() // 所有位取反flip(k) // 把第k位取反","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://xiaoke-jin.github.io/tags/STL/"}]},{"title":"洛谷名字颜色","slug":"杂文/洛谷名字颜色","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T05:07:28.636Z","comments":true,"path":"2021/08/10/杂文/洛谷名字颜色/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E6%9D%82%E6%96%87/%E6%B4%9B%E8%B0%B7%E5%90%8D%E5%AD%97%E9%A2%9C%E8%89%B2/","excerpt":"","text":"名字颜色规则 动态等级是根据用户在一段时间内的刷题、社区活跃、打卡、题解、违规情况，按照一定算法得出的结果，该算法不公开。动态等级比较准确的表现了用户一段时间内在洛谷的综合行为。 动态等级由 -1 到 4， 管理员的用户名颜色为 紫色\\color{purple}{紫色}紫色，不受动态等级影响。 用户名的颜色为分别对应为棕色、灰色、蓝色、绿色、橙色、红色。 -1 棕色\\color{brown}{棕色}棕色 作弊者 0 灰色\\color{Grey}{灰色}灰色 见习用户 即咕值&lt;100&lt;100&lt;100的用户 1 蓝色\\color{blue}{蓝色}蓝色 普通用户 即咕值在[100,119][100,119][100,119]的用户 2 绿色\\color{green}{绿色}绿色 算法爱好者 即咕值在[120,169][120,169][120,169]的用户 3 橙色\\color{orange}{橙色}橙色 刷题健将 即咕值在[170,229][170,229][170,229]的用户 4 红色\\color{RED}{红色}红色 虐题狂魔 即咕值&gt;229&gt;229&gt;229的用户 新用户的初始动态等级为 0，也就是 灰色\\color{Grey}{灰色}灰色 用户名。用户在洛谷中按照洛谷社区规则使用各项功能，会增加动态等级。如果长时间不使用洛谷或者有违规行为，可能会降级。除非用户有严重违规行为或者在长时间不使用洛谷且未进行实名认证的情况下，一旦用户达到蓝名，则不会掉到 灰色\\color{Grey}{灰色}灰色 。你可以在打卡之后在打卡结果中看到自己用户名的颜色。在犇犇或者讨论中询问颜色名字和咕值相关的一些问题将被和谐。 如果用户抄袭题解或非恶意比赛作弊，将降级至棕名及名字旁带有 Cheater\\color{brown}{Cheater}Cheater 标签，每次查到持续 15 日，并且在 90 日内不得在任何比赛获得排名。15 日后，变成 灰色\\color{Grey}{灰色}灰色 并清空所有 ACACAC 记录。（即，变为 Unaccepted 100Unaccepted\\ \\ \\ 100Unaccepted 100 分状态）。（注：棕名\\color{brown}{棕名}棕名用户是仅次于封号的最严厉警告，如果发生任何违反洛谷社区规则的事情，直接立刻封禁一年。） 动态等级影响洛谷内很多权限，例如创建比赛、团队、提交冷却时间、图床、下载数据等。灰名\\color{Grey}{灰名}灰名 会有较多的限制。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://xiaoke-jin.github.io/tags/%E6%B4%9B%E8%B0%B7/"}]},{"title":"LaTeX","slug":"语言/LaTeX","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-23T01:43:45.265Z","comments":true,"path":"2021/08/10/语言/LaTeX/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E8%AF%AD%E8%A8%80/LaTeX/","excerpt":"","text":"LaTeX入门 LaTeX入门 KaTeX KaTeX源码 其他网站 在线LaTeX编辑器","categories":[{"name":"语言","slug":"语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://xiaoke-jin.github.io/tags/LaTeX/"}]},{"title":"Markdown","slug":"语言/Markdown","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-29T05:26:31.573Z","comments":true,"path":"2021/08/10/语言/Markdown/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E8%AF%AD%E8%A8%80/Markdown/","excerpt":"","text":"Markdown编辑器 Markdown语法 如何在Markdown中输入数学公式 Markdown KaTeX多个公式对齐 格式手册 行间公式 如果这些多行对齐的公式需要 编号，请用 align 或 equation 环境； 请使用 \\begin&#123;aligned&#125; ... \\end&#123;aligned&#125; 表示多行对齐的公式； 每行式子分别编号：使用 align d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{align} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{align} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​​ 一坨式子一个编号：使用 aligned d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{aligned} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{aligned} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​ 不编号：align* a=b+c=e+f\\begin{align*} a&amp;=b+c\\\\ &amp;=e+f \\end{align*} a​=b+c=e+f​ 公式左对齐 \\begin{align*}\\label{2} & X(0) = x(0)W_{N}^{0\\cdot0} + x(1)W_{N}^{0\\cdot1} + \\cdots + x(N-1)W_{N}^{0\\cdot(N-1)}\\\\ & X(1) = x(0)W_{N}^{1\\cdot0} + x(1)W_{N}^{1\\cdot1} + \\cdots + x(N-1)W_{N}^{1\\cdot(N-1)} \\\\ & \\cdots \\\\ & X(N-1) = x(0)W_{N}^{(N-1)\\cdot0} + x(1)W_{N}^{(N-1)\\cdot1} + \\cdots + x(N-1)W_{N}^{(N-1)\\cdot(N-1)} \\\\ \\end{align*} 数学公式 数学公式中的中文文字 必须置于 \\text&#123;&#125; 命令之中，而变量、数字、运算符、函数名称则必须置于 \\text&#123;&#125; 命令之外。请不要在 \\text&#123;&#125; 命令中嵌套数学公式； 使用 array 环境时请注意 实际列数与对齐符号的数量保持一致。例如下面的公式中，数据实际有 3 列（&amp; 是列分隔符），因此需要 3 个对齐符号（l/r/c 分别表示左、右、居中对齐）。 F1={01,11}F2={01,12,11}\\begin{array}{lll} F_1=\\{\\frac{0}{1},&amp;&amp;\\frac{1}{1}\\}\\\\ F_2=\\{\\frac{0}{1},&amp;\\frac{1}{2},&amp;\\frac{1}{1}\\}\\\\ \\end{array} F1​={10​,F2​={10​,​21​,​11​}11​}​ LaTeX公式的要求 使用 Roman 体表示常量和函数。使用 Italic 体表示变量。 如果遇到没有预先定义好的需要使用 Roman 体的 函数名，我们可以使用 $\\operatorname&#123;something&#125;$ 来产生，如我们可以使用 $\\operatorname&#123;lcm&#125;$ 产生正体的最小公倍数（函数）符号。 同理，产生 Roman 体的 常量 应用 $\\mathrm&#123;&#125;$；产生 Roman 体粗体符号应用 $\\mathbf&#123;&#125;$； 产生 Italic 体粗体符号应用 $\\boldsymbol&#123;&#125;$（如向量 ）。 对于多字母的变量，应当使用 $\\textit&#123;&#125;$。 其他非数学内容，包括英文、特殊符号等，一律使用 $\\text&#123;&#125;$。中文我们则建议不放在 LaTeX 公式中。 在行内使用分数的时候，请使用 $\\dfrac&#123;&#125;&#123;&#125;$。比如 $\\dfrac&#123;1&#125;&#123;2&#125;$，效果 12\\dfrac{1}{2}21​ ，而不是 $\\frac&#123;1&#125;&#123;2&#125;$，效果 12\\frac{1}{2}21​。 组合数请使用 \\dbinom&#123;n&#125;&#123;m&#125;，效果 (nm)\\dbinom{n}{m}(mn​)，而不是 &#123;n \\choose m&#125;（在 LaTeX 中这种写法已不推荐）；与上一条关于分数的约定相似，请不要使用 \\binom&#123;n&#125;&#123;m&#125;，效果 (nm)\\binom{n}{m}(mn​)。 在不会引起歧义的情况下，请用 $\\times$ 代替星号。叉乘请使用 $\\times$，点乘请使用 $\\cdot$。如 a×ba\\times ba×b，a⋅ba\\cdot ba⋅b ，而不是 a∗ba*ba∗b。 请注意，不要在非代码区域使用任何程序设计语言的表示方式，而是使用 LaTeX 公式。例如，使用 $=$ 而不是 $==$（如 a=ba=ba=b ，而不是 a==ba==ba==b ）、使用 a&lt;&lt;1 或者 $a\\times 2$ 而不是 $a&lt;&lt;1$、使用 $a\\bmod b$ 代替 $a\\%b$（如 a mod ba\\bmod bamodb，而不是 a%ba\\%ba%b ）等。 公式中不要使用中括号连缀（即 C++ 高维数组的表示方式）而多使用下标。 为了统一且书写方便，复杂度分析时大 OOO 记号请直接使用 $O()$ 而不是 $\\mathcal O()$。","categories":[{"name":"语言","slug":"语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://xiaoke-jin.github.io/tags/Markdown/"}]},{"title":"RMQ","slug":"DS_Algorithm证明与讲解/基础算法/RMQ","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:12:18.205Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/RMQ/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/RMQ/","excerpt":"","text":"RMQ RMQ ( Range Minimum/Maximum Query )，即区间最值查询。 RMQRMQRMQ算法一般用较长时间做预处理，时间复杂度为O(nlog⁡n)O(n\\log{n})O(nlogn)，然后可以在O(1)O(1)O(1)的时间内处理每次查询。 ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"}]},{"title":"二分","slug":"DS_Algorithm证明与讲解/基础算法/二分","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:12:12.350Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/二分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分本质 「二段性」 只要能确定目标一定在mid左边或右边。 ​ 注意事项 「边界问题」 小于所有元素，大于所有元素。即不属于查找范围内。 ​ 整数二分 while(l &lt; r) ​ 实数二分 「精度问题」：如果要求保留到n位，则while(r - l &gt; 1e-(n + 2))即可。 ​ ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"前缀和与差分","slug":"DS_Algorithm证明与讲解/基础算法/前缀和与差分","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T04:52:54.480Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/前缀和与差分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 求前n个数的和 a[i] = a[i - 1] + a[i] 求某区间 [l,r][l, r][l,r] 的和 x = a[r] - a[l - 1]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"}]},{"title":"排序题目","slug":"题目/基础算法/排序","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:22:35.154Z","comments":true,"path":"2021/08/10/题目/基础算法/排序/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序 AcWing 105. 七夕祭 AcWing 106. 动态中位数 求中位数 对顶堆 ==对顶思想== 逆序对 AcWing 788. 逆序对的数量 AcWing 107. 超快速排序 最少执行多少交换操作才能对给定的输入序列进行排序。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://xiaoke-jin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"小技巧","slug":"题目/小技巧","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-15T03:37:12.836Z","comments":true,"path":"2021/08/09/题目/小技巧/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"倒着来！！！ 字典序最小 AcWing 12. 背包问题求具体方案 记录方案 AcWing 1076. 迷宫问题","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"小技巧","slug":"题目/小技巧","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"感想","slug":"题目/感想","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-13T08:13:51.981Z","comments":true,"path":"2021/08/09/题目/感想/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/","excerpt":"","text":"2021/08/10/22:41 拜服于大佬的精妙思想 ​ 2021/08/12 最难的不是数据结构与算法的学习，而是对题目进行深入分析，发掘其本质，将其转换为「易于求解的等价问题」。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"刷题注意事项","slug":"题目/注意事项","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-24T09:53:17.583Z","comments":true,"path":"2021/08/09/题目/注意事项/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"注意高精度、LL的坑 求方案数； 逆序对数量； ​ 数组下标需要从1开始 数组堆； 背包DP； 前缀和与差分； 输入字符 注意空字符； %c会读入换行符、空格； %s输入输出会略过空格、换行符； 输入「带空格」的字符矩阵 char g[N][N];for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 2 * m; j++)&#123;//读入末尾换行符 char ch; scanf(&quot;%c&quot;, &amp;ch); if(ch == &#x27; &#x27; || ch == &#x27;\\n&#x27;) ; // 不进行任何操作 else g[i][j/2] = ch; // j/2 &#125; 输入「不带空格」的字符矩阵 输入为数字但「数字之间没有空格」，将其视为字符串。 char g[100][100];for(int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]); 输入单个字符 char op[2];scanf(&quot;%s&quot;, op); ​ 二分 (l + r) / 2 与 (l + r + 1) / 2； 考虑目标元素小于或大于区间内所有元素； ​ 双指针 防止指针越界 ​","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}],"tags":[{"name":"刷题注意事项","slug":"刷题注意事项","permalink":"http://xiaoke-jin.github.io/tags/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}]},{"title":"递推与递归","slug":"题目/基础算法/递推与递归","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-08T14:20:16.399Z","comments":true,"path":"2021/08/08/题目/基础算法/递推与递归/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/08/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"递推 AcWing 95. 费解的开关 递归 AcWing 98. 分形之城","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递推与递归","slug":"递推与递归","permalink":"http://xiaoke-jin.github.io/tags/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/"}]},{"title":"位运算题目","slug":"题目/基础算法/位运算","date":"2021-08-06T16:00:00.000Z","updated":"2021-08-14T07:55:38.057Z","comments":true,"path":"2021/08/07/题目/基础算法/位运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/07/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"位运算 二进制枚举 快速幂，快速加 AcWing 90. 64位整数乘法 AcWing 875. 快速幂","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://xiaoke-jin.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"背包讲解","slug":"DS_Algorithm证明与讲解/DP/背包","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-13T01:13:17.488Z","comments":true,"path":"2021/08/06/DS_Algorithm证明与讲解/DP/背包/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/DP/%E8%83%8C%E5%8C%85/","excerpt":"","text":"01背包 AcWing 423. 采药【01背包DP模型+朴素优化】","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"前缀和与差分题目","slug":"题目/基础算法/前缀和与差分","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-14T07:57:23.609Z","comments":true,"path":"2021/08/06/题目/基础算法/前缀和与差分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 AcWing 99. 激光炸弹 差分 AcWing 100. 增减序列 分析 三种类型的操作 贪心——尽快得到0 优先操作一(可以改变两个数)，然后再使用操作二、三补充。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"}]},{"title":"贪心题目","slug":"题目/贪心/贪心","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-14T07:58:41.013Z","comments":true,"path":"2021/08/06/题目/贪心/贪心/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"贪心","slug":"题目/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"背包题目","slug":"题目/DP/背包","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-15T02:14:43.991Z","comments":true,"path":"2021/08/05/题目/DP/背包/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/05/%E9%A2%98%E7%9B%AE/DP/%E8%83%8C%E5%8C%85/","excerpt":"","text":"求方案数 物品选择顺序不影响方案数 求方案数 AcWing 278. 数字组合 AcWing 1023. 买书 AcWing 1021. 货币系统 求最小方案数 洛谷 P1679. 神奇的四次方数 求最优方案数 AcWing 11. 背包问题求方案数 物品选择顺序影响方案数 AcWing 3643. 上楼梯 求具体方案 要求字典序最小 AcWing 12. 背包问题求具体方案 求任意一个方案 1. 至多、恰好、至少 问题 至多 AcWing 423. 采药 AcWing 1019. 庆功会 洛谷 P1802 5倍经验日 至少 AcWing 1020. 潜水员 恰好 多维费用背包问题 AcWing 8. 二维费用的背包问题 AcWing 1022. 宠物小精灵之收服 墨染空的优化 链接 洛谷 P1509 找啊找啊找GF 分组背包 AcWing 1013. 机器分配 AcWing 487. 金明的预算方案 背包 + AcWing 734. 能量石","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"DP","slug":"题目/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"二分题目","slug":"题目/基础算法/二分","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-13T08:15:31.708Z","comments":true,"path":"2021/08/05/题目/基础算法/二分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/05/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分 AcWing_P790 浮点数二分 AcWing 102. 最佳牛围栏 平均值最大的问题，一般都可以转化为二分。 AcWing 113. 特殊排序 本题的解答过程事实上证明了：任意有向完全图（又称竞赛图）都存在Hamilton路径。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"}]}],"categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"},{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"初等数论及其应用","slug":"数论/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E8%AE%BA/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"题目/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"},{"name":"语言","slug":"语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%AD%E8%A8%80/"},{"name":"小技巧","slug":"题目/小技巧","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"},{"name":"贪心","slug":"题目/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"题目/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/DP/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/tags/Github/"},{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"最短路","slug":"最短路","permalink":"http://xiaoke-jin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"高精度","slug":"高精度","permalink":"http://xiaoke-jin.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"},{"name":"并查集","slug":"并查集","permalink":"http://xiaoke-jin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"STL","slug":"STL","permalink":"http://xiaoke-jin.github.io/tags/STL/"},{"name":"洛谷","slug":"洛谷","permalink":"http://xiaoke-jin.github.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://xiaoke-jin.github.io/tags/LaTeX/"},{"name":"Markdown","slug":"Markdown","permalink":"http://xiaoke-jin.github.io/tags/Markdown/"},{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"name":"排序","slug":"排序","permalink":"http://xiaoke-jin.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"刷题注意事项","slug":"刷题注意事项","permalink":"http://xiaoke-jin.github.io/tags/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"递推与递归","slug":"递推与递归","permalink":"http://xiaoke-jin.github.io/tags/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/"},{"name":"位运算","slug":"位运算","permalink":"http://xiaoke-jin.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]}