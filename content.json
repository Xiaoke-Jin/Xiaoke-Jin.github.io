{"meta":{"title":"Cloud","subtitle":"Just for fun!","description":"Welcome To The World Of Algorithm","author":"A Cloud","url":"http://Xiaoke-Jin.github.io","root":"/"},"pages":[{"title":"","date":"2021-08-01T07:35:22.898Z","updated":"2021-08-01T07:35:22.898Z","comments":true,"path":"manifest.json","permalink":"http://xiaoke-jin.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"文章分类","date":"2021-07-29T14:53:49.000Z","updated":"2021-08-01T04:28:40.971Z","comments":true,"path":"categories/index.html","permalink":"http://xiaoke-jin.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-30T09:43:50.000Z","updated":"2021-08-01T04:28:40.966Z","comments":true,"path":"about/index.html","permalink":"http://xiaoke-jin.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-31T09:56:08.309Z","updated":"2022-03-31T09:56:08.309Z","comments":true,"path":"css/style.css","permalink":"http://xiaoke-jin.github.io/css/style.css","excerpt":"","text":"/* 网页侧边滚动条样式 */ /* ::-webkit-scrollbar { width: 15px; height: 10px; } */ /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar { border-radius: 10px; width: 14px; height: 16px; background-color: #ffffff; } /* 鼠标样式 */ body { cursor: url(https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/default.cur), default; } a, img { cursor: url(https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/pointer.cur), default; } /* 网页底部 */ #footer { background: transparent; } #footer-wrap { color: black; }"},{"title":"link","date":"2021-07-30T09:05:40.000Z","updated":"2021-08-01T04:28:40.976Z","comments":true,"path":"link/index.html","permalink":"http://xiaoke-jin.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T04:53:46.000Z","updated":"2021-08-01T04:28:40.981Z","comments":true,"path":"tags/index.html","permalink":"http://xiaoke-jin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数学书单","slug":"读书笔记/最近/数学/1","date":"2022-04-01T16:00:00.000Z","updated":"2022-04-03T02:43:56.701Z","comments":true,"path":"posts/c63a804b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c63a804b/","excerpt":"","text":"感觉我是要重新学习数学啊。。。 从初中数学开始学吧 先列个书单 科普级 数学也可以这样学（适合10岁以上的孩子自主阅读，177页 神奇的数学：牛津教授给青少年的讲座（260页 数学之书（250页 魔法数学 春夜十话（133页 自然之数：数学想象的虚幻实境（128页 数学思维导论 学会像数学家一样思考（140页 数学女孩系列 这才是好读的数学史 数学概观（344页 ​ 数学万花筒 数学桥：对高等数学的一次观赏之旅 高观点下的初等数学 当代数学：为了人类心智的荣耀（？ 微积分的历程：从牛顿到勒贝格 度量：一首献给数学的情歌 什么是数学：对思想和方法的基本研究 柯朗 ​ 数学史：《古今数学思想》《20世纪数学经纬 George Polya《怎样解题》https://www.zhihu.com/question/510616498/answer/2323536043 数学之美、吴军数学通识讲义、计算之魂 思考的乐趣——Matrix67数学笔记 https://zhuanlan.zhihu.com/p/85561831 陶哲轩教你学数学：主要讲的是数学竞赛中的一些技巧和方法，以及思路。 hard 数学：它的内容、方法和意义 俄 数学天书中的证明 ：本书介绍了35个著名数学问题的极富创造性和独具匠心的证明 数学物理方法","categories":[],"tags":[]},{"title":"","slug":"tmp","date":"2022-03-30T15:55:57.183Z","updated":"2022-03-31T05:18:16.535Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"差分前缀和及其扩展与优化 树状数组——在高阶前缀和上的应用","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/树相关算法","date":"2022-03-29T06:44:31.221Z","updated":"2022-03-30T01:59:29.729Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"树的直径 树上任意两节点之间最长的简单路径即为树的「直径」。 显然，一棵树可以有多条直径，他们的长度相等。 树的重心 概念 树的重心：对于树上的每一个点，计算其所有子树中最大的子树的结点数，这个值最小的点就是这棵树的重心。 性质 代码实现 #include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;bool st[N];int n;int h[N], e[N], ne[N], idx;int node; // node:重心下标int ans = 0x3f3f3f3f;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int DFS(int u)&#123; st[u] = true; int sum = 1, res = 0; // sum: 当前树的结点数, res: 当前结点分割出的连通块中结点最大值 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; int s = DFS(j); // s:子树的结点数 res = max(res, s); sum += s; &#125; &#125; res = max(res, n - sum); // res:当前结点分割出的连通块中结点最大值 if (ans &gt; res) ans = res, node = u; // !!!!! // 如果无需记录node // ans = min(ans, res); return sum;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof(h)); int a, b; for (int i = 1; i &lt; n; i++) &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); add(a, b); add(b, a); &#125; DFS(1); printf(&quot;%d&quot;, ans); return 0;&#125; LCA DFN 括号序","categories":[],"tags":[]},{"title":"关于包产到户","slug":"读书笔记/最近/包产到户","date":"2022-03-25T16:00:00.000Z","updated":"2022-04-02T15:06:25.038Z","comments":true,"path":"posts/f8c972a0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f8c972a0/","excerpt":"","text":"大锅饭 端着碗去村食堂吃饭，不允许自己在家做饭。1962年结束。 生产队 工分制。 天天要去地里伺候庄稼，力气没少花，粮食产量就是不高。F 生产队长分配任务，来了，干活了就有工分，且固定（因为不好说某某少干了，没法量化），有人没干完自己的活，大家一般会帮忙干，仍有较大偷懒空间。 按工分分配粮食，自己在家做饭。 由生产队购买化肥（粉末状的）。 包产到户 我爷说：“那肯定是包产到户好” 商桥镇这边没有宣传小岗村。响应党的政策，就分地了。 分地。一人一亩地（成人小孩都有）。人头数 == 亩数 伴随着分家、交公粮。 化肥自己买，基本都买不起。自己往地里挑粪、堆树叶。G 化肥没那么贵，但大家普遍没有认识到化肥的作用，又想省钱留作他用。所以化肥使用不是很普遍。F 亩产大多 400、500斤。一人交 100 多斤公粮。剩下的自己分配。卖粮食的基本没有，有些甚至不够吃。 后来化肥、种子有了，粮食产量也越来越多。 很多人外出打工，此前基本没有G 外出打工是90年后的事了。F 我爸在木具厂一月挣了150，我爷（铁路工人）说比他一月工资还高。F 问题 天天要干活？地里有那么多事吗？","categories":[],"tags":[]},{"title":"运算方法和运算器","slug":"读书笔记/最近/计算机组成与设计 硬件软件接口/2运算方法和运算器","date":"2022-03-25T16:00:00.000Z","updated":"2022-03-31T05:52:03.853Z","comments":true,"path":"posts/5e0fbec7/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5e0fbec7/","excerpt":"","text":"有符号整数：使用补数表示负数，补数的二进制码即补码。 若用 n 位数码表示整数，则负数 x 的补数为 2n−1−x=2n−1−1−x+12^{n - 1}-x = 2^{n-1} - 1 - x + 12n−1−x=2n−1−1−x+1。2n−1−12^{n-1}-12n−1−1 的二进制表示为 n 个 1，所以 2n−1−1−x2^{n-1}-1-x2n−1−1−x 可用异或完成计算。然后再加一，即求出补码。","categories":[],"tags":[{"name":"计组","slug":"计组","permalink":"http://xiaoke-jin.github.io/tags/%E8%AE%A1%E7%BB%84/"}]},{"title":"","slug":"读书笔记/最近/Linux/1","date":"2022-03-21T12:41:10.182Z","updated":"2022-03-27T15:16:27.610Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"Ubuntu20.04安装界面显示不完整 win10虚拟机Oracle VM VirtualBox安装和使用教程 Ubuntu 常用解压与压缩命令","categories":[],"tags":[]},{"title":"Java基础知识","slug":"读书笔记/最近/Java/1","date":"2022-03-17T16:00:00.000Z","updated":"2022-03-27T15:16:27.607Z","comments":true,"path":"posts/17c79c1f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/17c79c1f/","excerpt":"","text":"创建你的第一个对象：P36 TestDrive ArrayList P133 ArrayList&lt;Egg&gt; MyList = new ArrayList&lt;Egg&gt;(); Egg s = new Egg(); Mylist.add(s); int Size = Mylist.size(); boolean isIn = Mylist.contain(s); // isIn = true int idx = Mylist.indexOf(s); // idx = 0，若不存在则返回 -1 boolean empty = Mylist.isEmpty(); // empty = false Mylist.remove(s); // 删除某一元素 Mylist.remove(int); // 根据下标删除 java 常用的包 默认导入的包 java.lang----包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.applet----包含applet运行所需的一些类。 java.net----包含执行与网络相关的操作的类。 java.io----包含能提供多种输入/输出功能的类。 java.util----包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 Java包文档 包 P155 Math Math的构造函数是私有的。所以不能创建Math对象 Math.round() ：最接近的整数值 Math.min() Math.abs() Math.random()：大于等于 0，小于1。 static static 这个关键词可以标记出不需类实例的方法。一个静态的方法代表说：一种不依靠实例变量也就不需要对象的行为。 以类的名称调用静态方法。 静态的方法是在无关特定类的实例情况下执行的，甚至也不会有该类的实例。因为静态的方法是通过类的名称来调用，所以静态的方法无法引用到该类的任何实例变量。在此情况下，静态的方法也不会知道可以使用哪个实例变量值。 静态的方法也不能调用非静态的方法。 静态变量是共享的。 静态变量是在类被加载时初始化的。 静态变量会在该类的任何对象创建之前就完成初始化。 静态变量会在该类的任何静态方法执行之前就初始化。 final 静态final变量必须初始化 方法1：声明时初始化。 方法2：静态初始化程序。static &#123; &#125; final 也可以修饰实例变量、局部变量、方法的参数。也可以用 final 来防止方法被覆盖或创建子类（不能被继承）。 autoboxing 数字的格式化 日期的格式化 import static 在 JDK 1.5 之后增加了一种静态导入的语法 Java import static静态导入 静态导入使用 import static 语句， 静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法 和 全部静态成员变量、方法。","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"}]},{"title":"2022年日记","slug":"读书笔记/最近/日记/2022_03_18","date":"2022-03-17T16:00:00.000Z","updated":"2022-04-03T02:23:46.149Z","comments":true,"path":"posts/88c0a3fa/","link":"","permalink":"http://xiaoke-jin.github.io/posts/88c0a3fa/","excerpt":"","text":"2022年3月18日 最近深感颓废，回忆起几天前、几月前、几年前的时光，却感到一片模糊，我是不是老年痴呆了啊。 从前美好的、伤心的日子，都难以想起，只有眼前的一团糟心的乱麻。更深感我的人生的无聊、无趣。 所以，我要写日记！！！至少让我的回忆更加充实。让我看看几天前、几月前、几年前的自己，是在怎样地浪费时间、怎样的珍惜时间。 「每天写日记」。hhh，自小学时就有这样的想法了。 小学时，是效仿各大文豪、完成老师留的作业（每天一篇日记）。后来渐渐变成真心想记录生活。 但从来没坚持长久过。hhhh 自小学到现在，中间陆陆续续写过很多，有时感觉这一天真的是平平常常，真没什么可写的，干脆就没写，现在我要改变了，什么鸡零狗碎的都记录下来，总之，就是突出一个记录！不避讳美丑。 从前的日记，都是在纸上的，还总怕别人拿去看了，其实谁会关心这个？那些日记本，也早就无影无踪了。 想起一句话：“生命并不是你活了多少日子，而是你记住了多少日子。” 美好、美好的过去，为什么会渐行渐远呢 我相信这不是我一个人的经历：傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。 ——王小波 《沉默的大多数》 也许人生的事大抵都是如此，走近了看，都不壮观。那些与平常一般无二的日子里，我们做出的毫不庄重的举动，就此影响了我们的一生。 2022. 3 2022. 3. 19 北京林业大学公开课：中国名花 ：张启翔教授讲的很好，很热情。梅、月季 【CCTV纪录频道】《花开中国》全5集 ：茶花、月季、牡丹 最近很喜欢一个词：giant pain 2022. 3. 20 已有的事，后必再有：国家发改委称「坚决防止落入『福利主义』养懒汉的陷阱」 、多地禁止 60 岁以上男性及 50 岁以上女性从事建筑作业，超龄农民工未来路在何方？ 中午：去给钊迪寄快递，吃碗泡面，睡觉。（MD，身份证丢了 27号前搞完 java 基础 2022. 3. 21 星期一 7点起床，生活逐渐正常。 2022. 3. 22 计组学得很烦。 一整个下午在写Java实验。 晚上在刷B站。 2022. 3. 23 早上起晚了，看了会儿 Java，上体育课去了。 下午摸鱼。 晚上 Java。 2022. 3. 24 星期四 早上起晚了。去上操作系统，折磨。 下午计组，这课本真难看。 晚上，心理课。 2022. 3. 25 星期五 很烦，上的什么勾8课，折磨，浪费生命。 2022. 3. 26 上午做核酸，又了解了一些关于包产到户的事。 下午刷知乎，又玩游戏到晚上9点。扭曲丛林萨比是真的多，RNM。 啥也不想干。ACM无望，专业课不想看。 2022. 3. 27 上午学 java，进展比较快。 下午一直在打游戏。 2022. 3. 28 星期一 还是想继续学算法。果然在教室没法学习。 下午，被迫去上美术鉴赏。再不去要寄了。 2022. 3. 29 上午，计组。定点数、浮点数讲完了，接下来要去做实验了。 下午，打游戏。又看比赛。直接到了晚上 9点。又看 wls 直播。 2022. 3. 30 9点起床。体育课，测引体向上。 本月还有2天结束。🍒Σ🍒\\Sigma🍒Σ，偷流量是吧，RNM。 下午，总结 STL 用法；计组好起来了。 晚上看会比赛。 2022. 3. 31 星期四 上午数字图像处理实验、操作系统。 下午计组。上完回寝室打游戏。 这月终于要结束了，下月恢复流量自由。CY，NMSL。 2022. 4 2022. 4. 1 星期五 似乎又是打了一天的游戏。 今天是我的生日。7294 ÷ 365 = 19.98356164…………，已经20岁了。 听 dls 讲数论，感觉有个优秀的老师是多么重要5555，dls 太强啦。 作息时间又不对劲了啊。。。。 2022. 4. 2 10点起床，打游戏；12点，吃饭；12：41，吃完。 2022. 4. 3 星期日","categories":[],"tags":[]},{"title":"关于诗词","slug":"读书笔记/最近/诗词/1","date":"2022-03-17T16:00:00.000Z","updated":"2022-03-27T15:16:27.611Z","comments":true,"path":"posts/5c10641/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5c10641/","excerpt":"","text":"诗经·桃夭 桃之夭夭，灼灼其华。 之子于归，宜其室家。 夭夭：少、好之貌。年轻，美好的样子 子：既可以指男子，也可以指女子 之子：这样一个女子 于归：女子出嫁 国风：代表周朝十五国各国的民间风谣，反映各地的民情风俗 颂：祭祀歌颂祖先的歌诗，有政治意味。 雅：雅正。同样是反映政治的歌诗。 雅、颂：宫廷中任职的大臣、大夫所做的诗。 中国评赏诗的争论：诗是言志还是抒情？ 中国古文中的志，亦即儒家所说的志，是指「士当以天下为己任」，政治上的理想","categories":[],"tags":[]},{"title":"","slug":"读书笔记/最近/Nand2tetris","date":"2022-03-10T08:46:56.443Z","updated":"2022-03-21T11:14:24.180Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"【TED中英字幕】Shimon Schocken:自组织式计算机课程 Nand2tetris 学习笔记","categories":[],"tags":[]},{"title":"The Missing Semester of Your CS Education 中文版","slug":"读书笔记/最近/Missing Semester","date":"2022-03-09T16:00:00.000Z","updated":"2022-03-16T14:45:48.430Z","comments":true,"path":"posts/e43c13f3/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e43c13f3/","excerpt":"","text":"The Missing Semester of Your CS Education 中文版 命令行与shell工具 版本控制 文本编辑 远程服务器 查找文件数据处理 虚拟机 安全","categories":[],"tags":[]},{"title":"","slug":"读书笔记/最近/计算机科学导论/99数字系统","date":"2022-03-02T14:51:51.427Z","updated":"2022-03-16T14:45:48.454Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"非位置化数字系统 罗马数字 每个符号的值是固定的，为了求出一个数的值，我们把所有符号的值相加。 缺点：若要表示较大的数字，需要引入越来越多的符号。 位置化数字系统 十进制数 一个符号在不同的位置会有不同的权重。999：从左到右的三个9分别表示900，90，9 位权，是指数制中每一固定位置对应的单位值。对于多位数，处在某一位上的“1”所表示的数值的大小，称为该位的位权。 基数：每个数码位所用到的不同符号的个数，r进制的基数为r 二进制 可使用两个稳定状态的物理器件表示 0，1正好对应逻辑值 真，假。方便实现逻辑运算 可很方便地使用逻辑门电路实现算术运算 真值：符合人类习惯的数字 机器数：数字实际存到机器里的形式，正负号需要被数字化","categories":[],"tags":[]},{"title":"","slug":"读书笔记/最近/计算机科学导论/2数据运算","date":"2022-03-01T13:33:38.755Z","updated":"2022-03-16T14:45:48.447Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"移位运算 移位：通过改变各个数码位和小数点额相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法 算数移位 原码的算数移位：符号位保持不变，仅对数值位进行移位 右移：高位补零，低位舍弃。若舍弃的位是0，则相当于除以2；若舍弃的位是1，则会丢失精度。 左移：低位补0，高位舍弃。若舍弃的位是0，则相当于乘2；若舍弃的位是1，则会出现严重误差。 反码的算数移位 正数反码的移位运算也和原码相同。 负数反码的移位运算：右移：高位补1，低位舍弃。左移：低位补1，高位舍弃。 补码的算数移位 正数补码的移位运算也和原码相同。 逻辑移位 逻辑右移：高位补0，低位舍弃。 逻辑左移：低位补0，高位舍弃。 可以把逻辑移位看作是对无符号数的算数移位。 循环移位 带进位位的循环移位 加减运算 原码的加减法 补码的加减法 对补码来说，无论加法还是减法，最后都会转变成加法。 溢出判断 方法一：采用一位符号位，若正加正得负或负加负得正则溢出 方法二：采用一位符号位，根据数据位进位情况判断溢出 方法三：采用双符号位，正数符号为00，负数符号为11。 符号扩展 乘法运算 原码乘法 串行乘法与并行乘法 串行乘法：相加—移位。缺点：运算速度太慢，已被淘汰。 自从大规模集成电路问世以来，高速的单元阵列乘法器应运而生，出现了各种形式的流水式阵列乘法器，它们属于并行乘法器。 不带符号的阵列乘法器 带符号的阵列乘法器 补码乘法 除法运算","categories":[],"tags":[]},{"title":"","slug":"读书笔记/最近/计算机科学导论/99数据存储","date":"2022-03-01T13:33:38.755Z","updated":"2022-03-16T14:45:48.455Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"数据类型 数据压缩 错误检测与纠正 存储数字 两个问题：如何存储数字的符号、如何存储小数。 对于小数点，计算机使用两种不同的表示方法：定点和浮点。 定点：小数点位置固定。 定点数 无符号定点数： 通常只有无符号整数，而没有无符号小数。直接将数字转换为二进制存入 有符号定点数： 定点整数：小数点隐含在末尾，有符号位 定点小数：小数点隐含在某位 可用 原码、反码、补码三种方式来表示定点整数和定点小数。还可用 移码 表示定点整数。 原码：用尾数表示真值的绝对值，符号位 0/1 对应正负。 反码：若符号位为0，则反码与原码相同；若符号位为1，则 数值位全部取反，符号位不变。 补码：正数的补码和原码相同；负数的补码为反码 + 1 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数。方便比较大小 补码即补数。模数 - 负数的绝对值 = 补数 由一个数 a 的补码求 -a 的补码 浮点数 存储文本 ASCII码 英文字母共有26个。16 &lt; 26 &lt; 32，所以字母 A 的 ASCII 码表示为 0100 0001 ，左边五位的值为1。 并让一个字母的大小写相差32，a 的 ASCII 码表示为 01100 0001 。进行大小写转换时只需改变一个数码。 汉字编码 GB 2312-80 输入编码 汉字字形码 存储音频 存储图像 存储视频","categories":[],"tags":[]},{"title":"","slug":"读书笔记/最近/计算机科学导论/3操作系统简述","date":"2022-02-28T16:08:53.634Z","updated":"2022-03-16T14:45:48.448Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"参考 ：操作系统的发展过程 、多道程序设计基本思想 操作系统的发展 未配置操作系统的计算机系统 单道批操作系统 多道批操作系统 分时系统 实时系统 微机操作系统的发展","categories":[],"tags":[]},{"title":"计算理论","slug":"读书笔记/最近/计算机科学导论/5计算理论","date":"2022-02-26T16:00:00.000Z","updated":"2022-03-16T14:45:48.453Z","comments":true,"path":"posts/b596bdd6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b596bdd6/","excerpt":"","text":"","categories":[{"name":"计算机科学导论","slug":"计算机科学导论","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"}],"tags":[]},{"title":"程序设计语言","slug":"读书笔记/最近/计算机科学导论/4程序设计语言","date":"2022-02-26T16:00:00.000Z","updated":"2022-03-16T14:45:48.452Z","comments":true,"path":"posts/c09424ed/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c09424ed/","excerpt":"","text":"","categories":[{"name":"计算机科学导论","slug":"计算机科学导论","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"}],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/单调栈&&单调队列","date":"2022-02-26T14:12:39.232Z","updated":"2022-03-16T14:45:48.430Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/最近/查看汇编代码","date":"2022-02-26T10:13:08.730Z","updated":"2022-03-16T14:45:48.446Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"https://blog.csdn.net/zhangpeterx/article/details/100120219 https://godbolt.org","categories":[],"tags":[]},{"title":"计算机组成简述","slug":"读书笔记/最近/计算机科学导论/3计算机组成简述","date":"2022-02-23T16:00:00.000Z","updated":"2022-03-16T15:35:06.266Z","comments":true,"path":"posts/dfc259ee/","link":"","permalink":"http://xiaoke-jin.github.io/posts/dfc259ee/","excerpt":"","text":"计算机的组成部分可以分成三大类（或子系统）：中央处理单元CPU、主存储器、输出/输出系统 中央处理单元 中央处理单元CPU用于数据的运算。在大多数体系结构中，它有三个组成部分：算术逻辑单元ALU、控制单元、寄存器。 运算器 算术逻辑单元ALU对数据进行逻辑、移位、算术运算。 逻辑运算：非、与、或、异或 移位运算：逻辑移位运算、算术移位运算 算术运算：加、减、乘、除、模 控制器 控制是通过控制单元CU向其他子系统发出信号来进行。 CPU区分指令和数据的依据：指令周期的不同阶段 寄存器 寄存器是用来存放临时数据的、高速的、独立的存储单元。 数据寄存器：在过去，CPU只有几个数据寄存器用来存储输入的数据和运算结果。现在，越来越多的复杂运算改由硬件设备实现（而不是使用软件），所以CPU使用几十个寄存器来提高运算速度，并且需要一些寄存器来保存这些运算的中间结果。 指令寄存器：计算机中存储的不仅是数据，还有存储在内存中的程序。CPU的一个功能是：从内存中逐条取出指令，并将取出的指令存储在指令寄存器中，分析并执行指令。 程序寄存器：即PC寄存器。程序寄存器中保存着当前正在执行的指令。当前的指令执行完成后，计数器将自动加1，指向下一条指令的内存地址。 主存储器 主存储器：存储体、MAR、MDR。 CPU对主存储器读写时这三个部件的作用 存储体：存储单元、存储字、存储字长、存储元 存储器的类型 RAM 随机存取存储器。断电后信息丢失。 SRAM：使用触发器门电路来保存数据。这些门保持状态（0或1），也就是说当通电时数据始终存在，不需要刷新。SRAM速度快，但价格昂贵。 DRAM：使用电容保持数据。因为电容器会随时间而漏掉一部分电，所以内存单元需要周期性地刷新。DRAM比较慢，但比较便宜。 ROM 只读存储器（Read Only）的内容是由制造商写进去的。用户只能读但不能写，它的优点是非易失性：当切断电源后，数据也不会丢失。通常用来存储那些关机后不能丢失的程序或数据。 PROM、EPROM、EEPROM 存储器的层次结构 寄存器、cache、主存、外存（硬盘） 输入输出子系统 这个子系统使计算机可以与外界通信，并在断电的情况下存储程序和数据。输入/输出设备可以分为两大类：非存储设备和存储设备。 非存储设备 键盘鼠标打印机 存储设备 磁介质存储设备 磁盘 磁带 光存储设备 CD-ROM CD-R CD-RW 子系统的互连 CPU和存储器的连接 CPU和存储器之间通常由称为总线的三组线路连接在一起，它们分别是：数据总线、地址总线、控制总线。 数据总线：由多根线组成。每根线上每次传送1个比特。线的数量取决于计算机的字的大小。例如，计算机的字是32位（4字节），那么需要有32根线的数据总线，以便同一时刻能够传送32个比特。 地址总线： 控制总线： I/O设备的连接 输入/输出设备的寻址 程序执行 不同的体系结构 简单计算机","categories":[{"name":"计算机科学导论","slug":"计算机科学导论","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"}],"tags":[]},{"title":"计算机发展简史","slug":"读书笔记/最近/计算机科学导论/99计算机发展简史","date":"2022-02-23T16:00:00.000Z","updated":"2022-03-01T12:49:10.664Z","comments":true,"path":"posts/f4a1cbcb/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f4a1cbcb/","excerpt":"","text":"打孔卡片数据处理 纸带编程 穿孔卡片计算机 IBM 029 wikipedia ENIAC 1946 ENIAC Computer History Remastered FULL VERSION First Large Digital Electronic Computer U.S. How ENIAC took a Square Root Programming the ENIAC 计算机模型 无「存储程序」的计算机 存储器中只存数据。需要手动接线来完成一个个的指令。比如早期的 ENIAC 冯·诺伊曼计算机 计算机由输入输出设备、运算器、控制器、存储器组成。 指令和数据以同等地位位于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心：输入输出设备与存储器之间的数据传送通过运算器完成。这样会降低运算器效率 早期计算机结构中只有数据才能存储在存储器中。完成某一任务的程序是通过操作一系列的开关或改变其配线来实现的。 现代计算机 以存储器为中心 CPU=运算器 + 控制器，集成在一起，称为CPU。 MAR、MDR通常会集成到CPU里。 计算机历史 机械计算机器 与现代计算机几乎没有相似之处。 略 电子计算机的诞生 早期的电子计算机：运算速度虽然比当时任何其他的机电式计算机都快，但是却有着致命的缺陷，即指导完成计算的指令不能以数据的形式存贮在同一存储器中。运行之前，必须先想好全部指令，然后用手去连接所有需要接通的电路。这一过程极为复杂，往往要许多技术人员干好几天。而且 每改变一个程序，所有的线路都要重新拆接一次。比如 ENIAC 基于冯·诺伊曼模型的计算机：程序和数据都存在存储器中。按照这种方法，使用计算机运行一个程序，只需要改变程序，而不用重新布线或调节成百上千的开关。比如 EDVAC 四个年代的计算机 1950年以后出现的计算机都差不多基于冯·诺伊曼模型。它们变得更快、更小、更便宜，但原理几乎是相同的。每一代计算机的改进主要体现在硬件或软件方面，而不是模型。 一代：1946 - 1957。电子管时代。使用机器语言（01串）、汇编语言编程， 二代：1958 - 1964。1947年贝尔实验室发明晶体管。出现面向过程的程序设计语言FORTRAN。有了操作系统雏形。（虽然有了FORTRAN，仍使用穿孔卡片作为输入给计算机运行 https://zhuanlan.zhihu.com/p/415819018 三代：1964 - 1971。发明集成电路。高级语言开始迅速发展，开始有了分时操作系统。计算机主要用于科学计算等专业用途 四代：1972 - 现在。大规模、超大规模集成电路时代。开始出现「微处理器」、「微型计算机」、个人计算机萌芽。操作系统（win、Max、Linux，，）出现 计算机性能的指标 计算机系统的层次结构","categories":[{"name":"计算机科学导论","slug":"计算机科学导论","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"}],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/动态规划/概率DP","date":"2022-02-18T14:34:13.393Z","updated":"2022-02-19T02:32:20.986Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜概率dp初见—HDU4576 Robot","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最短路/Floyd","date":"2022-02-18T14:32:59.152Z","updated":"2022-02-19T02:32:21.010Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜Floyd求最小环(CF Shortest Cycle)","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/动态规划/线性DP","date":"2022-02-18T14:19:40.030Z","updated":"2022-02-19T02:32:20.986Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜最长上升子序列长度及其优化与变种","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最小生成树/Prim","date":"2022-02-18T14:17:55.906Z","updated":"2022-02-19T02:32:21.006Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜最小生成树-prime算法","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数学/组合数学/二项式定理","date":"2022-02-18T14:16:56.412Z","updated":"2022-02-19T02:32:21.013Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜杨辉三角与二项式定理","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/二分图","date":"2022-02-18T14:16:03.209Z","updated":"2022-02-19T02:32:20.997Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜二分图详解 干货｜二分图匹配","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/欧拉图","date":"2022-02-18T14:15:00.939Z","updated":"2022-02-19T02:32:20.998Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜欧拉图学习笔记","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最小生成树/Kruskal","date":"2022-02-18T14:12:48.370Z","updated":"2022-02-19T02:32:21.007Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"最小生成树-Kruskal（克鲁斯卡尔）算法+理解+证明 干货｜最小生成树Prim算法与Kruskal算法","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/杂项算法/常见的距离","date":"2022-02-18T14:11:16.466Z","updated":"2022-02-19T02:32:21.003Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"本文主要讲解 三种 常见的距离算法，分别是 欧氏距离，曼哈顿距离，切比雪夫距离 。 算法 | 常用距离算法详解","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/计算几何/凸包","date":"2022-02-18T14:09:13.400Z","updated":"2022-02-19T02:32:21.004Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"算法 | 凸包问题的卷包裹法 算法｜凸包问题–旋转卡壳 算法｜凸包问题–Graham-Scan算法 算法｜凸包问题–动态凸包（平衡树维护）","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/KM算法","date":"2022-02-18T14:07:35.635Z","updated":"2022-02-19T02:32:20.995Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"男女配对问题｜KM算法详解+模板","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/字符串/后缀数组","date":"2022-02-18T14:05:27.290Z","updated":"2022-02-19T02:32:21.000Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"数组 | 后缀数组的求法及应用 练习｜后缀数组学习笔记","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数学/博弈论/博弈论入门","date":"2022-02-18T13:47:37.798Z","updated":"2022-02-19T02:32:21.012Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"算法｜博弈论入门（函数讲解+真题模板） 巴什博奕(Bash Game)入门 干货｜ACM博弈知识总结及相关例题","categories":[],"tags":[]},{"title":"","slug":"牛客比赛/寒假训练营1","date":"2022-02-13T07:31:51.484Z","updated":"2022-02-13T07:32:57.187Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"https://ac.nowcoder.com/acm/contest/23106","categories":[],"tags":[]},{"title":"","slug":"牛客比赛/寒假训练营2","date":"2022-02-13T07:31:51.484Z","updated":"2022-02-13T07:32:49.521Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"https://ac.nowcoder.com/acm/contest/23477","categories":[],"tags":[]},{"title":"","slug":"牛客比赛/寒假训练营3","date":"2022-02-13T07:31:51.484Z","updated":"2022-02-13T07:32:38.646Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"https://ac.nowcoder.com/acm/contest/23478","categories":[],"tags":[]},{"title":"2022牛客寒假算法基础集训营6","slug":"牛客比赛/寒假训练营6","date":"2022-02-11T16:00:00.000Z","updated":"2022-02-13T07:30:32.311Z","comments":true,"path":"posts/17dfb37c/","link":"","permalink":"http://xiaoke-jin.github.io/posts/17dfb37c/","excerpt":"","text":"https://ac.nowcoder.com/acm/contest/23481 共 10 题 签到：E F I 牛妹的数学难题 easy version 组合数学 hard version 分治 FFT","categories":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"牛客智乃数据结构前缀和与差分习题","slug":"牛客比赛/智乃前缀和与差分习题","date":"2022-02-11T16:00:00.000Z","updated":"2022-02-18T05:07:35.015Z","comments":true,"path":"posts/301d0555/","link":"","permalink":"http://xiaoke-jin.github.io/posts/301d0555/","excerpt":"","text":"牛客竞赛数据结构专题班前缀和练习题 题解 A 前缀乘 B 子集与超集 C 高阶差分、高阶前缀和 D E 前缀矩阵 F 前缀置换 G 前缀和 H 差分 区间加、区间加等差数列、区间加自然数平方和数列 题解：小w的糖果 I J","categories":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"牛客智乃数据结构线段树习题","slug":"牛客比赛/智乃线段树习题","date":"2022-02-11T16:00:00.000Z","updated":"2022-02-17T09:06:47.575Z","comments":true,"path":"posts/ddddeb5b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ddddeb5b/","excerpt":"","text":"牛客竞赛数据结构专题班树状数组、线段树练习题 题解 A 区间修改 二分 + 差分 B1 树状数组 莫队 C 树状数组 D1 区间加、乘 区间和、区间元素的平方的和 E1 区间加、乘 区间和、区间元素的两两乘积的和 F 区间 mex 莫队 G 区间加自然数的平方和 线段树维护区间加平方数列 H 线段树上二分 I 特殊的区间加、区间和 原始数组每个结点有三个值 J DDP K 线段树 + 矩阵","categories":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"浅谈卡迈克尔数","slug":"DS_Algorithm证明与讲解/数学/数论/整除/卡迈克尔数","date":"2022-02-11T16:00:00.000Z","updated":"2022-02-13T04:25:24.855Z","comments":true,"path":"posts/572a6897/","link":"","permalink":"http://xiaoke-jin.github.io/posts/572a6897/","excerpt":"","text":"判断一个数是否为卡迈克尔数：题目 https://vjudge.net/problem/UVA-10006 题解：UVA 10006（卡迈克尔数+素数打表） 1e8 内的卡迈克尔数 1e8 内的 255 个卡迈克尔数如下。 The number 561 is a Carmichael number. 561 = 3 * 11 * 17The number 1105 is a Carmichael number. 1105 = 5 * 13 * 17The number 1729 is a Carmichael number. 1729 = 7 * 13 * 19The number 2465 is a Carmichael number. 2465 = 5 * 17 * 29The number 2821 is a Carmichael number. 2821 = 7 * 13 * 31The number 6601 is a Carmichael number. 6601 = 7 * 23 * 41The number 8911 is a Carmichael number. 8911 = 7 * 19 * 67The number 10585 is a Carmichael number. 10585 = 5 * 29 * 73The number 15841 is a Carmichael number. 15841 = 7 * 13 * 73The number 29341 is a Carmichael number. 29341 = 13 * 37 * 61The number 41041 is a Carmichael number. 41041 = 7 * 11 * 13 * 41The number 46657 is a Carmichael number. 46657 = 13 * 37 * 97The number 52633 is a Carmichael number. 52633 = 7 * 73 * 103The number 62745 is a Carmichael number. 62745 =3 * 5 * 47 * 89The number 63973 is a Carmichael number. 63973 = 7 * 13 * 19 * 37The number 75361 is a Carmichael number. 75361 = 11 * 13 * 17 * 31The number 101101 is a Carmichael number. 101101 = 7 * 11 * 13 * 101The number 115921 is a Carmichael number. 115921 = 13 * 37 * 241The number 126217 is a Carmichael number. 126217 = 7 * 13 * 19 * 73The number 162401 is a Carmichael number. 162401 = 17 * 41 * 233The number 172081 is a Carmichael number. 172081 = 7 * 13 * 31 * 61The number 188461 is a Carmichael number. 188461 = 7 * 13 * 19 * 109The number 252601 is a Carmichael number. 252601 = 41 * 61 * 101The number 278545 is a Carmichael number. 278545 = 5 * 17 * 29 * 113The number 294409 is a Carmichael number. 294409 = 37 * 73 * 109The number 314821 is a Carmichael number. 314821 = 13 * 61 * 397The number 334153 is a Carmichael number. 334153 = 19 * 43 * 409The number 340561 is a Carmichael number. 340561 = 13 * 17 * 23 * 67The number 399001 is a Carmichael number. 399001 = 31 * 61 * 211The number 410041 is a Carmichael number. 410041 = 41 * 73 * 137The number 449065 is a Carmichael number. 449065 = 5 * 19 * 29 * 163The number 488881 is a Carmichael number. 488881 = 37 * 73 * 181The number 512461 is a Carmichael number. 512461 = 31 * 61 * 271The number 530881 is a Carmichael number. 530881 = 13 * 97 * 421The number 552721 is a Carmichael number. 552721 = 13 * 17 * 41 * 61The number 656601 is a Carmichael number. 656601 = 3 * 11 * 101 * 197The number 658801 is a Carmichael number. 658801 = 11 * 13 * 17 * 271The number 670033 is a Carmichael number. 670033 = 7 * 13 * 37 * 199 The number 748657 is a Carmichael number. 748657 = 7 * 13 * 19 * 433 The number 825265 is a Carmichael number. 825265 = 5 * 7 * 17 * 19 * 73The number 838201 is a Carmichael number. 838201 = 7 * 13 * 61 * 151 The number 852841 is a Carmichael number. 852841 = 11 * 31 * 41 * 61 The number 997633 is a Carmichael number. 997633 = 7 * 13 * 19 * 577 The number 1024651 is a Carmichael number. 1024651 = 19 * 199 * 271 The number 1033669 is a Carmichael number. 1033669 = 7 * 13 * 37 * 307 The number 1050985 is a Carmichael number. 1050985 = 5 * 13 * 19 * 23 * 37The number 1082809 is a Carmichael number. 1082809 = 7 * 13 * 73 * 163 The number 1152271 is a Carmichael number. 1152271 = 43 * 127 * 211 The number 1193221 is a Carmichael number. 1193221 = 31 * 61 * 631 The number 1461241 is a Carmichael number. 1461241 = 37 * 73 * 541 The number 1569457 is a Carmichael number. 1569457 = 17 * 19 * 43 * 113The number 1615681 is a Carmichael number. 1615681 = 23 * 199 * 353 The number 1773289 is a Carmichael number. 1773289 = 7 * 19 * 67 * 199The number 1857241 is a Carmichael number. 1857241 = 31 * 181 * 331The number 1909001 is a Carmichael number. 1909001 = 41 * 101 * 461The number 2100901 is a Carmichael number. 2100901 = 11 * 31 * 61 * 101The number 2113921 is a Carmichael number. 2113921 = 19 * 31 * 37 * 97The number 2433601 is a Carmichael number. 2433601 = 17 * 37 * 53 * 73The number 2455921 is a Carmichael number. 2455921 = 13 * 19 * 61 * 163The number 2508013 is a Carmichael number. 2508013 = 53 * 79 * 599The number 2531845 is a Carmichael number. 2531845 = 5 * 19 * 29 * 919The number 2628073 is a Carmichael number. 2628073 = 7 * 37 * 73 * 139The number 2704801 is a Carmichael number. 2704801 = 11 * 29 * 61 * 139The number 3057601 is a Carmichael number. 3057601 = 43 * 211 * 337The number 3146221 is a Carmichael number. 3146221 = 13 * 31 * 37 * 211The number 3224065 is a Carmichael number. 3224065 = 5 * 13 * 193 * 257The number 3581761 is a Carmichael number. 3581761 = 29 * 113 * 1093The number 3664585 is a Carmichael number. 3664585 = 5 * 29 * 127 * 199The number 3828001 is a Carmichael number. 3828001 = 101 * 151 * 251The number 4335241 is a Carmichael number. 4335241 = 53 * 157 * 521The number 4463641 is a Carmichael number. 4463641 = 7 * 13 * 181 * 271The number 4767841 is a Carmichael number. 4767841 = 13 * 19 * 97 * 199The number 4903921 is a Carmichael number. 4903921 = 11 * 31 * 73 * 197The number 4909177 is a Carmichael number. 4909177 = 7 * 13 * 73 * 739The number 5031181 is a Carmichael number. 5031181 = 19 * 23 * 29 * 397The number 5049001 is a Carmichael number. 5049001 = 31 * 271 * 601The number 5148001 is a Carmichael number. 5148001 = 41 * 241 * 521The number 5310721 is a Carmichael number. 5310721 = 13 * 37 * 61 * 181The number 5444489 is a Carmichael number. 5444489 = 29 * 197 * 953The number 5481451 is a Carmichael number. 5481451 = 31 * 151 * 1171The number 5632705 is a Carmichael number. 5632705 = 5 * 13 * 193 * 449The number 5968873 is a Carmichael number. 5968873 = 43 * 127 * 1093The number 6049681 is a Carmichael number. 6049681 = 11 * 31 * 113 * 157The number 6054985 is a Carmichael number. 6054985 = 5 * 53 * 73 * 313The number 6189121 is a Carmichael number. 6189121 = 61 * 241 * 421The number 6313681 is a Carmichael number. 6313681 = 11 * 17 * 19 * 1777The number 6733693 is a Carmichael number. 6733693 = 109 * 163 * 379The number 6840001 is a Carmichael number. 6840001 = 7 * 17 * 229 * 251The number 6868261 is a Carmichael number. 6868261 = 43 * 211 * 757The number 7207201 is a Carmichael number. 7207201 = 17 * 353 * 1201The number 7519441 is a Carmichael number. 7519441 = 41 * 241 * 761The number 7995169 is a Carmichael number. 7995169 = 7 * 13 * 103 * 853The number 8134561 is a Carmichael number. 8134561 = 37 * 109 * 2017The number 8341201 is a Carmichael number. 8341201 = 11 * 31 * 61 * 401The number 8355841 is a Carmichael number. 8355841 = 13 * 41 * 61 * 257The number 8719309 is a Carmichael number. 8719309 = 19 * 37 * 79 * 157The number 8719921 is a Carmichael number. 8719921 = 7 * 23 * 41 * 1321The number 8830801 is a Carmichael number. 8830801 = 7 * 19 * 67 * 991The number 8927101 is a Carmichael number. 8927101 = 31 * 37 * 43 * 181The number 9439201 is a Carmichael number. 9439201 = 61 * 271 * 571The number 9494101 is a Carmichael number. 9494101 = 23 * 61 * 67 * 101The number 9582145 is a Carmichael number. 9582145 = 5 * 23 * 97 * 859The number 9585541 is a Carmichael number. 9585541 = 7 * 31 * 163 * 271The number 9613297 is a Carmichael number. 9613297 = 19 * 29 * 73 * 239The number 9890881 is a Carmichael number. 9890881 = 7 * 11 * 13 * 41 * 241The number 10024561 is a Carmichael number. 10024561 = 71 * 271 * 521The number 10267951 is a Carmichael number. 10267951 = 67 * 331 * 463The number 10402561 is a Carmichael number. 10402561 = 13 * 29 * 41 * 673The number 10606681 is a Carmichael number. 10606681 = 31 * 43 * 73 * 109The number 10837321 is a Carmichael number. 10837321 = 11 * 31 * 61 * 521The number 10877581 is a Carmichael number. 10877581 = 11 * 13 * 29 * 43 * 61The number 11119105 is a Carmichael number. 11119105 = 5 * 17 * 257 * 509The number 11205601 is a Carmichael number. 11205601 = 11 * 17 * 31 * 1933The number 11921001 is a Carmichael number. 11921001 = 3 * 29 * 263 * 521The number 11972017 is a Carmichael number. 11972017 = 43 * 433 * 643The number 12261061 is a Carmichael number. 12261061 = 19 * 61 * 71 * 149The number 12262321 is a Carmichael number. 12262321 = 17 * 41 * 73 * 241The number 12490201 is a Carmichael number. 12490201 = 19 * 37 * 109 * 163The number 12945745 is a Carmichael number. 12945745 = 5 * 19 * 29 * 37 * 127The number 13187665 is a Carmichael number. 13187665 = 5 * 17 * 113 * 1373The number 13696033 is a Carmichael number. 13696033 = 13 * 17 * 29 * 2137The number 13992265 is a Carmichael number. 13992265 = 5 * 7 * 19 * 53 * 397The number 14469841 is a Carmichael number. 14469841 = 73 * 379 * 523The number 14676481 is a Carmichael number. 14676481 = 71 * 421 * 491The number 14913991 is a Carmichael number. 14913991 = 43 * 127 * 2731The number 15247621 is a Carmichael number. 15247621 = 61 * 181 * 1381The number 15403285 is a Carmichael number. 15403285 = 5 * 37 * 139 * 599The number 15829633 is a Carmichael number. 15829633 = 43 * 547 * 673The number 15888313 is a Carmichael number. 15888313 = 7 * 19 * 67 * 1783The number 16046641 is a Carmichael number. 16046641 = 13 * 37 * 73 * 457The number 16778881 is a Carmichael number. 16778881 = 7 * 17 * 19 * 41 * 181The number 17098369 is a Carmichael number. 17098369 = 113 * 337 * 449The number 17236801 is a Carmichael number. 17236801 = 151 * 211 * 541The number 17316001 is a Carmichael number. 17316001 = 53 * 157 * 2081The number 17586361 is a Carmichael number. 17586361 = 13 * 61 * 67 * 331The number 17812081 is a Carmichael number. 17812081 = 7 * 41 * 53 * 1171The number 18162001 is a Carmichael number. 18162001 = 11 * 13 * 17 * 31 * 241The number 18307381 is a Carmichael number. 18307381 = 29 * 61 * 79 * 131The number 18900973 is a Carmichael number. 18900973 = 7 * 13 * 229 * 907The number 19384289 is a Carmichael number. 19384289 = 89 * 353 * 617The number 19683001 is a Carmichael number. 19683001 = 13 * 37 * 151 * 271The number 20964961 is a Carmichael number. 20964961 = 17 * 19 * 47 * 1381The number 21584305 is a Carmichael number. 21584305 = 5 * 17 * 197 * 1289The number 22665505 is a Carmichael number. 22665505 = 5 * 17 * 97 * 2749The number 23382529 is a Carmichael number. 23382529 = 97 * 193 * 1249The number 25603201 is a Carmichael number. 25603201 = 13 * 29 * 113 * 601The number 26280073 is a Carmichael number. 26280073 = 73 * 157 * 2293The number 26474581 is a Carmichael number. 26474581 = 7 * 19 * 67 * 2971The number 26719701 is a Carmichael number. 26719701 = 3 * 29 * 197 * 1559The number 26921089 is a Carmichael number. 26921089 = 13 * 37 * 97 * 577The number 26932081 is a Carmichael number. 26932081 = 11 * 47 * 113 * 461The number 27062101 is a Carmichael number. 27062101 = 11 * 31 * 61 * 1301The number 27336673 is a Carmichael number. 27336673 = 7 * 13 * 23 * 37 * 353The number 27402481 is a Carmichael number. 27402481 = 31 * 43 * 61 * 337The number 28787185 is a Carmichael number. 28787185 = 5 * 7 * 19 * 73 * 593The number 29020321 is a Carmichael number. 29020321 = 11 * 37 * 113 * 631The number 29111881 is a Carmichael number. 29111881 = 211 * 281 * 491The number 31146661 is a Carmichael number. 31146661 = 7 * 13 * 31 * 61 * 181The number 31405501 is a Carmichael number. 31405501 = 71 * 631 * 701The number 31692805 is a Carmichael number. 31692805 = 5 * 47 * 157 * 859The number 32914441 is a Carmichael number. 32914441 = 7 * 19 * 61 * 4057The number 33302401 is a Carmichael number. 33302401 = 11 * 31 * 61 * 1601The number 33596641 is a Carmichael number. 33596641 = 13 * 17 * 281 * 541The number 34196401 is a Carmichael number. 34196401 = 17 * 47 * 127 * 337The number 34657141 is a Carmichael number. 34657141 = 191 * 421 * 431The number 34901461 is a Carmichael number. 34901461 = 7 * 19 * 397 * 661The number 35571601 is a Carmichael number. 35571601 = 13 * 31 * 61 * 1447The number 35703361 is a Carmichael number. 35703361 = 61 * 277 * 2113The number 36121345 is a Carmichael number. 36121345 = 5 * 13 * 17 * 97 * 337The number 36765901 is a Carmichael number. 36765901 = 37 * 613 * 1621The number 37167361 is a Carmichael number. 37167361 = 7 * 11 * 41 * 61 * 193The number 37280881 is a Carmichael number. 37280881 = 11 * 17 * 73 * 2731The number 37354465 is a Carmichael number. 37354465 = 5 * 29 * 73 * 3529The number 37964809 is a Carmichael number. 37964809 = 109 * 379 * 919The number 38151361 is a Carmichael number. 38151361 = 41 * 53 * 97 * 181The number 38624041 is a Carmichael number. 38624041 = 37 * 61 * 109 * 157The number 38637361 is a Carmichael number. 38637361 = 7 * 37 * 241 * 619The number 39353665 is a Carmichael number. 39353665 = 5 * 13 * 193 * 3137The number 40160737 is a Carmichael number. 40160737 = 19 * 23 * 29 * 3169The number 40280065 is a Carmichael number. 40280065 = 5 * 7 * 67 * 89 * 193The number 40430401 is a Carmichael number. 40430401 = 11 * 101 * 151 * 241The number 40622401 is a Carmichael number. 40622401 = 17 * 43 * 61 * 911The number 40917241 is a Carmichael number. 40917241 = 19 * 31 * 127 * 547The number 41298985 is a Carmichael number. 41298985 = 5 * 7 * 13 * 139 * 653The number 41341321 is a Carmichael number. 41341321 = 7 * 19 * 31 * 37 * 271The number 41471521 is a Carmichael number. 41471521 = 7 * 13 * 31 * 61 * 241The number 42490801 is a Carmichael number. 42490801 = 31 * 41 * 101 * 331The number 43286881 is a Carmichael number. 43286881 = 11 * 31 * 61 * 2081The number 43331401 is a Carmichael number. 43331401 = 43 * 631 * 1597The number 43584481 is a Carmichael number. 43584481 = 17 * 31 * 191 * 433The number 43620409 is a Carmichael number. 43620409 = 7 * 19 * 157 * 2089The number 44238481 is a Carmichael number. 44238481 = 7 * 61 * 313 * 331The number 45318561 is a Carmichael number. 45318561 = 3 * 29 * 173 * 3011The number 45877861 is a Carmichael number. 45877861 = 31 * 43 * 127 * 271The number 45890209 is a Carmichael number. 45890209 = 29 * 53 * 73 * 409The number 46483633 is a Carmichael number. 46483633 = 7 * 19 * 373 * 937The number 47006785 is a Carmichael number. 47006785 = 5 * 7 * 17 * 199 * 397The number 48321001 is a Carmichael number. 48321001 = 37 * 41 * 53 * 601The number 48628801 is a Carmichael number. 48628801 = 13 * 31 * 67 * 1801The number 49333201 is a Carmichael number. 49333201 = 17 * 61 * 113 * 421The number 50201089 is a Carmichael number. 50201089 = 97 * 673 * 769The number 53245921 is a Carmichael number. 53245921 = 17 * 41 * 79 * 967The number 53711113 is a Carmichael number. 53711113 = 157 * 313 * 1093The number 54767881 is a Carmichael number. 54767881 = 7 * 37 * 103 * 2053The number 55462177 is a Carmichael number. 55462177 = 17 * 23 * 83 * 1709The number 56052361 is a Carmichael number. 56052361 = 211 * 421 * 631The number 58489201 is a Carmichael number. 58489201 = 19 * 29 * 101 * 1051The number 60112885 is a Carmichael number. 60112885 = 5 * 7 * 443 * 3877The number 60957361 is a Carmichael number. 60957361 = 61 * 181 * 5521The number 62756641 is a Carmichael number. 62756641 = 109 * 241 * 2389The number 64377991 is a Carmichael number. 64377991 = 163 * 487 * 811The number 64774081 is a Carmichael number. 64774081 = 29 * 71 * 163 * 193The number 65037817 is a Carmichael number. 65037817 = 13 * 19 * 73 * 3607The number 65241793 is a Carmichael number. 65241793 = 29 * 43 * 113 * 463The number 67371265 is a Carmichael number. 67371265 = 5 * 13 * 37 * 109 * 257The number 67653433 is a Carmichael number. 67653433 = 19 * 29 * 199 * 617The number 67902031 is a Carmichael number. 67902031 = 43 * 271 * 5827The number 67994641 is a Carmichael number. 67994641 = 11 * 13 * 37 * 71 * 181The number 68154001 is a Carmichael number. 68154001 = 151 * 601 * 751The number 69331969 is a Carmichael number. 69331969 = 7 * 19 * 37 * 73 * 193The number 70561921 is a Carmichael number. 70561921 = 31 * 53 * 67 * 641The number 72108421 is a Carmichael number. 72108421 = 7 * 11 * 191 * 4903The number 72286501 is a Carmichael number. 72286501 = 7 * 67 * 79 * 1951The number 74165065 is a Carmichael number. 74165065 = 5 * 13 * 59 * 83 * 233The number 75151441 is a Carmichael number. 75151441 = 17 * 19 * 29 * 71 * 113The number 75681541 is a Carmichael number. 75681541 = 13 * 19 * 61 * 5023The number 75765313 is a Carmichael number. 75765313 = 13 * 29 * 73 * 2753The number 76595761 is a Carmichael number. 76595761 = 11 * 17 * 31 * 73 * 181The number 77826001 is a Carmichael number. 77826001 = 11 * 43 * 137 * 1201The number 78091201 is a Carmichael number. 78091201 = 31 * 37 * 103 * 661The number 78120001 is a Carmichael number. 78120001 = 19 * 73 * 151 * 373The number 79411201 is a Carmichael number. 79411201 = 193 * 257 * 1601The number 79624621 is a Carmichael number. 79624621 = 139 * 691 * 829The number 80282161 is a Carmichael number. 80282161 = 43 * 61 * 127 * 241The number 80927821 is a Carmichael number. 80927821 = 13 * 19 * 103 * 3181The number 81638401 is a Carmichael number. 81638401 = 13 * 97 * 101 * 641The number 81926461 is a Carmichael number. 81926461 = 19 * 67 * 139 * 463The number 82929001 is a Carmichael number. 82929001 = 281 * 421 * 701The number 83099521 is a Carmichael number. 83099521 = 19 * 37 * 43 * 2749The number 83966401 is a Carmichael number. 83966401 = 41 * 43 * 97 * 491The number 84311569 is a Carmichael number. 84311569 = 19 * 73 * 89 * 683The number 84350561 is a Carmichael number. 84350561 = 107 * 743 * 1061The number 84417985 is a Carmichael number. 84417985 = 5 * 29 * 577 * 1009The number 87318001 is a Carmichael number. 87318001 = 17 * 71 * 73 * 991The number 88689601 is a Carmichael number. 88689601 = 7 * 11 * 13 * 41 * 2161The number 90698401 is a Carmichael number. 90698401 = 103 * 647 * 1361The number 92625121 is a Carmichael number. 92625121 = 181 * 631 * 811The number 93030145 is a Carmichael number. 93030145 = 5 * 13 * 257 * 5569The number 93614521 is a Carmichael number. 93614521 = 7 * 11 * 13 * 41 * 2281The number 93869665 is a Carmichael number. 93869665 = 5 * 17 * 29 * 113 * 337The number 94536001 is a Carmichael number. 94536001 = 7 * 19 * 607 * 1171The number 96895441 is a Carmichael number. 96895441 = 109 * 433 * 2053The number 99036001 is a Carmichael number. 99036001 = 61 * 541 * 3001The number 99830641 is a Carmichael number. 99830641 = 53 * 79 * 113 * 211The number 99861985 is a Carmichael number. 99861985 = 5 * 97 * 109 * 1889 判断一个数是否为卡迈克尔数 #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 66000;int p[N], cnt;bool st[N];void getp(int n = 66000)&#123; for (int i = 2; i &lt;= n; i++) &#123; if(!st[i]) p[++cnt] = i; for (int j = 1; 1ll * p[j] * i &lt;= n; j++) &#123; st[p[j] * i] = true; if(i % p[j] == 0) break; &#125; &#125;&#125;int main()&#123; getp(); int n, flag, all = 0; while (~scanf(&quot;%d&quot;, &amp;n)) &#123; flag = 1; if (n == 0) break; if (st[n] &amp;&amp; (n % 2 == 1)) // 卡迈克尔数 是 奇合数 &#123; for (int i = 1; p[i] &lt; n; i++) // 遍历小于 n 的所有质数 &#123; if (n % p[i] == 0) &#123; if (n % (p[i] * p[i]) == 0 || (n - 1) % (p[i] - 1)) &#123; flag = 0; break; &#125; &#125; &#125; &#125; else &#123; flag = 0; &#125; if (flag) &#123; printf(&quot;The number %d is a Carmichael number.\\n&quot;, n); all++; &#125; else printf(&quot;%d is normal.\\n&quot;, n); &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"2022牛客寒假算法基础集训营5","slug":"牛客比赛/寒假训练营5","date":"2022-02-10T16:00:00.000Z","updated":"2022-02-13T07:26:40.688Z","comments":true,"path":"posts/8ed6e2c6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/8ed6e2c6/","excerpt":"","text":"https://ac.nowcoder.com/acm/contest/23480 共 11 题，3个签到GIJ，4个不可做BFHK 1 [x] A 二分 [x] C 枚举 [ ] D 数位DP 或 素数环 2 [ ] E 线段树 + 矩阵","categories":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/杂项算法/双指针","date":"2022-02-08T15:24:40.692Z","updated":"2022-02-18T14:01:25.314Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"算法学习｜“尺取法”区间伸缩算法介绍","categories":[],"tags":[]},{"title":"2022牛客寒假算法基础集训营4","slug":"牛客比赛/寒假训练营4","date":"2022-02-07T16:00:00.000Z","updated":"2022-02-19T04:50:21.181Z","comments":true,"path":"posts/f9d1d250/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f9d1d250/","excerpt":"","text":"https://ac.nowcoder.com/acm/contest/23479 共 12 题 4 签到：E F H K medium [x] I 爆炸的符卡洋洋洒洒 01背包 [x] C 蓝彗星 前缀和与差分 [ ] D 雪色光晕 计算几何 [x] A R 双指针 medium-hard [x] G 子序列权值乘积 [ ] B 进制 线段树：特殊的区间合并 https://ac.nowcoder.com/acm/contest/view-submission?submissionId=50787533 hard [ ] L 在这冷漠的世界里光光哭哭 区间子序列数量","categories":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/网络流","date":"2022-02-07T15:29:34.212Z","updated":"2022-02-07T15:36:08.874Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"https://www.zhihu.com/question/263856769 https://www.zhihu.com/question/34374412 https://www.zhihu.com/question/266149721","categories":[],"tags":[]},{"title":"树链剖分","slug":"DS_Algorithm证明与讲解/数据结构/树链剖分","date":"2022-02-04T16:00:00.000Z","updated":"2022-02-18T13:38:35.157Z","comments":true,"path":"posts/7e454910/","link":"","permalink":"http://xiaoke-jin.github.io/posts/7e454910/","excerpt":"","text":"算法｜树链剖分瞎入门（这绝对是全网最长的树剖文章） 轻重链剖分 长链剖分 https://www.cnblogs.com/cjyyb/p/9479258.html 长链剖分 也是一种树链剖分，平时我们说树链剖分，一般都是直接默认为轻重链剖分。 轻重链剖分的优秀性质在于从任意一个点开始，向上跳跃，跳过的重链数量不会超过 log 级别。 这样子可以很优秀的解决两点之间链的问题。 对于解决一些子树的信息问题，我们可以用 dsu on tree 的思路，保证了每个点向上修改的次数不超过 log 次，也可以很方便的解决一些问题。而 长链剖分 则是通过修改剖分链的方式，通过维护一些信息，可以在更有优秀的时间中解决一部分问题。 长链剖分 十分类似于轻重链剖分，但是我们稍加修改，将每次选择子树大小最大的儿子作为重儿子变成了选择子树深度最大的那个儿子作为重儿子。然后将所有点和它的重儿子之间的边认为是重边，如果我们把他们在树中全部加粗，那么原树就被分割成了若干条链。因为很多东西都和轻重链剖分是相同的，所以这一部分我写的很简单。甚至于连两者之间的代码都是非常的相似的。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/字符串/字典树","date":"2022-02-04T13:09:06.124Z","updated":"2022-02-04T15:59:40.742Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"字典树（Trie） 代码实现 struct trie &#123; int nex[100000][26], cnt; bool exist[100000]; // 该结点结尾的字符串是否存在 void insert(char *s, int l) &#123; // 插入字符串 int p = 0; for (int i = 0; i &lt; l; i++) &#123; int c = s[i] - &#x27;a&#x27;; if (!nex[p][c]) nex[p][c] = ++cnt; // 如果没有，就添加结点 p = nex[p][c]; &#125; exist[p] = 1; &#125; bool find(char *s, int l) &#123; // 查找字符串 int p = 0; for (int i = 0; i &lt; l; i++) &#123; int c = s[i] - &#x27;a&#x27;; if (!nex[p][c]) return 0; p = nex[p][c]; &#125; return exist[p]; &#125;&#125;; 应用 检索字符串 维护异或极值 维护异或和 01-trie合并 可持久化字典树","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/图论基础与总结","date":"2022-02-02T14:36:46.155Z","updated":"2022-03-29T06:45:06.493Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"OI wiki 图论相关概念 算法｜图论 2W字知识点整理（超全面） 极大连通子图与极小连通子图（带图讲解）","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/强连通分量","date":"2022-02-02T14:36:11.618Z","updated":"2022-02-18T14:36:08.958Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜强连通分量 - 割点桥 - 双缩点","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/拓扑排序","date":"2022-02-02T12:35:14.210Z","updated":"2022-02-18T14:37:19.968Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"干货｜拓扑排序讲解","categories":[],"tags":[]},{"title":"ST表（稀疏表）","slug":"DS_Algorithm证明与讲解/数据结构/ST表","date":"2022-02-01T16:00:00.000Z","updated":"2022-02-09T14:05:59.379Z","comments":true,"path":"posts/eb42690/","link":"","permalink":"http://xiaoke-jin.github.io/posts/eb42690/","excerpt":"","text":"ST表功能有限，但可以用的时候优先用，否则大概率 TLE。 洛谷日报#146[周子衡] 浅谈ST表 简介 ST 表基于倍增思想，可以做到 Θ(nlog⁡n)\\Theta(n\\log n)Θ(nlogn) 预处理，Θ(1)\\Theta(1)Θ(1) 回答每个区间的最大/小值。但是不支持修改操作。 也可以看成是区间DP。 ST 表是用于解决 可重复贡献问题 的数据结构。 ​ 可重复贡献问题 是指对于运算 opt⁡\\operatorname{opt}opt，满足 xopt⁡x=xx\\operatorname{opt} x=xxoptx=x，则对应的区间询问就是一个可重复贡献问题。例如，最大值有 max⁡(x,x)=x\\max(x,x)=xmax(x,x)=x，gcd 有 gcd⁡(x,x)=x\\operatorname{gcd}(x,x)=xgcd(x,x)=x，所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外，opt⁡\\operatorname{opt}opt 还必须满足结合律才能使用 ST 表求解。 具体实现 预处理 令 f(i,j)f(i,j)f(i,j) 表示区间 [i,i+2j−1][i,i+2^j-1][i,i+2j−1] 的最大值，即从 i 开始，长度为 2j2^j2j 的区间内的最大值。 显然 f(i,0)=aif(i,0)=a_if(i,0)=ai​。 依据倍增的思路，写出状态转移方程：f(i,j)=max⁡(f(i,j−1),f(i+2j−1,j−1))f(i,j)=\\max(f(i,j-1),f(i+2^{j-1},j-1))f(i,j)=max(f(i,j−1),f(i+2j−1,j−1))。 查询 对于每个询问 [l,r][l,r][l,r]，我们把它分成两部分：f[l,l+2s−1]f[l,l+2^s-1]f[l,l+2s−1] 与 f[r−2s+1,r]f[r-2^s+1,r]f[r−2s+1,r]，其中 s=⌊log⁡2(r−l+1)⌋s=\\left\\lfloor\\log_2(r-l+1)\\right\\rfloors=⌊log2​(r−l+1)⌋。两部分的结果的最大值就是回答。 注意点 每次用 std::log 重新计算 log 函数值并不值得，建议进行如下的预处理： {Log2[1]=0,Log2[i]=Logn[i2]+1.\\left\\{\\begin{aligned} Log_2[1] &amp;=0, \\\\ Log_2\\left[i\\right] &amp;=Logn[\\frac{i}{2}] + 1. \\end{aligned}\\right. ⎩⎨⎧​Log2​[1]Log2​[i]​=0,=Logn[2i​]+1.​ ST 表维护其他信息 除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。 需要注意的是，对于“区间 GCD”，ST 表的查询复杂度并没有比线段树更优（令值域为 www，ST 表的查询复杂度为 Θ(log⁡w)\\Theta(\\log w)Θ(logw)，而线段树为 Θ(log⁡n+log⁡w)\\Theta(\\log n+\\log w)Θ(logn+logw)，且值域一般是大于 nnn 的），但是 ST 表的预处理复杂度也没有比线段树更劣，而编程复杂度方面 ST 表比线段树简单很多。 如果分析一下，“可重复贡献问题”一般都带有某种类似 RMQ 的成分。例如“区间按位与”就是每一位取最小值，而“区间 GCD”则是每一个质因数的指数取最小值。 总结 ST 表能较好的维护“可重复贡献”的区间信息（同时也应满足结合律），时间复杂度较低，代码量相对其他算法很小。但是，ST 表能维护的信息非常有限，不能较好地扩展，并且不支持修改操作。 模板题 P3865 【模板】ST 表 #include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 23, M = 18;int a[N], f[N][M];double Log[N];int n, m;double t = log(2);inline int read()&#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) f = -1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; x = x * 10 + ch - 48; ch = getchar(); &#125; return x * f;&#125;void init()&#123; Log[1] = .0; for (int i = 2; i &lt;= n; i++) Log[i] = Log[i / 2] + 1.; for (int i = 1; i &lt;= n; i++) f[i][0] = a[i]; for (int j = 1; j &lt; M; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]);&#125;inline int query(int l, int r)&#123; int len = r - l + 1; // int k = log(len) / t; int k = Log[len] / Log[2]; return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125;int main()&#123; // cin &gt;&gt; n &gt;&gt; m; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) // scanf(&quot;%d&quot;, a + i); a[i] = read(); init(); while (m--) &#123; int l, r; // scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = read(), r = read(); printf(&quot;%d\\n&quot;, query(l, r)); &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"牛客比赛/汇总","date":"2022-01-25T09:50:34.130Z","updated":"2022-01-29T14:55:42.556Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"喜迎暑假多校联赛第一场","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/动态规划/计数DP","date":"2022-01-23T08:23:17.691Z","updated":"2022-01-29T14:55:42.554Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数位DP","slug":"DS_Algorithm证明与讲解/动态规划/数位DP","date":"2022-01-22T16:00:00.000Z","updated":"2022-01-29T14:55:42.562Z","comments":true,"path":"posts/a3781d1f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/a3781d1f/","excerpt":"","text":"数位动态规划一般用来回答类似这样的问题： 请问区间 [l, r] 中有多少个满足某个条件的数。 其中 l 和 r 的范围一般很大。 例题：数数 问题：0 到 9 这些数字在 [l,r](1≤l≤r≤1016)[l,r](1\\le l\\le r\\le 10^{16})[l,r](1≤l≤r≤1016) ，中的数位中分别出现了多少次？ n=a1a2⋯ann=a_1a_2\\cdots a_nn=a1​a2​⋯an​ 000001 000010 000100 001000 010000 100000 …… (a1−1)00000(a_1-1)00000(a1​−1)00000","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"状态压缩DP","slug":"DS_Algorithm证明与讲解/动态规划/状态压缩DP","date":"2022-01-22T16:00:00.000Z","updated":"2022-01-23T05:49:28.151Z","comments":true,"path":"posts/9ba26914/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9ba26914/","excerpt":"","text":"一个例题 题目：摸鱼 压缩 1：把所有方案用 1~n-1 的十进制数表示 压缩 2：把每天的列表用数字表示","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"树形DP","slug":"DS_Algorithm证明与讲解/动态规划/树形DP","date":"2022-01-20T16:00:00.000Z","updated":"2022-01-23T05:39:12.607Z","comments":true,"path":"posts/9ba26914/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9ba26914/","excerpt":"","text":"wls 已经写得很好了，我就放个 链接 。 没有上司的舞会——无人数限制 #include&lt;bits/stdc++.h&gt; // 无人数限制using namespace std;#define int long longconst int N = 1e5 + 10;int h[N], e[N], ne[N], idx;int w[N];int f[N][2]; // 0:不参加 1:参加void add(int a, int b) &#123; e[++idx] = b, ne[idx] = h[a], h[a] = idx; &#125;void solve(int x)&#123; for (int i = h[x]; i != -1; i = ne[i]) &#123; int j = e[i]; solve(j); f[x][1] += f[j][0]; f[x][0] += max(f[j][1], f[j][0]); &#125;&#125;signed main()&#123; memset(h, -1, sizeof h); memset(f, 0, sizeof f); int n, x; cin &gt;&gt; n; for (int i = 2; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;, &amp;x); add(x, i); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;, w + i); f[i][1] = w[i]; &#125; solve(1); printf(&quot;%lld&quot;, max(f[1][0], f[1][1]));&#125; 新的背包 我们有一个总容量为 m(1≤m≤500)m(1\\le m\\le 500)m(1≤m≤500) 的袋子。又有 n(1≤n≤500)n(1\\le n\\le 500)n(1≤n≤500) 种物品，每种物品都有 m 个，它们的体积都是 1。对于第 i 种物品，如果我们一共取了 j 个，会获得 WijW_{ij}Wij​ 的收益，问如何选择物品，使得在物品的总体积 不超过 m 的情况下，获得最大的收益？请求出最大收益。 #include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint n, m, f[600][600], v[600][600];signed main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%lld&quot;, &amp;v[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt;= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - k] + v[i][k]); printf(&quot;%lld&quot;, f[n][m]);&#125; 没有上司的舞会——树上背包 考虑第 i 号员工的团队，除了考虑 i 参不参加，还需要考虑团队中一共有多少人参加了； 用 Fi,j,0、Fi,j,1F_{i,j,0}、F_{i,j,1}Fi,j,0​、Fi,j,1​ 分别表示考虑 i 号员工的团队，团队中一共有不超过 j 个人参加， i 不参加/参加 的情况下的最大快乐值。 上面的状态定义是空间压缩后的；（与多重背包的空间压缩同理） 完整的应该是：Fi,n,j,0F_{i,n,j,0}Fi,n,j,0​ 表示考虑 i 号员工的团队，从前 n 个直接下属中选择不超过 j 个人参加，i 不参加 的情况下的最大快乐值。（第四维等于 1 时为参加） 题目 P1352 没有上司的舞会 ：题解。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"换根树形DP","slug":"DS_Algorithm证明与讲解/动态规划/换根DP","date":"2022-01-20T16:00:00.000Z","updated":"2022-01-23T05:40:05.009Z","comments":true,"path":"posts/4286fd48/","link":"","permalink":"http://xiaoke-jin.github.io/posts/4286fd48/","excerpt":"","text":"[学习笔记]换根dp - UM的小屋 - 洛谷博客 wls的换根树形DP讲解 一个换根DP例子 我们用 size[i] 表示以 i 号点为根的子树中有多少个点；f[i] 表示考虑以 i 号点为根的子树中 i 号点到子树中其他所有点的距离和。 换根时发生了什么 当根从 1 变成它的子结点 i 的时候会发生什么？ （为了方便，第一次算的时候默认以 1 为根） i 多出一个以 1 为根的子树，而 i 原来的子树对 f[i] 的贡献不变。那么以 1 为根的子树对 f[1] 的贡献怎么算？ 用 v[i] 表示 i 的父亲作为 i 的子树时对 f[i] 的贡献。 v[i] = f[1] - f[i] - size[i] + n - size[i] f[1] - size[i] - f[i] ：去掉以 i 为根的子树对 f[1] 的贡献。 n - size[i] ：去掉以 i 为根的子树对 size[1] 的贡献。 现在考虑根从任意结点 x 变成它的子结点 y 的时候会发生什么？ v[y] = v[x] + f[x] - f[y] - size[y] + n - size[y] v[x] f[x] - f[y] size[y] n-size[y] 新根的答案怎么算 ans = v[y] + f[y] 总结——什么是换根树形DP 让我们来总结下这类问题。 \\qquad在这类问题中，我们需要求出以每个点为根时的值（在“距离和”中，我们要求的是以 i 号点为根时其他所有点到它的距离和）。在这类问题中，通常都可以定义从下往上考虑的数组 f（f[i] 表示考虑以 i 号点为根的子树的值）以及从上往下考虑的数组 v（v[i] 表示 i 号点的父亲 x 号点作为它的儿子时考虑以 x 号点为根的子树的值） ，最后要求的答案可以通过 f 和 v 算出。通用做法是先以任意点（实际操作中一般选择 1 号点）为根，做一遍有根数的树形动态规划，求出对应的 f；然后再从这个选定的任意点出发， 在递归遍历整棵树的过程中不断地把根从父亲变成儿子，与此同时求出对应的 v。这类问题一般被称为 换根树形动态规划问题 。 流","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"","slug":"读书笔记/算法导论/第 4 章 分治策略","date":"2022-01-20T13:44:57.267Z","updated":"2022-01-21T13:15:16.255Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"引理 1 向下取整和向上取整 ∀a,b,c∈Z,⌊abc⌋=⌊⌊ab⌋c⌋\\forall a,b,c\\in\\mathbb{Z},\\left\\lfloor\\frac{a}{bc}\\right\\rfloor=\\left\\lfloor\\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor ∀a,b,c∈Z,⌊bca​⌋=⌊c⌊ba​⌋​⌋ 略证： ab=⌊ab⌋+r(0≤r&lt;1) ⟹ ⌊abc⌋=⌊ab⋅1c⌋=⌊1c(⌊ab⌋+r)⌋=⌊⌊ab⌋c+rc⌋=⌊⌊ab⌋c⌋□\\begin{aligned} &amp;\\frac{a}{b}=\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r(0\\leq r&lt;1)\\\\ \\implies &amp;\\left\\lfloor\\frac{a}{bc}\\right\\rfloor =\\left\\lfloor\\frac{a}{b}\\cdot\\frac{1}{c}\\right\\rfloor =\\left\\lfloor \\frac{1}{c}\\left(\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r\\right)\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c} +\\frac{r}{c}\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor\\\\ &amp;&amp;\\square \\end{aligned} ⟹​ba​=⌊ba​⌋+r(0≤r&lt;1)⌊bca​⌋=⌊ba​⋅c1​⌋=⌊c1​(⌊ba​⌋+r)⌋=⌊c⌊ba​⌋​+cr​⌋=⌊c⌊ba​⌋​⌋​□​ 向上取整 ab=⌊ab⌋+r(0≤r&lt;1)⌈ab⌉=⌊ab⌋+[r&gt;0]=⌊ab⌋+⌈r⌉ (0≤r&lt;1) ⟹ ⌈abc⌉=⌈ab⋅1c⌉=⌈1c(⌊ab⌋+r)⌉=⌈⌊ab⌋c+rc⌉=⌈⌊ab⌋c+[r&gt;0]c⌉=⌈⌈ab⌉c⌉□\\begin{aligned} &amp;\\frac{a}{b}=\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r(0\\leq r&lt;1)\\\\ &amp;\\left\\lceil\\frac{a}{b}\\right\\rceil = \\left\\lfloor\\frac{a}{b}\\right\\rfloor+[r &gt; 0] = \\left\\lfloor\\frac{a}{b}\\right\\rfloor+ \\left\\lceil r\\right\\rceil\\ \\ \\ \\ (0\\leq r&lt;1)\\\\ \\implies &amp;\\left\\lceil\\frac{a}{bc}\\right\\rceil =\\left\\lceil\\frac{a}{b}\\cdot\\frac{1}{c}\\right\\rceil =\\left\\lceil \\frac{1}{c}\\left(\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r\\right)\\right\\rceil =\\left\\lceil \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c} +\\frac{r}{c}\\right\\rceil =\\left\\lceil \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c} +\\frac{[r &gt; 0]}{c}\\right\\rceil =\\left\\lceil \\frac{\\left\\lceil\\frac{a}{b}\\right\\rceil}{c}\\right\\rceil\\\\ &amp;&amp;\\square \\end{aligned} ⟹​ba​=⌊ba​⌋+r(0≤r&lt;1)⌈ba​⌉=⌊ba​⌋+[r&gt;0]=⌊ba​⌋+⌈r⌉ (0≤r&lt;1)⌈bca​⌉=⌈ba​⋅c1​⌉=⌈c1​(⌊ba​⌋+r)⌉=⌈c⌊ba​⌋​+cr​⌉=⌈c⌊ba​⌋​+c[r&gt;0]​⌉=⌈c⌈ba​⌉​⌉​□​","categories":[],"tags":[]},{"title":"浅谈二次剩余","slug":"DS_Algorithm证明与讲解/数学/数论/同余/二次剩余","date":"2022-01-18T16:00:00.000Z","updated":"2022-01-19T15:56:28.523Z","comments":true,"path":"posts/839c6db8/","link":"","permalink":"http://xiaoke-jin.github.io/posts/839c6db8/","excerpt":"","text":"链接：Alioth的博客 二次剩余 代码实现 #include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll w;struct Complex&#123; ll x, y;&#125;;Complex mul(Complex a, Complex b, ll p)&#123; Complex ans = &#123;0, 0&#125;; ans.x = ((a.x * b.x % p + a.y * b.y % p * w % p) % p + p) % p; ans.y = ((a.x * b.y % p + a.y * b.x % p) % p + p) % p; return ans;&#125;ll qp(ll a, ll b, ll p)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = 1ll * ans % p * a % p; a = a % p * a % p; b &gt;&gt;= 1; &#125; return ans % p;&#125;ll lmul(Complex a, ll b, ll p)&#123; Complex ans = &#123;1, 0&#125;; while (b) &#123; if (b &amp; 1) ans = mul(ans, a, p); a = mul(a, a, p); b &gt;&gt;= 1; &#125; return ans.x % p;&#125;ll solve(ll n, ll p)&#123; n = n % p; if (p == 2) return n; if (qp(n, (p - 1) &gt;&gt; 1, p) == p - 1) return -1; //不存在 ll a; while (1) &#123; a = rand() % p; w = ((a * a % p - n) % p + p) % p; if (qp(w, (p - 1) &gt;&gt; 1, p) == p - 1) break; &#125; Complex x = &#123;a, 1&#125;; return lmul(x, (p + 1) &gt;&gt; 1, p);&#125;int main()&#123; ll t = 1, n, p; scanf(&quot;%lld&quot;, &amp;t); while (t--) &#123; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p); // x^2 ≡ n (mod p) p是奇素数 if (!n) &#123; printf(&quot;0\\n&quot;); continue; &#125; ll ans1 = solve(n, p), ans2; if (ans1 == -1) &#123; printf(&quot;No Solution\\n&quot;); continue; &#125; ans2 = p - ans1; if (ans1 &gt; ans2) swap(ans1, ans2); if (ans1 == ans2) printf(&quot;%lld\\n&quot;, ans1); else printf(&quot;%lld %lld\\n&quot;, ans1, ans2); &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"FFT原理及实现","slug":"DS_Algorithm证明与讲解/数学/多项式/FFT","date":"2022-01-15T16:00:00.000Z","updated":"2022-02-18T13:51:34.393Z","comments":true,"path":"posts/bf2bcbd8/","link":"","permalink":"http://xiaoke-jin.github.io/posts/bf2bcbd8/","excerpt":"","text":"待更 算法｜FFT基础及各种常数优化，5万字笔记：公式推导+代码模板 递归版 #include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e6 + 10;const double PI = acos(-1.0);struct Complex&#123; double x, y; Complex(double xx = 0, double yy = 0) &#123; x = xx, y = yy; &#125; Complex operator+(const Complex &amp;t) const &#123; return &#123;x + t.x, y + t.y&#125;; &#125; Complex operator-(const Complex &amp;t) const &#123; return &#123;x - t.x, y - t.y&#125;; &#125; Complex operator*(const Complex &amp;t) const &#123; return &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;; &#125;&#125; A[N], B[N];void FFT(int limit, Complex *a, int type)&#123; if (limit == 1) return; // 只有一个常数项 Complex a1[(limit &gt;&gt; 1)], a2[(limit &gt;&gt; 1)]; // a1[]:偶数 a2[]:奇数 for (int i = 0; i &lt; limit; i += 2) // 根据下标的奇偶性分类 a1[i &gt;&gt; 1] = a[i], a2[i &gt;&gt; 1] = a[i + 1]; FFT(limit &gt;&gt; 1, a1, type); FFT(limit &gt;&gt; 1, a2, type); Complex Wn = Complex(cos(2.0 * PI / limit), type * sin(2.0 * PI / limit)), w = Complex(1, 0); // Wn为单位根，w表示幂 for (int i = 0; i &lt; (limit &gt;&gt; 1); i++, w = w * Wn) &#123; // 这里的w相当于公式中的k a[i] = a1[i] + w * a2[i]; // 左边加 a[i + (limit &gt;&gt; 1)] = a1[i] - w * a2[i]; // 右边减 &#125;&#125;int main()&#123; int N, M; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt;= N; i++) scanf(&quot;%lf&quot;, &amp;A[i].x); for (int i = 0; i &lt;= M; i++) scanf(&quot;%lf&quot;, &amp;B[i].x); int limit = 1; while (limit &lt;= N + M) limit &lt;&lt;= 1; // 2^n FFT(limit, A, 1); FFT(limit, B, 1); // 后面的1表示要进行的变换是什么类型 // 1表示从系数变为点值 // -1表示从点值变为系数 // 至于为什么这样是对的，可以参考一下c向量的推导过程， for (int i = 0; i &lt;= limit; i++) A[i] = A[i] * B[i]; FFT(limit, A, -1); for (int i = 0; i &lt;= N + M; i++) printf(&quot;%d &quot;, (int)(A[i].x / limit + 0.5)); //按照我们推倒的公式，这里还要除以n return 0;&#125; 迭代版 #include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;const double PI = 3.1415926535;struct Complex&#123; double x, y; Complex(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125; A[N], B[N];Complex operator*(Complex J, Complex Q)&#123; //模长相乘，幅度相加 return Complex(J.x * Q.x - J.y * Q.y, J.x * Q.y + J.y * Q.x);&#125;Complex operator-(Complex J, Complex Q)&#123; return Complex(J.x - Q.x, J.y - Q.y);&#125;Complex operator+(Complex J, Complex Q)&#123; return Complex(J.x + Q.x, J.y + Q.y);&#125;void FFT(int limit, Complex *a, int type)&#123; if (limit == 1) return; //只有一个常数项 Complex a1[limit &gt;&gt; 1], a2[limit &gt;&gt; 1]; for (int i = 0; i &lt;= limit; i += 2) //根据下标的奇偶性分类 a1[i &gt;&gt; 1] = a[i], a2[i &gt;&gt; 1] = a[i + 1]; FFT(limit &gt;&gt; 1, a1, type); FFT(limit &gt;&gt; 1, a2, type); Complex Wn = Complex(cos(2.0 * PI / limit), type * sin(2.0 * PI / limit)), w = Complex(1, 0); // Wn为单位根，w表示幂 for (int i = 0; i &lt; (limit &gt;&gt; 1); i++, w = w * Wn) &#123; //这里的w相当于公式中的k a[i] = a1[i] + w * a2[i]; //左边加 a[i + (limit &gt;&gt; 1)] = a1[i] - w * a2[i]; //右边减 &#125;&#125;int rev[N], bit, tot;void fft(Complex a[], int inv) // 迭代版&#123; for (int i = 0; i &lt; tot; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); // 得到递归到最底层的序列 for (int mid = 1; mid &lt; tot; mid &lt;&lt;= 1) // 自底向上合并 &#123; Complex w1 = Complex(&#123;cos(PI / mid), inv * sin(PI / mid)&#125;); for (int i = 0; i &lt; tot; i += mid * 2) // 对长度为 mid 的区间向上合并 &#123; Complex wk = Complex(&#123;1, 0&#125;); for (int j = 0; j &lt; mid; j++, wk = wk * w1) &#123; Complex x = a[i + j], y = wk * a[i + j + mid]; a[i + j] = x + y, a[i + j + mid] = x - y; &#125; &#125; &#125;&#125;int main()&#123; int N, M; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt;= N; i++) scanf(&quot;%lf&quot;, A[i].x); for (int i = 0; i &lt;= M; i++) scanf(&quot;%lf&quot;, B[i].x); int limit = 1; while (limit &lt;= N + M) limit &lt;&lt;= 1; for (int i = 0; i &lt; tot; i++) // 蝴蝶变换--------------------------------------- rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1)); FFT(limit, A, 1); FFT(limit, B, 1); //后面的1表示要进行的变换是什么类型 // 1表示从系数变为点值 //-1表示从点值变为系数 //至于为什么这样是对的，可以参考一下c向量的推导过程， for (int i = 0; i &lt;= limit; i++) A[i] = A[i] * B[i]; FFT(limit, A, -1); for (int i = 0; i &lt;= N + M; i++) printf(&quot;%d &quot;, (int)(A[i].x / limit + 0.5)); //按照我们推倒的公式，这里还要除以n return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"多项式","slug":"数据结构与算法/多项式","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://xiaoke-jin.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"FWT原理及实现","slug":"DS_Algorithm证明与讲解/数学/多项式/FWT","date":"2022-01-15T16:00:00.000Z","updated":"2022-02-19T02:32:21.017Z","comments":true,"path":"posts/2fdc99e6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/2fdc99e6/","excerpt":"","text":"算法笔记｜快速沃尔什变换 FWT（或卷积、与卷积、异或卷积）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"多项式","slug":"数据结构与算法/多项式","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://xiaoke-jin.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"NTT原理及实现","slug":"DS_Algorithm证明与讲解/数学/多项式/NTT","date":"2022-01-15T16:00:00.000Z","updated":"2022-01-22T08:10:13.373Z","comments":true,"path":"posts/6b176c6e/","link":"","permalink":"http://xiaoke-jin.github.io/posts/6b176c6e/","excerpt":"","text":"繁凡——超简单的快速数论变换（NTT）（FFT的优化）（含全套证明） Pecco——算法学习笔记(42): 快速数论变换 比FFT还容易明白的NTT（快速数论变换）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"多项式","slug":"数据结构与算法/多项式","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://xiaoke-jin.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"Burnside引理与polya定理","slug":"DS_Algorithm证明与讲解/数学/群论/Burnside引理与polya定理","date":"2022-01-15T16:00:00.000Z","updated":"2022-02-19T02:32:21.020Z","comments":true,"path":"posts/eb4bb1b0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/eb4bb1b0/","excerpt":"","text":"算法｜等价类计数问题学习笔记","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"群论简介","slug":"DS_Algorithm证明与讲解/数学/群论/群论基础","date":"2022-01-15T16:00:00.000Z","updated":"2022-01-21T12:57:27.808Z","comments":true,"path":"posts/aa05fcd4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/aa05fcd4/","excerpt":"","text":"欧拉公式与群论","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"二维计算几何基础","slug":"DS_Algorithm证明与讲解/计算几何/二维计算几何基础","date":"2022-01-14T16:00:00.000Z","updated":"2022-02-18T14:18:48.825Z","comments":true,"path":"posts/f92281da/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f92281da/","excerpt":"","text":"NaN 几何｜计算几何基础–规范数据表示 几何｜计算几何基础–判断点的位置 几何｜计算几何基础–线段的性质 几何 | 计算几何基础–半平面求交 练习｜半平面交题目汇总 学习｜判断一个点是否在三角形内","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算几何","slug":"数据结构与算法/计算几何","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://xiaoke-jin.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"卡特兰数简介","slug":"DS_Algorithm证明与讲解/数学/组合数学/卡特兰数","date":"2022-01-13T16:00:00.000Z","updated":"2022-01-16T05:32:57.362Z","comments":true,"path":"posts/b13205b0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b13205b0/","excerpt":"","text":"B站 卡特兰数","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"容斥原理简介","slug":"DS_Algorithm证明与讲解/数学/组合数学/容斥原理","date":"2022-01-13T16:00:00.000Z","updated":"2022-02-18T14:33:47.448Z","comments":true,"path":"posts/f700d41a/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f700d41a/","excerpt":"","text":"干货｜容斥原理（二进制实现） 题目 CF451E Devu and Flowers P2567 [SCOI2010]幸运数字 P1450 [HAOI2008]硬币购物","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数学/数论/同余/N次剩余","date":"2022-01-12T12:16:11.487Z","updated":"2022-01-12T14:47:03.678Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"高斯——约旦消元算法","slug":"DS_Algorithm证明与讲解/数学/线性代数/高斯消元","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-08T09:17:20.872Z","comments":true,"path":"posts/5c7fe989/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5c7fe989/","excerpt":"","text":"链接： 小白都能看懂的线性方程组及其解法 题目 P3389 【模板】高斯消元法 高斯消元板子 #include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;const double eps = 1e-8;int n;double a[N][N];int gauss() // 高斯消元，答案存于a[i][n]中，0 &lt;= i &lt; n&#123; int c, r; // 列column, 行row for (c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) // 找绝对值最大的行 if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) // 这一列最大值等于 0 continue; for (int i = c; i &lt;= n; i++) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i &gt;= c; i--) a[r][i] /= a[r][c]; // 将当前行的首位变成1 for (int i = r + 1; i &lt; n; i++) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) &gt; eps) for (int j = n; j &gt;= c; j--) a[i][j] -= a[r][j] * a[i][c]; r++; &#125;// 得到一个上三角 if (r &lt; n) &#123; // 存在系数全为 0 的行 for (int i = r; i &lt; n; i++) if (fabs(a[i][n]) &gt; eps) // 方程结果不为 0 return 2; // 无解 return 1; // 有无穷多组解 &#125; for (int i = n - 1; i &gt;= 0; i--) // 得到一个完美上三角, 对角线上均为 1 for (int j = i + 1; j &lt; n; j++) a[i][n] -= a[i][j] * a[j][n]; // 将之前的解代入 // 这里是减法, 所以可能会得到 eps &lt;a[i][n] &lt; 0, 所以输出时要特判, 避免输出 -0.00 return 0; // 有唯一解&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n + 1; j++) scanf(&quot;%lf&quot;, &amp;a[i][j]); int t = gauss(); if (t == 2) puts(&quot;No Solution&quot;); else if (t == 1) puts(&quot;Infinite group solutions&quot;); else &#123; for (int i = 0; i &lt; n; i++) &#123; if (fabs(a[i][n]) &lt; eps) a[i][n] = 0; // 去掉输出 -0.00 的情况 printf(&quot;%.2lf\\n&quot;, a[i][n]); &#125; &#125; return 0;&#125; 高斯——约旦消元板子 #include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;const double eps = 1e-8;double a[N][N];int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n + 1; j++) scanf(&quot;%lf&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; i++) //枚举列（项） &#123; int m = i; for (int j = i + 1; j &lt;= n; j++) //选出该列最大系数 if (fabs(a[j][i]) &gt; fabs(a[m][i])) // fabs是取浮点数的绝对值的函数 m = j; for (int j = 1; j &lt;= n + 1; j++) //交换 swap(a[i][j], a[m][j]); if (fabs(a[i][i]) &lt; eps) //最大值等于0则说明该列都为0，肯定无解 &#123; printf(&quot;No Solution\\n&quot;); return 0; &#125; for (int j = 1; j &lt;= n; j++) // 每一项都减去一个数 &#123; if (j != i) //不是主元那一项 &#123; double d = a[j][i] / a[i][i]; for (int k = i + 1; k &lt;= n + 1; k++) &#123; a[j][k] -= a[i][k] * d; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) // 最后的结果系数可能不为1，所以记得消去常数 &#123; printf(&quot;%.2lf\\n&quot;, a[i][n + 1] / a[i][i]); &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"线代","slug":"线代","permalink":"http://xiaoke-jin.github.io/tags/%E7%BA%BF%E4%BB%A3/"}]},{"title":"Lucas算法和exLucas","slug":"DS_Algorithm证明与讲解/数学/数论/同余/Lucas","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-08T06:02:26.053Z","comments":true,"path":"posts/36a502c4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/36a502c4/","excerpt":"","text":"Lucas算法 exLucas算法","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"类欧几里得算法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/类欧几里得算法","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-24T10:34:09.268Z","comments":true,"path":"posts/5aff289c/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5aff289c/","excerpt":"","text":"看洛谷模板题题解学算法：https://www.luogu.com.cn/problem/solution/P5170 类欧几里得算法学习 类欧学习笔记 题目 洛谷题单：类欧几里得算法基础 P5170 【模板】类欧几里得算法","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最小生成树/Boruvka","date":"2022-01-07T15:30:03.220Z","updated":"2022-01-08T05:30:40.961Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"https://cloud.tencent.com/developer/article/1411324","categories":[],"tags":[]},{"title":"BSGS算法","slug":"DS_Algorithm证明与讲解/数学/数论/同余/BSGS","date":"2022-01-06T16:00:00.000Z","updated":"2022-02-02T03:40:24.485Z","comments":true,"path":"posts/55c1ff4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/55c1ff4/","excerpt":"","text":"知乎 离散对数为什么是难题？ 关于高次同余方程，一般有 ax≡b( mod m)a^x\\equiv b(\\bmod m)ax≡b(modm) 和 xa≡b( mod m)x^a\\equiv b(\\bmod m)xa≡b(modm) 两种，这里只讨论第一种高次同余方程，第二种高次同余方程需要利用原根，阶，指标等概念。 BSGS算法 我们这里使用BSGS（Baby Step,Giant Step）算法求解 第一类高次同余方程 。 题目 洛谷题单：BSGS题单 P3846 可爱的质数 /【模板】BSGS：BSGS。 P2485 计算器：快速幂 + exgcd + BSGS。（注意数据范围）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/字符串/Manacher","date":"2022-01-06T08:24:54.374Z","updated":"2022-02-18T14:22:47.653Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"算法学习｜Manacher算法：如何求一个字符串的最长回文字符串长度 干货｜Manacher(马拉车)算法详解 干货|Manacher(马拉车)算法详解_牛客博客","categories":[],"tags":[]},{"title":"一些乱七八糟的东西","slug":"DS_Algorithm证明与讲解/竞赛杂谈","date":"2022-01-05T16:00:00.000Z","updated":"2022-03-31T05:20:37.759Z","comments":true,"path":"posts/e4de82cf/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e4de82cf/","excerpt":"","text":"为什么很多程序竞赛题目都要求答案对 1e9+7 取模？ - 知乎 几个时间复杂性类（NP/BPP/RP/ZPP） 数论：张益唐、余建春","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"杂谈","slug":"数据结构与算法/杂谈","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://xiaoke-jin.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"原根简介","slug":"DS_Algorithm证明与讲解/数学/数论/同余/阶和原根","date":"2022-01-05T16:00:00.000Z","updated":"2022-01-19T15:54:38.921Z","comments":true,"path":"posts/12e783a5/","link":"","permalink":"http://xiaoke-jin.github.io/posts/12e783a5/","excerpt":"","text":"前置芝士：费马—欧拉定理、裴蜀定理 关于循环节的一点思考：阶与原根 - 知乎 - Zhihu 分子为1的分数的循环节分别是多少位？这其中有什么规律？ 算法学习笔记(40): 原根 、题解 P6091 【模板】原根 整数的阶 性质 111： a,a2,⋯ ,aδm(a)a,a^2,\\cdots,a^{\\delta_m(a)}a,a2,⋯,aδm​(a) 模 mmm 两两不同余。 证明：考虑反证，假设存在两个数 i≠ji\\ne ji=j，且 ai≡aj(modm)a^i\\equiv a^j\\pmod mai≡aj(modm)，则有 a∣i−j∣≡1(modp)a^{|i-j|}\\equiv 1\\pmod pa∣i−j∣≡1(modp)。 但是显然的有：0&lt;∣i−j∣&lt;δm(a)0&lt;|i-j|&lt;\\delta_m(a)0&lt;∣i−j∣&lt;δm​(a)，这与阶的最小性矛盾，故原命题成立。 定理：如果(a,n)=1(a,n)=1(a,n)=1且 n&gt;0n&gt;0n&gt;0 ，那么 ai≡aj( mod n)a^i\\equiv a^j(\\bmod n)ai≡aj(modn) 当且仅当 i≡j( mod ord⁡na)i\\equiv j(\\bmod \\operatorname{ord}_na)i≡j(modordn​a) ，其中 i,ji,ji,j 是非负整数。 证明： 性质 444：设 k∈Nk \\in \\mathbb{N}k∈N，m∈N∗m\\in \\mathbb{N}^{*}m∈N∗，a∈Za\\in\\mathbb{Z}a∈Z，gcd⁡(a,m)=1\\gcd(a,m)=1gcd(a,m)=1，则 δm(ak)=δm(a)gcd⁡(δm(a),k)\\delta_m(a^k)=\\dfrac{\\delta_m(a)}{\\gcd\\big(\\delta_m(a),k\\big)} δm​(ak)=gcd(δm​(a),k)δm​(a)​ 证明：注意到： 原根 定义：如果 (r,n)=1(r,n)=1(r,n)=1 且 n&gt;0n&gt;0n&gt;0 ，那么当 ord⁡nr=φ(n)\\operatorname{ord}_nr=\\varphi(n)ordn​r=φ(n) 时，称 rrr 是模 nnn 的原根或者 nnn 的原根，并且我们称 nnn 有一原根。（原根就是特殊的阶） 定理：如果 (r,n)=1(r,n)=1(r,n)=1 且 n&gt;0n&gt;0n&gt;0 ，则如果 rrr 是模 nnn 的一个原根，那么 r1,r2,⋯ ,rφ(n)r^1,r^2,\\cdots,r^{\\varphi(n)}r1,r2,⋯,rφ(n) 构成模 nnn 的既约剩余系。 一个原根的某个幂还是一个原根 如果一个整数 nnn 有一个原根，那么它一共有 φ(φ(n))\\varphi(\\varphi(n))φ(φ(n)) 个不同余的原根。 求原根 找到所有的原根 最小原根的数量级 王元于 1959 年证明了若 mmm 有原根，其最小原根是不多于 m0.25m^{0.25}m0.25 级别的。此处略去证明。 这保证了我们暴力找一个数的最小原根，复杂度是可以接受的。 题目 P6091 【模板】原根：线性筛 + 暴力查找原根。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"题解/数论/整除/欧几里得算法/二元一次不定方程","date":"2022-01-05T07:56:19.844Z","updated":"2022-01-05T07:57:10.653Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"P5656 【模板】二元一次不定方程 (exgcd) 一个重要的题 #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int read()&#123; int w = 1, c, ret = 0; while ((c = getchar()) &gt; &#x27;9&#x27; || c &lt; &#x27;0&#x27;) w = (c == &#x27;-&#x27; ? -1 : 1); ret = c - &#x27;0&#x27;; while ((c = getchar()) &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) ret = ret * 10 + c - &#x27;0&#x27;; return ret * w;&#125;void print(int x)&#123; if (x &lt; 0) x = -x, putchar(&#x27;-&#x27;); if (x &gt; 9) print(x / 10); putchar(&#x27;0&#x27; + x % 10);&#125;LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; LL a = read(), b = read(), c = read(), x, y; LL d = exgcd(a, b, x, y); if (c % d != 0) puts(&quot;-1&quot;); else &#123; x *= c / d, y *= c / d; // 得到一组特解 LL p = b / d, q = a / d, k; // if (x &lt; 0) k = ceil((1.0 - x) / p), x += p * k, y -= q * k; // 将x提高到最小正整数 // if (x &gt;= 0) // k = (x - 1) / p, x -= p * k, y += q * k; // 将x降低到最小正整数 if (y &gt; 0) &#123; // 有正整数解 printf(&quot;%lld &quot;, (y - 1) / q + 1); // 将y减到1的方案数即为解的个数 printf(&quot;%lld &quot;, x); // 当前的x即为最小正整数x printf(&quot;%lld &quot;, (y - 1) % q + 1); // 将y取到最小正整数 printf(&quot;%lld &quot;, x + (y - 1) / q * p); // 将x提升到最大 printf(&quot;%lld &quot;, y); // 特解即为y最大值 &#125; else &#123; // 无x,y均为正整数的解 printf(&quot;%lld &quot;, x); // printf(&quot;%lld&quot;, y + q * (LL)ceil((1.0 - y) / q)); printf(&quot;%lld&quot;, y - q * (LL)floor((y - 1.0) / q)); &#125; puts(&quot;&quot;); &#125; &#125; return 0;&#125;// #include &lt;bits/stdc++.h&gt;// using namespace std;// typedef long long int;// const int INF = 2147483647;// int read()// &#123;// int w = 1, c, ret = 0;// while ((c = getchar()) &gt; &#x27;9&#x27; || c &lt; &#x27;0&#x27;)// w = (c == &#x27;-&#x27; ? -1 : 1);// ret = c - &#x27;0&#x27;;// while ((c = getchar()) &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)// ret = ret * 10 + c - &#x27;0&#x27;;// return ret * w;// &#125;// void print(int x)// &#123;// if (x &lt; 0)// x = -x, putchar(&#x27;-&#x27;);// if (x &gt; 9)// print(x / 10);// putchar(&#x27;0&#x27; + x % 10);// &#125;// int exgcd(int a, int b, int &amp;x, int &amp;y)// &#123;// int d = a;// if (b == 0)// x = 1, y = 0;// else// d = exgcd(b, a % b, y, x), y -= a / b * x;// return d;// &#125;// int main()// &#123;// int T;// cin &gt;&gt; T;// while (T--)// &#123;// int a = read(), b = read(), c = read(), x, y;// int d = exgcd(a, b, x, y);// if (c % d != 0)// puts(&quot;-1&quot;);// else// &#123;// x *= c / d, y *= c / d;// int p = b / d, q = a / d, k;// if (x &lt; 0)// k = ceil((1.0 - x) / p), x += p * k, y -= q * k;// else //将x提高到最小正整数// if (x &gt;= 0)// k = (x - 1) / p, x -= p * k, y += q * k; //将x降低到最小正整数// if (y &gt; 0)// &#123; //有正整数解// printf(&quot;%intd &quot;, (y - 1) / q + 1); //将y减到1的方案数即为解的个数// printf(&quot;%intd &quot;, x); //当前的x即为最小正整数x// printf(&quot;%intd &quot;, (y - 1) % q + 1); //将y取到最小正整数// printf(&quot;%intd &quot;, x + (y - 1) / q * p); //将x提升到最大// printf(&quot;%intd &quot;, y); //特解即为y最大值// &#125;// else// &#123; //无整数解// printf(&quot;%intd &quot;, x); //当前的x即为最小的正整数x// printf(&quot;%intd&quot;, y + q * (int)ceil((1.0 - y) / q)); //将y提高到正整数// &#125;// puts(&quot;&quot;);// &#125;// &#125;// return 0;// &#125;","categories":[],"tags":[]},{"title":"线性基学习笔记","slug":"DS_Algorithm证明与讲解/数学/线性代数/线性基","date":"2022-01-04T16:00:00.000Z","updated":"2022-02-18T14:07:00.057Z","comments":true,"path":"posts/7e52e099/","link":"","permalink":"http://xiaoke-jin.github.io/posts/7e52e099/","excerpt":"","text":"参考资料 https://www.luogu.com.cn/blog/635forever/solution-p3812 https://oi.men.ci/linear-basis-notes/ 算法｜线性基学习笔记 算法讲解｜线性基的性质和计算方法详解","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"数据结构与算法/线性代数","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"线代","slug":"线代","permalink":"http://xiaoke-jin.github.io/tags/%E7%BA%BF%E4%BB%A3/"}]},{"title":"数论——高次同余方程","slug":"DS_Algorithm证明与讲解/数学/数论/同余/高次同余方程","date":"2022-01-02T16:00:00.000Z","updated":"2022-01-14T08:16:20.335Z","comments":true,"path":"posts/90e0f818/","link":"","permalink":"http://xiaoke-jin.github.io/posts/90e0f818/","excerpt":"","text":"前言 咕咕咕，，， dls说二次剩余、N次剩余是useless！！！ 两种常见的高次同余方程： ax≡b( mod p)a^x\\equiv b(\\bmod p)ax≡b(modp) 和 xn≡b( mod p)x^n\\equiv b(\\bmod p)xn≡b(modp) 。 第一种方程可用 BSGSBSGSBSGS 来解。 第二种方程称为 NNN 次剩余；n=2n=2n=2 的特殊情况称为二次剩余，此时有更优秀的算法来解。 题目 【数论】BSGS","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"题解/数论/积性函数到杜教筛/莫比乌斯反演/cjlu_无聊的水题","date":"2021-12-24T17:08:55.940Z","updated":"2021-12-29T16:42:53.450Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"题目 无聊的数学题 解一 枚举 gcd + 杜教筛 解二","categories":[],"tags":[]},{"title":"题解：CF1617 GCD Problem","slug":"题解/数论/整除/素数/CF1617B","date":"2021-12-16T16:00:00.000Z","updated":"2021-12-23T10:29:21.337Z","comments":true,"path":"posts/705a7427/","link":"","permalink":"http://xiaoke-jin.github.io/posts/705a7427/","excerpt":"","text":"题目 CF1617B GCD Problem 已知 nnn ，求 a+b+c=na + b + c = na+b+c=n 且 gcd⁡(a,b)=c\\gcd(a, b) = cgcd(a,b)=c 。要求 a≠b≠ca\\ne b\\ne ca=b=c 。 10≤n≤10910\\le n\\le 10^910≤n≤109 设 a=x×c, b=y×ca = x\\times c,\\ b = y\\times ca=x×c, b=y×c ， 思路 1：数学解 将一个数拆分为两个互质的数 令 c=1c = 1c=1 ，则 x+y=n−1x + y = n - 1x+y=n−1 。只要将 n−1n-1n−1 拆分为两个互质的数即可。 若 n−1n-1n−1 为奇数，显然 (n−1)−2(n-1)-2(n−1)−2 和 2 互质。 若 n−1n-1n−1 为偶数，则只要找到一个小于 n−1n-1n−1 的质数 aaa 使得 a∤(n−1)a\\nmid (n-1)a∤(n−1) 。则 n−1=a×l+rn - 1 = a \\times l + rn−1=a×l+r ， 0&lt;r&lt;a0&lt;r&lt;a0&lt;r&lt;a ，显然 a×(l−1)+ra\\times (l-1)+ra×(l−1)+r 和 aaa 互质。 因为 n≤109n\\le 10^9n≤109 ，且前 10 个素数相乘爆 int，所以在前10个素数中必有一个是我们要找的 a。 思路2：构造解 如果 n≡0(mod2)n\\equiv0\\pmod 2n≡0(mod2) ，输出 (n−3,2,1)(n-3,2,1)(n−3,2,1) n−1n - 1n−1 为奇数，同思路1中的1 如果 n≡1(mod4)n\\equiv1\\pmod 4n≡1(mod4) ，输出 (⌊n2⌋−1,⌊n2⌋+1,1)(\\lfloor\\frac{n}{2} \\rfloor - 1,\\lfloor\\frac{n}{2} \\rfloor + 1,1)(⌊2n​⌋−1,⌊2n​⌋+1,1) n−1n - 1n−1 为偶数且 ⌊n2⌋\\lfloor\\frac{n}{2} \\rfloor⌊2n​⌋ 为偶数。相邻奇数互质。 如果 n≡3(mod4)n\\equiv3\\pmod 4n≡3(mod4) ，输出 (⌊n2⌋−2,⌊n2⌋+2,1)(\\lfloor\\frac{n}{2} \\rfloor - 2,\\lfloor\\frac{n}{2} \\rfloor + 2,1)(⌊2n​⌋−2,⌊2n​⌋+2,1) n−1n - 1n−1 为偶数但 ⌊n2⌋\\lfloor\\frac{n}{2} \\rfloor⌊2n​⌋ 为奇数。一个奇数的左相邻奇数和右相邻奇数互质，即 2n+12n+12n+1 和 2n+52n+52n+5 互质。 即 若两个奇数之差等于 2 的 n 次幂（1≤n1\\le n1≤n），则这两个奇数互质。 错误思路 (x+y+1)×c=n(x+y+1)\\times c=n(x+y+1)×c=n ，从 6 开始找 (x+y+1)(x+y+1)(x+y+1) 。 若 n 为大质数，直接 TLE。倒着枚举那就是令 c=1c=1c=1 。","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论杂题题单--无算法标签","slug":"题目/数论/数论题","date":"2021-12-03T16:00:00.000Z","updated":"2022-01-19T07:41:35.475Z","comments":true,"path":"posts/1899ae60/","link":"","permalink":"http://xiaoke-jin.github.io/posts/1899ae60/","excerpt":"","text":"数论杂题题单–无算法标签 本题单记录一下 CF 上刷过一些有趣的数论相关题，多是 1500 —— 2000+的题。以考察思维、概念为主。 一些有意思的题目后面会有标记。 CF1627D Not Adding 1 CF1617B GCD Problem ：题解 CD1612D X-Magic Pair CF1603B Moderate Modular Mode 1593D2 Half of Same 1 CF1542C Strange Function CF1542B Plus and Multiply CF1538D Another Problem About Dividing Numbers CF1514C Product 1 Modulo N ：相邻的自然数一定互质。 CF1469D Ceil Divisions 1 CF1459C Row GCD 1 CF1444A Division 1 CF1396A Multiples of Length CF1165D Almost All Divisors 1 CF1152C Neko does Maths 1 Sum of Consecutive Prime Numbers Prime Distance","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"}]},{"title":"","slug":"CodeForces/Div.2/729 Div.2","date":"2021-12-02T05:27:08.393Z","updated":"2021-12-04T02:29:04.065Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"CodeForces/Div.2/757 Div.2","date":"2021-12-02T05:26:39.497Z","updated":"2021-12-04T02:29:04.072Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"A B https://codeforces.com/problemset/problem/1614/B #include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;PII a[N];int b[N];int n;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; scanf(&quot;%d&quot;, &amp;n); int x; for (int i = 1; i &lt;= n; i++)&#123; scanf(&quot;%d&quot;, &amp;x); a[i] = &#123;x, i&#125;; &#125; sort(a + 1, a + n + 1); int idx = 1; long long sum = 0; for (int i = n; i &gt;= 1; i--) &#123; sum += 1ll * a[i].first * 2 * abs(idx); if(idx &gt; 0) &#123; b[a[i].second] = idx; idx = -idx; &#125; else &#123; b[a[i].second] = idx; idx = -idx; idx++; &#125; &#125; printf(&quot;%lld\\n0 &quot;, sum); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, b[i]); printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"P1352 没有上司的舞会 题解","slug":"题解/DP/树形DP/P1352 没有上司的舞会","date":"2021-11-30T16:00:00.000Z","updated":"2022-01-22T05:39:09.468Z","comments":true,"path":"posts/3a4efa66/","link":"","permalink":"http://xiaoke-jin.github.io/posts/3a4efa66/","excerpt":"","text":"题目 P1352 没有上司的舞会 输入 输入的第一行是一个整数 nnn 。 第 2 到第 n+1n + 1n+1 行，每行一个整数，第 i+1i+1i+1 行的整数表示 iii 号职员的快乐指数 rir_iri​。 第 n+2n + 2n+2 到第 2n2n2n 行，每行输入一对整数 l,kl, kl,k 代表 kkk 是 lll 的直接上司。 输出 最大快乐值 思路 一道裸题，基本思路不再赘述。具体看 wls的树形DP讲解 。 需要注意的是题目并没有指定树根，所以每组数据的根是不确定的。 namo，怎么 O(1)O(1)O(1) 找到树根而不是 O(n)O(n)O(n) 地找呢？ 发现结点编号为 1~n，所以 n 个结点的编号和为 sum := (n + 1) * n / 2 ，在输入数据中，每个结点作为子结点出现的次数是唯一的，所以对于每组 l,kl,kl,k ， sum -= l 。则最终 sum 为根结点编号。","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"题解/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"","slug":"CodeForces/补题记录","date":"2021-11-29T04:10:32.837Z","updated":"2022-01-23T04:49:23.800Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"Div.1 752 Div.1 Div.2 729 Div.2 757 Div.2 Education Round 117","categories":[],"tags":[]},{"title":"P4626 一道水题","slug":"题解/数论/整除/欧几里得算法/P4626 一道水题Ⅱ","date":"2021-11-27T16:00:00.000Z","updated":"2021-12-01T15:20:50.835Z","comments":true,"path":"posts/86eb60bc/","link":"","permalink":"http://xiaoke-jin.github.io/posts/86eb60bc/","excerpt":"","text":"题目 P4626 一道水题 II 。 求 1~n 的最小公倍数。 n≤1e8n\\le 1e8n≤1e8 思路 欧拉筛 1e8，对于小于等于 n 的每个素数，找其小于等于 n 的最大次幂的值。开 O2 即可 AC。 ll ans = 1;for(int i = 1; p[i] &lt;= n; i++)&#123; int t = p[i]; while(t &lt;= n) t *= p[i]; t /= p[i]; ans = ans * t % mod;&#125; 然后 开始优化 ！ 当 n 较大时，使用欧拉筛可以先把偶数滤掉。平均每个点快 60 ms。 p[++cnt] = 2;for(int i = 3; i &lt;= n; i += 2)&#123; // euler balabala&#125; 在欧拉筛中，for(int j = 1; p[j] &lt;= n / i; j++) 这一步为了防止溢出，大家通常会用除法，但通过控制变量法，我发现用 for(int j = 1; 1ll * p[j] * i &lt;= n; j++) 会更快！这也又一次说明了除法是有多么慢！ 最后，若一个素数 p 大于 n\\sqrt{n}n​ ，那么小于等于 n 时，p的最大次幂为 1。所以可以直接 ans = ans * p % mod 。这个其实影响不大，因为用 while 也就多 1 次乘法。","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"题解：比比谁更大","slug":"题解/数论/整除/因数/比比谁更大","date":"2021-11-26T16:00:00.000Z","updated":"2021-12-17T02:37:07.734Z","comments":true,"path":"posts/98f81663/","link":"","permalink":"http://xiaoke-jin.github.io/posts/98f81663/","excerpt":"","text":"题目 比比谁更大 思路 一上来就想到 n!n!n! 的质因子分解，然后快速幂，但是数据范围 1e9，筛素数铁 T 。 注意到 模数并不是质数，经过对模数质因子分解发现，这是 2~103之间部分数的乘积。 所以若 a 或 b 大于等于 103，则 a! mod 999068070a!\\bmod 999068070a!mod999068070 一定等于 0。 若 a 或 b 小于等于 103，直接边乘边取模即可。记得开 long long","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"min_25筛","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/min_25筛","date":"2021-11-24T16:00:00.000Z","updated":"2022-02-05T03:55:08.774Z","comments":true,"path":"posts/6e1de96f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/6e1de96f/","excerpt":"","text":"挖","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"杜教筛","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/杜教筛","date":"2021-11-24T16:00:00.000Z","updated":"2022-02-18T14:08:34.518Z","comments":true,"path":"posts/faa2e13b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/faa2e13b/","excerpt":"","text":"链接： 狄利克雷卷积及其快速计算方法及杜教筛 。算法讲解 | 杜教筛 唐靖哲：浅谈一类积性函数的前缀和 如何给一个已知积性函数配一个积性函数使得卷积后的函数好算前缀和。 如何计算递归式的时间复杂度，为什么只展开一层。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P1029 最大公约数和最小公倍数问题","slug":"题解/数论/整除/欧几里得算法/P1029 最大公约数和最小公倍数","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-26T08:36:58.945Z","comments":true,"path":"posts/c908cbb4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c908cbb4/","excerpt":"","text":"题目 [NOIP2001 普及组] 最大公约数和最小公倍数问题","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P2350 HAOI 外星人","slug":"题解/数论/积性函数到杜教筛/欧拉函数/P2350 外星人","date":"2021-11-22T16:00:00.000Z","updated":"2021-11-26T06:45:07.128Z","comments":true,"path":"posts/89ac1c0b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/89ac1c0b/","excerpt":"","text":"题目：P2350 [HAOI2012]外星人 。 题意 给出 N 的质因子分解。 令 N=φ(N)N=\\varphi(N)N=φ(N) ，求最少进行多少次这样的操作使得 N=1N=1N=1 。（因为 φ(1)=1\\varphi(1)=1φ(1)=1 ，所以要限制「最少」） φ(∏i=1npiqi)=∏i=1n(pi−1)piqi−1\\varphi(\\prod_{i=1}^{n}p_i^{q_i})=\\prod_{i=1}^{n}(p_i-1)p_i^{q_i-1}φ(∏i=1n​piqi​​)=∏i=1n​(pi​−1)piqi​−1​ 。 思路 首先 N 很大，无法表示。所以只能去挖掘其性质。 然后发现在每次的 N=φ(N)N=\\varphi(N)N=φ(N) 中，都会消耗一个 2 ，并产生若干个 2 。 又发现 N 的每个质因子产生的 2 是固定的。 所以预处理一下 1e5 内的质因子在迭代过程中所产生的 2 的个数即可 O(1)O(1)O(1) 给出答案。 若初始时 N 为奇数，即不含因子 2 ，则第一次迭代不消耗 2，但这不影响各个质因子产生的 2 的数量。所以若初始时 N 为奇数，操作数要加一。 代码 #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e5 + 23;int p[N], cnt, f[N];bool st[N];void getp(int n = 1e5)&#123; f[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if(!st[i]) p[++cnt] = i, f[i] = f[i - 1]; for (int j = 1; p[j] * i &lt;= n; j++) &#123; st[p[j] * i] = true; f[p[j] * i] = f[p[j]] + f[i]; if(i % p[j] == 0) break; &#125; &#125;&#125;int main()&#123; getp(); int T, m, p, q; cin &gt;&gt; T; while(T--) &#123; ll ans = 1ll; scanf(&quot;%d&quot;, &amp;m); while(m--) &#123; scanf(&quot;%d%d&quot;, &amp;p, &amp;q); if(p == 2) ans--; ans += 1ll * f[p] * q; &#125; printf(&quot;%lld\\n&quot;, ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"SP5971 LCM SUM","slug":"题解/数论/积性函数到杜教筛/欧拉函数/SPOJ 5971 LCM SUM","date":"2021-11-22T16:00:00.000Z","updated":"2021-11-26T06:45:07.130Z","comments":true,"path":"posts/bd88eb27/","link":"","permalink":"http://xiaoke-jin.github.io/posts/bd88eb27/","excerpt":"","text":"转载自 OI-Wiki 。 题目 SP5971 LCM Sum 求值（多组数据） ∑i=1nlcm⁡(i,n)s.t. 1⩽T⩽3×105,1⩽n⩽106\\sum_{i=1}^n \\operatorname{lcm}(i,n)\\quad \\text{s.t.}\\ 1\\leqslant T\\leqslant 3\\times 10^5,1\\leqslant n\\leqslant 10^6 i=1∑n​lcm(i,n)s.t. 1⩽T⩽3×105,1⩽n⩽106 做法一 易得原式即 ∑i=1ni⋅ngcd⁡(i,n)\\sum_{i=1}^n \\frac{i\\cdot n}{\\gcd(i,n)} i=1∑n​gcd(i,n)i⋅n​ 将原式复制一份并且颠倒顺序，然后将 n 一项单独提出，可得 12⋅(∑i=1n−1i⋅ngcd⁡(i,n)+∑i=n−11i⋅ngcd⁡(i,n))+n\\frac{1}{2}\\cdot \\left(\\sum_{i=1}^{n-1}\\frac{i\\cdot n}{\\gcd(i,n)}+\\sum_{i=n-1}^{1}\\frac{i\\cdot n}{\\gcd(i,n)}\\right)+n 21​⋅(i=1∑n−1​gcd(i,n)i⋅n​+i=n−1∑1​gcd(i,n)i⋅n​)+n 根据 gcd⁡(i,n)=gcd⁡(n−i,n)\\gcd(i,n)=\\gcd(n-i,n)gcd(i,n)=gcd(n−i,n)，可将原式化为 12⋅(∑i=1n−1i⋅ngcd⁡(i,n)+∑i=n−11i⋅ngcd⁡(n−i,n))+n\\frac{1}{2}\\cdot \\left(\\sum_{i=1}^{n-1}\\frac{i\\cdot n}{\\gcd(i,n)}+\\sum_{i=n-1}^{1}\\frac{i\\cdot n}{\\gcd(n-i,n)}\\right)+n 21​⋅(i=1∑n−1​gcd(i,n)i⋅n​+i=n−1∑1​gcd(n−i,n)i⋅n​)+n 两个求和式中分母相同的项可以合并。 12⋅∑i=1n−1n2gcd⁡(i,n)+n\\frac{1}{2}\\cdot \\sum_{i=1}^{n-1}\\frac{n^2}{\\gcd(i,n)}+n 21​⋅i=1∑n−1​gcd(i,n)n2​+n 即 12⋅∑i=1nn2gcd⁡(i,n)+n2\\frac{1}{2}\\cdot \\sum_{i=1}^{n}\\frac{n^2}{\\gcd(i,n)}+\\frac{n}{2} 21​⋅i=1∑n​gcd(i,n)n2​+2n​ 可以将相同的 gcd⁡(i,n)\\gcd(i,n)gcd(i,n) 合并在一起计算，故只需要统计 gcd⁡(i,n)=d\\gcd(i,n)=dgcd(i,n)=d 的个数。当 gcd⁡(i,n)=d\\gcd(i,n)=dgcd(i,n)=d 时，gcd⁡(id,nd)=1\\displaystyle\\gcd(\\frac{i}{d},\\frac{n}{d})=1gcd(di​,dn​)=1，所以 gcd⁡(i,n)=d\\gcd(i,n)=dgcd(i,n)=d 的个数有 φ(nd)\\displaystyle\\varphi(\\frac{n}{d})φ(dn​) 个。 故答案为 12⋅∑d∣nn2⋅φ(nd)d+n2 \\frac{1}{2}\\cdot\\sum_{d\\mid n}\\frac{n^2\\cdot\\varphi(\\frac{n}{d})}{d}+\\frac{n}{2} 21​⋅d∣n∑​dn2⋅φ(dn​)​+2n​ 变换求和顺序，设 d′=nd\\displaystyle d&#x27;=\\frac{n}{d}d′=dn​，合并公因式，式子化为 12n⋅(∑d′∣nd′⋅φ(d′)+1)\\frac{1}{2}n\\cdot\\left(\\sum_{d&#x27;\\mid n}d&#x27;\\cdot\\varphi(d&#x27;)+1\\right) 21​n⋅⎝⎛​d′∣n∑​d′⋅φ(d′)+1⎠⎞​ 设 g⁡(n)=∑d∣nd⋅φ(d)\\displaystyle \\operatorname{g}(n)=\\sum_{d\\mid n} d\\cdot\\varphi(d)g(n)=d∣n∑​d⋅φ(d)，已知 g⁡\\operatorname{g}g 为积性函数，于是可以 Θ(n)\\Theta(n)Θ(n) 筛出。每次询问 Θ(1)\\Theta(1)Θ(1) 计算即可。 下面给出这个函数筛法的推导过程： 首先考虑 g⁡(pjk)\\operatorname g(p_j^k)g(pjk​) 的值，显然它的约数只有 pj0,pj1,⋯ ,pjkp_j^0,p_j^1,\\cdots,p_j^kpj0​,pj1​,⋯,pjk​，因此 g⁡(pjk)=∑w=0kpjw⋅φ(pjw)\\operatorname g(p_j^k)=\\sum_{w=0}^{k}p_j^w\\cdot\\varphi(p_j^w) g(pjk​)=w=0∑k​pjw​⋅φ(pjw​) 又有 φ(pjw)=pjw−1⋅(pj−1)\\varphi(p_j^w)=p_j^{w-1}\\cdot(p_j-1)φ(pjw​)=pjw−1​⋅(pj​−1)，则原式可化为 ∑w=0kpj2w−1⋅(pj−1)\\sum_{w=0}^{k}p_j^{2w-1}\\cdot(p_j-1) w=0∑k​pj2w−1​⋅(pj​−1) 于是有 g⁡(pjk+1)=g⁡(pjk)+pj2k+1⋅(pj−1)\\operatorname g(p_j^{k+1})=\\operatorname g(p_j^k)+p_j^{2k+1}\\cdot(p_j-1) g(pjk+1​)=g(pjk​)+pj2k+1​⋅(pj​−1) 那么，对于线性筛中的 g⁡(i⋅pj)(pj∣i)\\operatorname g(i\\cdot p_j)(p_j|i)g(i⋅pj​)(pj​∣i)，令 i=a⋅pjw(gcd⁡(a,pj)=1)i=a\\cdot p_j^w(\\operatorname{gcd}(a,p_j)=1)i=a⋅pjw​(gcd(a,pj​)=1)，可得 g⁡(i⋅pj)=g⁡(a)⋅g⁡(pjw+1)\\operatorname g(i\\cdot p_j)=\\operatorname g(a)\\cdot\\operatorname g(p_j^{w+1}) g(i⋅pj​)=g(a)⋅g(pjw+1​) g⁡(i)=g⁡(a)⋅g⁡(pjw)\\operatorname g(i)=\\operatorname g(a)\\cdot\\operatorname g(p_j^w) g(i)=g(a)⋅g(pjw​) 即 g⁡(i⋅pj)−g⁡(i)=g⁡(a)⋅pj2w+1⋅(pj−1)\\operatorname g(i\\cdot p_j)-\\operatorname g(i)=\\operatorname g(a)\\cdot p_j^{2w+1}\\cdot(p_j-1) g(i⋅pj​)−g(i)=g(a)⋅pj2w+1​⋅(pj​−1) 同理有 g⁡(i)−g⁡(ipj)=g⁡(a)⋅pj2w−1⋅(pj−1)\\operatorname g(i)-\\operatorname g(\\frac{i}{p_j})=\\operatorname g(a)\\cdot p_j^{2w-1}\\cdot(p_j-1) g(i)−g(pj​i​)=g(a)⋅pj2w−1​⋅(pj​−1) 因此 g⁡(i⋅pj)=g⁡(i)+(g⁡(i)−g⁡(ipj))⋅pj2\\operatorname g(i\\cdot p_j)=\\operatorname g(i)+\\left (\\operatorname g(i)-\\operatorname g(\\frac{i}{p_j})\\right )\\cdot p_j^2 g(i⋅pj​)=g(i)+(g(i)−g(pj​i​))⋅pj2​ 时间复杂度：Θ(n+T)\\Theta(n+T)Θ(n+T) 代码 #include &lt;cstdio&gt;const int N = 1000000;int tot, p[N + 5];long long g[N + 5];bool flg[N + 5]; //标记数组void solve() &#123; g[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!flg[i]) &#123; p[++tot] = i; g[i] = (long long)1 * i * (i - 1) + 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= N; ++j) &#123; flg[i * p[j]] = 1; if (i % p[j] == 0) &#123; g[i * p[j]] = g[i] + (g[i] - g[i / p[j]]) * p[j] * p[j]; //代入推出来的式子 break; &#125; g[i * p[j]] = g[i] * g[p[j]]; &#125; &#125;&#125;int main() &#123; int T, n; solve(); //预处理g数组 scanf(&quot;%d&quot;, &amp;T); for (int i = 1; i &lt;= T; ++i) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%lld\\n&quot;, (g[n] + 1) * n / 2); &#125; return 0;&#125; 做法二 https://venusnero.github.io/2019/02/21/solution_sp5971/","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P2568 GCD","slug":"题解/数论/积性函数到杜教筛/莫比乌斯反演/P2568 GCD","date":"2021-11-22T16:00:00.000Z","updated":"2021-12-03T08:25:55.937Z","comments":true,"path":"posts/959831ee/","link":"","permalink":"http://xiaoke-jin.github.io/posts/959831ee/","excerpt":"","text":"题目链接：P2568 GCD 。 题意 给定正整数 nnn ，求 1⩽x, y⩽n1\\leqslant x,\\ y\\leqslant n1⩽x, y⩽n 且 gcd⁡(x, y)\\gcd(x,\\ y)gcd(x, y) 为素数的数对 x, yx,\\ yx, y 有多少对。 一个暴力思路 这是我第一次 AC 的做法，但它不是正解，然而效率还不错。但这也是我第一次一发通过紫题！敲完就交！所以要纪念一下。 update 2021-12-03 呜呜呜，这道题降级成蓝题了。 开始推狮子：（以下除法均为向下取整） 先枚举质数，再替换出莫比乌斯函数，再枚举因数即可。 ∑x=1n∑y=1n[gcd⁡(x,y)∈Primes]=∑p∑x=1n∑y=1n[gcd⁡(x,y)=p]=∑p∑x=1n/p∑y=1n/p[gcd⁡(x,y)=1]=∑p∑x=1n/p∑y=1n/p∑d∣gcd⁡(x,y)μ(d)=∑p∑d=1n/pμ(d)∑x=1n/p∑y=1n/p[d∣gcd⁡(x,y)]=∑p∑d=1n/pμ(d)∑x=1(n/p)d∑y=1(n/p)d1=∑p∑d=1n/pμ(d)(n/pd)2\\begin{aligned} \\sum_{x=1}^{n}\\sum_{y=1}^{n}[\\gcd(x,y)\\in \\text{Primes}] &amp; = \\sum_p\\sum_{x=1}^{n}\\sum_{y=1}^{n}[\\gcd(x,y) = p] \\\\ &amp; = \\sum_p\\sum_{x=1}^{n/p}\\sum_{y=1}^{n/p}[\\gcd(x,y) = 1] \\\\ &amp; = \\sum_p\\sum_{x=1}^{n/p}\\sum_{y=1}^{n/p}\\sum_{d\\mid \\gcd(x,y)}\\mu(d) \\\\ &amp; = \\sum_p\\sum_{d=1}^{n/p}\\mu(d)\\sum_{x=1}^{n/p}\\sum_{y=1}^{n/p} [d\\mid \\gcd(x,y)] \\\\ &amp; = \\sum_p\\sum_{d=1}^{n/p}\\mu(d)\\sum_{x=1}^{\\frac{(n/p)}{d}}\\sum_{y=1}^{\\frac{(n/p)}{d}} 1 \\\\ &amp; = \\sum_p\\sum_{d=1}^{n/p}\\mu(d)({\\dfrac{n/p}{d}})^2 \\end{aligned} x=1∑n​y=1∑n​[gcd(x,y)∈Primes]​=p∑​x=1∑n​y=1∑n​[gcd(x,y)=p]=p∑​x=1∑n/p​y=1∑n/p​[gcd(x,y)=1]=p∑​x=1∑n/p​y=1∑n/p​d∣gcd(x,y)∑​μ(d)=p∑​d=1∑n/p​μ(d)x=1∑n/p​y=1∑n/p​[d∣gcd(x,y)]=p∑​d=1∑n/p​μ(d)x=1∑d(n/p)​​y=1∑d(n/p)​​1=p∑​d=1∑n/p​μ(d)(dn/p​)2​ 好了，推到这里，用欧拉筛筛出 1~n 的质数，莫比乌斯函数，再求莫比乌斯函数前缀和。最后遍历质数，用数论分块求每个 d 的贡献即可！时间复杂度就是 O(∑pnp)O(\\sum_{p}\\sqrt{\\dfrac{n}{p}})O(∑p​pn​​) 。（我不会算QwQ） #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e7 + 10;int p[N], cnt;bool st[N];int mu[N];void getp(int n = 1e7)&#123; mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if(!st[i]) p[++cnt] = i, mu[i] = -1; for (int j = 1; p[j] * i &lt;= n; j++) &#123; st[p[j] * i] = true; if(i % p[j] == 0) &#123; mu[p[j] * i] = 0; break; &#125; mu[p[j] * i] = -mu[i]; &#125; &#125;&#125;int main()&#123; getp(); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= 1e7; ++i) mu[i] += mu[i - 1]; ll ans = 0; for (int i = 1; i &lt;= cnt &amp;&amp; p[i] &lt;= n; ++i) &#123; int end = n / p[i]; for (int l = 1, r; l &lt;= end; l = r + 1) &#123; r = n / (n / l); ans += 1ll * (mu[r] - mu[l - 1]) * (end / l) * (end / l); &#125; &#125; printf(&quot;%lld&quot;, ans); return 0;&#125; 暴力的进一步优化 然而上述式子在这道题 P2257 YY的GCD 中就会 TLE，所以需要进一步优化：筛法处理：链接 。循环预处理 链接 。 正解 依然是枚举质数，然后 ∑x=1n/p∑y=1n/p[gcd⁡(x,y)=1]=(2∑i=1n/pφ(i))−1\\sum_{x=1}^{n/p}\\sum_{y=1}^{n/p}[\\gcd(x,y) = 1]=\\big( 2\\sum_{i=1}^{n/p}\\varphi(i)\\big) -1∑x=1n/p​∑y=1n/p​[gcd(x,y)=1]=(2∑i=1n/p​φ(i))−1 。 预处理一下欧拉函数前缀和，枚举 1~n 质数，相加即可。 时间复杂度 O(n)O(n)O(n) 。欧拉筛 O(n)O(n)O(n) ，枚举质数 O(nlog⁡n)O(\\dfrac{n}{\\log{n}})O(lognn​) 。 或者是 OI-Wiki 上的大力猛推。链接 。","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/分块","date":"2021-11-20T03:56:49.424Z","updated":"2021-11-25T10:39:14.831Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"题目 洛谷题单：kb的数列分块&amp;整除分块入门题单","categories":[],"tags":[]},{"title":"","slug":"读书笔记/算法导论/第26章 最大流","date":"2021-11-14T02:59:12.962Z","updated":"2021-11-25T10:39:14.862Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"26.1 流网络 26.2 Ford-Fulkerson方法 26.3 最大二分匹配 26.4 推送-重贴标签算法 26.5 前置重贴标签算法","categories":[],"tags":[]},{"title":"","slug":"读书笔记/算法导论/第24章 单源最短路径","date":"2021-11-14T02:56:30.721Z","updated":"2021-11-25T10:39:14.863Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"24.1 Bellman-Ford算法 24.2 有向无环图中的单源最短路径问题 24.3 Dijstra算法 24.4 差分约束和最短路径 24.5 最短路径性质的证明","categories":[],"tags":[]},{"title":"","slug":"读书笔记/算法导论/第23章 最小生成树","date":"2021-11-14T02:55:21.266Z","updated":"2021-11-25T10:39:14.857Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"23.1 最小生成树的形成 23.2 Kruskal 与 Prim","categories":[],"tags":[]},{"title":"","slug":"读书笔记/算法导论/第22章 基本的图算法","date":"2021-11-14T02:51:56.664Z","updated":"2021-11-25T10:39:14.858Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"\\qquad对图算法进行讨论需要有一些约定和表述。给定图 G=(V,E)G=(V,E)G=(V,E) ，当对该图上的一个算法的运行时间进行表述时，我们通常以图的结点数 ∣V∣|V|∣V∣ 和边的条数 ∣E∣|E|∣E∣ 作为输入的规模。也就是说，我们用的是两个参数，而不是一个参数，来描述输入的规模。对这些参数，我们采用通常的约定来进行表述。在渐进记号中，符号 VVV 代表 ∣V∣|V|∣V∣ ，符号 EEE 代表 ∣E∣|E|∣E∣ 。例如，我们可以说，“某算法运行的时间为 O(VE)O(VE)O(VE) ”，意味着算法运行时间为 O(∣V∣∣E∣)O(|V||E|)O(∣V∣∣E∣) 。这种约定使运行时间的表达式更容易理解，而又不会产生模糊性。 \\qquad本书采用的另一种约定涉及伪代码。本书用 G.VG.VG.V 来表示图 GGG 的结点集，用 G.EG.EG.E 表示图 GGG 的边集合。也就是说。在伪代码中，我们将结点和边看做是图的属性。 前言 22.1 节对图的两种最常见的计算机表示法进行讨论。这两种表示法分别为邻接链表和邻接矩阵。 22.2 节讲解BFS，并演示如何创建一棵广度优先树。 22.3 节讲解DFS，同时对此种搜索所访问的结点之间的次序进行讨论，并对这方面的一些标准结果进行证明。 22.4 节给出深度优先搜索的一个实际应用：有向无环图的拓扑排序。 22.5 节则讨论深度优先搜索的另一个实际应用：有向图中计算强连通分量。 22.1 图的表示 \\qquad对于图 G=(V,E)G=(V,E)G=(V,E) ，可以用两个标准表示方法表示。一种表示方法将图作为邻接链表的组合，另一种表示法则将图作为邻接矩阵来看待。两种表示方法都既可以表示无向图，也可以表示有向图。邻接链表因为在表示稀疏图时非常紧凑而成为通常的选择。在稠密图的情况下，我们可能更倾向于使用邻接矩阵表示法。另外，如果需要快速判断任意两个结点之间是否有边相连，可能也需要使用邻接矩阵表示法。 邻接链表 \\qquad对于图 G=(V,E)G=(V,E)G=(V,E) ，其邻接链表表示由一个包含 ∣V∣|V|∣V∣ 条链表的数组 AdjAdjAdj 所构成，每个结点有一条链表。对于每个结点 u∈Vu\\in Vu∈V ，邻接链表 Adj[u]Adj[u]Adj[u] 包含所有与结点 uuu 之间有边相连的结点 vvv ，即 Adj[u]Adj[u]Adj[u] 包含图 GGG 中所有与 uuu 邻接的结点。在伪代码里，我们将数组 AdjAdjAdj 看做是图的一个属性，因此我们将看到 G.Adj[u]G.Adj[u]G.Adj[u] 这样的表示。 \\qquad如果 GGG 是一个有向图，则对于边 (u, v)(u,\\ v)(u, v) 来说，结点 vvv 将出现在链表 Adj[u]Adj[u]Adj[u] 里，因此，所有邻接链表的长度之和等于 ∣E∣|E|∣E∣ 。如果 GGG 是一个无向图，则对于边 (u, v)(u,\\ v)(u, v) 来说，结点 vvv 将出现在链表 Adj[u]Adj[u]Adj[u] 里，结点 uuu 将出现在链表 Adj[v]Adj[v]Adj[v] 里，因此，所有邻接链表的长度之和等于 2∣E∣2|E|2∣E∣ 。所以，无论是有向图还是无向图，邻接链表表示法的存储空间需求均为 O(V+E)O(V+E)O(V+E) 。 \\qquad邻接链表的一个潜在缺陷是无法快速判断一条边 (u,v)(u,v)(u,v) 是否是图中的一条边，唯一的办法是在邻接链表的 Adj[u]Adj[u]Adj[u] 里面搜索结点 。邻接矩阵克服了这个缺陷，但付出的代价是更大的存储空间消耗。（关于如何在邻接链表上进行快速边搜索的信息，请参阅练习 22.1-8） 邻接矩阵 \\qquad我们通常将图 GGG 中的结点编为 1,2,⋯ ,∣V∣1,2,\\cdots,|V|1,2,⋯,∣V∣ ，这种编号可以是任意的。在进行此种编号后，图 GGG 的邻接矩阵表示由一个 ∣V∣×∣V∣|V|\\times|V|∣V∣×∣V∣ 的矩阵 A=(aij)A=(a_{ij})A=(aij​) 予以表示。该矩阵满足下述条件：（w表示边 (i,j)(i,j)(i,j) 的权重，INF表示无穷大，即边 (i,j)(i,j)(i,j) 不存在） aij={w若(i,j)∈E INF其他a_{ij}= \\begin{cases} w &amp; 若 (i,j)\\in E\\ \\\\ \\text{INF} &amp; \\text{其他} \\end{cases} aij​={wINF​若(i,j)∈E 其他​ \\qquad无向图的邻接矩阵是一个对称矩阵。因为在无向图中，边 (u,v)(u,v)(u,v) 和边 (v,u)(v,u)(v,u) 是同一条边，无向图的邻接矩阵 AAA 就是自己的转置，即 A=ATA=A^TA=AT 。 22.2 广度优先搜索 \\qquad给定图 G=(V,E)G=(V,E)G=(V,E) 和一个可以识别的源结点 sss ，广度优先搜索对图 GGG 中的边进行系统性的探索来发现可以从源结点 sss 到达的所有结点。该算法能计算从源结点 sss 到每个可达的结点的距离（最小的边数），同时生成一棵“广度优先搜索树”。对于每个从源结点 sss 可以到达的结点 vvv ，在BFS树里从结点 sss 到结点 vvv 的 简单路径 所对应的就是图 GGG 中从结点 sss 到结点 vvv 的”最短路径“，即包含最少边数的路径。该算法即可以用于有向图，也可以用于无向图。 \\qquad广度优先搜索之所以如此命名是因为该算法始终是将已发现结点和未发现结点之间的边界，沿其广度方向向外扩展。也就是说，该算法需要在发现所有距离源结点 sss 为 kkk 的所有结点之后，才会发现距离源结点 sss 为 k+1k+1k+1 的所有结点。 \\qquad为了帮助理解算法的运行，BFS在逻辑上将每个结点涂上 白色、灰色 或 黑色 。所有结点在一开始的时候均涂上白色，表示未被搜索到。在算法推进过程中，第一次遇到一个结点就称该结点被“发现”，此时该结点的颜色将从白色变为灰色，表示发现该结点，但还未从该结点出发搜索其邻接点。所以对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点。灰色结点所代表的就是已知和未知两个集合之间的边界 。当我们从一个灰色的点出发搜索完其所有邻接点后，该结点变为黑色。 \\qquad在执行广度优先搜索的过程中将构造出一颗 广度优先树。一开始，该树仅含有根结点，就是源结点 sss 。在扫描已发现结点 uuu 的邻接链表时，每当发现一个白色结点 vvv ，就将结点 vvv 和边 (u,v)(u,v)(u,v) 同时加入该棵树中。在广度优先树中，称结点 uuu 是结点 vvv 的前驱或父结点。由于每个结点最多被发现一次，它最多有一个父结点。广度优先树中的祖先和后代关系皆以相对于根结点 sss 的位置来进行定义：如果结点 uuu 是从根结点 sss 到结点 vvv 的简单路径上的一个结点，则结点 uuu 是结点 vvv 的祖先，结点 vvv 是结点 uuu 的后代。 \\qquad在下面给出的广度优先搜索过程中，假定输入图 G=(V,E)G=(V,E)G=(V,E) 是以邻接链表所表示的。该算法为图中每个结点赋予了一些额外的属性：我们将每个结点 uuu 的颜色存放在属性 u.coloru.coloru.color 里，将 uuu 的前驱结点存放在属性 u.πu.\\piu.π 里。如果 uuu 没有前驱结点（例如 u=su=su=s 或结点 uuu 尚未被发现），则 u.π=NILu.\\pi=\\text{NIL}u.π=NIL 。属性 u.du.du.d 记录的是BFS所计算出的从源结点 sss 到结点 uuu 之间的距离。该算法使用一个先进先出的队列 QQQ 来管理灰色结点集合。 BFS(G,s)1for each vertex u∈G.V−{s}2u.color=WHITE3u.d=∞4u.π=NIL5s.color=GRAY6s.d=∞7s.π=NIL8Q=∅9ENQUEUE(Q,s)10while Q≠∅11u=DEQUEUE(Q)12for each v∈G.Adj[u]13if v.color==WHITE14v.color=GRAY15v.d=v.d+116v.π=u17ENQUEUE(Q,v)18u.coloe==BLACK\\quad BFS(G,s) \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\\\ \\begin{array}{ll} 1 &amp; \\textbf{for } \\text{each vertex }u\\in G.V - \\{s\\} \\\\ 2 &amp; \\qquad u.color = \\text{WHITE} \\\\ 3 &amp; \\qquad u.d = \\infty \\\\ 4 &amp; \\qquad u.\\pi = \\text{NIL} \\\\ 5 &amp; s.color = \\text{GRAY}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\\\ 6 &amp; s.d = \\infty \\\\ 7 &amp; s.\\pi = \\text{NIL} \\\\ 8 &amp; Q = \\varnothing \\\\ 9 &amp; \\text{ENQUEUE}(Q,s) \\\\ 10&amp; \\textbf{while }Q\\ne \\varnothing \\\\ 11&amp; \\qquad u= \\text{DEQUEUE}(Q) \\\\ 12&amp; \\qquad \\textbf{for }\\text{each }v\\in G.Adj[u] \\\\ 13&amp; \\qquad\\qquad \\textbf{if } v.color == \\text{WHITE} \\\\ 14&amp; \\qquad\\qquad \\qquad v.color = \\text{GRAY} \\\\ 15&amp; \\qquad\\qquad \\qquad v.d = v.d+1 \\\\ 16&amp; \\qquad\\qquad \\qquad v.\\pi = u \\\\ 17&amp; \\qquad\\qquad\\qquad\\text{ENQUEUE}(Q,v) \\\\ 18&amp; \\qquad u.coloe == \\text{BLACK} \\end{array} BFS(G,s)123456789101112131415161718​for each vertex u∈G.V−{s}u.color=WHITEu.d=∞u.π=NILs.color=GRAYs.d=∞s.π=NILQ=∅ENQUEUE(Q,s)while Q=∅u=DEQUEUE(Q)for each v∈G.Adj[u]if v.color==WHITEv.color=GRAYv.d=v.d+1v.π=uENQUEUE(Q,v)u.coloe==BLACK​ 算法第 10 行 while 循环的不变式为：队列 Q 里面包含的是灰色结点集合。==，，略，，，==，所以我们给出的循环不变式一直得到保持。 \\qquad广度优先搜索的结果可能依赖于每个结点的邻接结点的访问顺序：广度优先生成树可能会不一样，但本算法所计算出来的距离 ddd 都是一样的。 BFS时间复杂度 最短路径 我们定义从源结点 sss 到结点 vvv 的最短路径距离 δ(s,v)\\delta(s,v)δ(s,v) 为从结点 sss 到结点 vvv 之间所有路径的边数的最小值。如果从结点 sss 到结点 vvv 之间没有路径，则 δ(s,v)=∞\\delta(s,v)=\\inftyδ(s,v)=∞ 。我们称从结点 sss 到结点 vvv 的长度为 δ(s,v)\\delta(s,v)δ(s,v) 的路径为 sss 到 vvv 的 最短路径。在证明广度优先搜索可以正确计算出最短路径距离之前，我们先来讨论 最短路径的一个重要性质。 引理 22.1：给定 G=(V,E)G=(V,E)G=(V,E) （有向图或无向图），设 s∈Vs\\in Vs∈V 为任意结点，则对于任意边 (u,v)∈E(u,v)\\in E(u,v)∈E ， δ(s,v)⩽δ(s,u)+1\\delta(s,v)\\leqslant \\delta(s,u)+1δ(s,v)⩽δ(s,u)+1 。 证明： 我们现在证明 BFS 能够正确计算出每个结点 v∈Vv\\in Vv∈V 的 v.d=δ(s,v)v.d=\\delta(s,v)v.d=δ(s,v) 。首先证明 v.dv.dv.d 是 δ(s,v)\\delta(s,v)δ(s,v) 的一个上界。 引理 22.2： 要证明 v.d=δ(s,v)v.d=\\delta(s,v)v.d=δ(s,v) 。 引理 22.3： 下面的推论表明，在结点加入队列时，ddd 值随时间推移单调增长。 推论 22.4： 我们现在证明 广度优先搜索可以正确计算出最短路径距离 。 定理 22.5： 广度优先树 22.3 深度优先搜索 22.4 拓扑排序 22.5 强连通分量","categories":[],"tags":[]},{"title":"反演","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/反演","date":"2021-11-11T16:00:00.000Z","updated":"2022-02-19T02:32:21.022Z","comments":true,"path":"posts/c9b378cc/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c9b378cc/","excerpt":"","text":"算法｜反演学习笔记（含非卷积证明法详细证明）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"积性函数与狄利克雷卷积","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/积性函数与卷积","date":"2021-11-11T16:00:00.000Z","updated":"2022-01-01T14:02:04.003Z","comments":true,"path":"posts/dbc8cfae/","link":"","permalink":"http://xiaoke-jin.github.io/posts/dbc8cfae/","excerpt":"","text":"参考了几位大佬的博客： 0x30 积性函数 ， 0x40反演 ， 「笔记」莫比乌斯反演 ， 狄利克雷卷积与莫比乌斯反演 ， 浅谈一类积性函数的前缀和 。 积性函数 积性函数：对于数论函数 fff ，若任意互质的 p, qp,\\ qp, q 都有 f(pq)=f(p)f(q)f(pq)=f(p)f(q)f(pq)=f(p)f(q) ，则称 fff 是积性函数。 完全积性函数：对于数论函数 fff ，若任意的 p, qp,\\ qp, q 都有 f(pq)=f(p)f(q)f(pq)=f(p)f(q)f(pq)=f(p)f(q) ，则称 fff 是完全积性函数。 定义逐点加法：(f+g)(x)=f(x)+g(x), (f⋅g)(x)=f(x)g(x)(f+g)(x)=f(x)+g(x),\\ \\ \\ (f\\cdot g)(x)=f(x)g(x)(f+g)(x)=f(x)+g(x), (f⋅g)(x)=f(x)g(x) 。 定理：积性函数一定满足 f(1)=1f(1)=1f(1)=1 。 证明：设 f(a)≠0f(a)\\ne 0f(a)=0 ，则 f(a)=f(1×a)=f(1)f(a)f(a)=f(1\\times a)=f(1)f(a)f(a)=f(1×a)=f(1)f(a) 。显然 f(1)=1f(1)=1f(1)=1 。 定理：对于任意的 n&gt;1, n=p1a1p2a2⋯psasn&gt;1,\\ n=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n&gt;1, n=p1a1​​p2a2​​⋯psas​​ ，则对积性函数 fff 有： f(n)=∏i=1sf(piai)f(n)=\\prod_{i=1}^{s}f(p_i^{a_i})f(n)=∏i=1s​f(piai​​) 。 凡是积性函数都可用线性筛求。 若 f, gf,\\ gf, g 是积性函数，则下列函数也是积性函数。 h(x)=f(xp)h(x)=fp(x)h(x)=f(x)g(x)h(x)=∑d∣xf(d)g(xd)\\begin{aligned} h(x) =&amp; f(x^p)\\\\ h(x) =&amp; f^p(x)\\\\ h(x) =&amp; f(x)g(x)\\\\ h(x) =&amp; \\sum_{d\\mid x}f(d)g(\\dfrac{x}{d}) \\end{aligned} h(x)=h(x)=h(x)=h(x)=​f(xp)fp(x)f(x)g(x)d∣x∑​f(d)g(dx​)​ 常见积性函数 定义：在 全体正整数（或全体整数）上定义的函数称作数论函数或算术函数。（当然，更一般些，也可把数论函数看作是在某一整数集合上定义的函数。） 下面来列举一些定义在全体自然数集合上的数论函数。 狄利克雷卷积的单位元 ε(n)\\varepsilon(n)ε(n) ε(n)={1 n=10 n&gt;1\\begin{array}{l} \\varepsilon(n)= \\left\\{\\begin{matrix} 1\\ \\ \\text{}n=1 \\\\ 0\\text{}\\ \\ n&gt;1 \\\\ \\end{matrix}\\right. \\end{array} ε(n)={1 n=10 n&gt;1​​ 除数函数 σλ(n)\\sigma_\\lambda(n)σλ​(n) ，λ\\lambdaλ 为实数。 σλ(n)=∑d∣ndλ\\sigma_\\lambda(n)=\\sum_{d\\mid n}d^{\\lambda}σλ​(n)=∑d∣n​dλ 。 当 λ=0\\lambda=0λ=0 ， nnn 的所有正因子数目，通常记作 d(n)d(n)d(n) 或 τ(n)\\tau(n)τ(n) ，d(n)=∑d∣n1d(n)=\\sum_{d\\mid n}1d(n)=∑d∣n​1 。 当 λ=1\\lambda=1λ=1 ， nnn 的所有正因子和，通常记作 σ(n)\\sigma(n)σ(n) ，σ(n)=∑d∣nd\\sigma(n)=\\sum_{d\\mid n}dσ(n)=∑d∣n​d 。 idk(n)=nkid^k(n)=n^kidk(n)=nk ，幂函数 id(n)=nid(n)=nid(n)=n ，单位函数（恒等函数） 111(n)=id0(n)=n0=1, n⩾1(n)=id^0(n)=n^0= 1,\\ \\ n\\geqslant 1(n)=id0(n)=n0=1, n⩾1 不变函数 欧拉函数 φ(n)\\varphi(n)φ(n) ，φ(n)=∑1⩽d⩽n (d, n)=11\\varphi(n)=\\sum_{1\\leqslant d\\leqslant n\\\\ \\ (d,\\ n)=1}1φ(n)=∑1⩽d⩽n (d, n)=1​1 莫比乌斯函数 μ(n)\\mu(n)μ(n)​ μ(n)={1n=1 0n 含有平方因子(−1)kk 为 n 的本质不同质因子个数 \\mu(n)= \\begin{cases} 1 &amp; n=1\\ \\\\ 0 &amp; n\\text{ 含有平方因子}\\\\ (-1)^k &amp; k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\ \\end{cases} μ(n)=⎩⎨⎧​10(−1)k​n=1 n 含有平方因子k 为 n 的本质不同质因子个数 ​ 积性函数的计算 O(n)O(\\sqrt{n})O(n​) 求单个函数值 原理： f(∏i=1kpiei)=∏i=1kf(piei)f(\\prod_{i=1}^{k}p_i^{e_i})=\\prod_{i=1}^{k}f(p_i^{e_i})f(∏i=1k​piei​​)=∏i=1k​f(piei​​) 。 int getf(int n)&#123; int ans = 1; for(int i = 2; i &lt;= n; i++) &#123; if(n % i == 0) &#123; int cnt = 0; while(n % i == 0) cnt++, n /= i; ans *= f(i, cnt); // 计算 f(p^cnt) &#125; &#125; if(n &gt; 1) ans *= f(n, 1); return ans;&#125; O(n)O(n)O(n) 求 1~n 的函数值 原理： f(∏i=1kpiei)=∏i=1kf(piei)f(\\prod_{i=1}^{k}p_i^{e_i})=\\prod_{i=1}^{k}f(p_i^{e_i})f(∏i=1k​piei​​)=∏i=1k​f(piei​​) 。 int p[N], pcnt; // p[]: 素数集合bool st[N]; // st[i] = true, i为合数int f[N]; // f[]: 一个积性函数int cntint calc_f(int p, int i); // 返回 f(p^i)void getf(int n)&#123; for(int i = 2; i &lt;= n; i++) &#123; if(!st[i]) &#123; p[++pcnt] = i; f[i] = calc_f(i, 1); cnt[i] = 1; &#125; for(int j = 1; p[j] * i &lt;= n; j++) &#123; st[p[j] * i] = true; if(i % p[j] == 0) &#123; cnt[p[j] * i] = cnt[i] + 1; f[p[j] * i] = f[i] / calc_f(p[j], cnt[i]) * calc_f(p[j], cnt[i] + 1); break; &#125; &#125; cnt[p[j] * i] = 1; f[p[j] * i] = f[i] * f[p[j]]; &#125;&#125; 莫比乌斯函数 性质：∑d∣nμ(d)=[n=1]\\sum_{d\\mid n}\\mu(d)=[n=1]∑d∣n​μ(d)=[n=1] 。即 ∑d∣nμ(d)=ε(n)\\sum_{d\\mid n}\\mu(d)=\\varepsilon(n)∑d∣n​μ(d)=ε(n) ，μ∗1=ε\\mu*1=\\varepsilonμ∗1=ε ，「 ∗*∗ 」为狄利克雷卷积。 证明：当 n=1n=1n=1 时，显然成立。设 n=p1α1p2α2⋯psαsn=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_s^{\\alpha_s}n=p1α1​​p2α2​​⋯psαs​​ ，则由 μ(n)\\mu(n)μ(n) 的定义知 ∑d∣nμ(d)=μ(1)+μ(p1)+⋯+μ(ps)+μ(p1p2)+⋯+μ(ps−1ps)+⋯+μ(p1p2⋯ps)=1+(s1)(−1)+(s2)(−1)2+⋯+(ss)(−1)s=0■\\qquad\\qquad\\qquad \\begin{aligned}\\sum_{d\\mid n}\\mu(d) &amp;=\\mu(1)+\\mu(p_1)+\\cdots+\\mu(p_s)+\\mu(p_1p_2)+\\cdots+\\mu(p_{s-1}p_s)+\\cdots+\\mu(p_1p_2\\cdots p_s)\\\\ &amp;= 1+\\dbinom{s}{1}(-1)+\\dbinom{s}{2}(-1)^2+\\cdots +\\dbinom{s}{s}(-1)^s \\\\ &amp;=0\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare \\end{aligned}d∣n∑​μ(d)​=μ(1)+μ(p1​)+⋯+μ(ps​)+μ(p1​p2​)+⋯+μ(ps−1​ps​)+⋯+μ(p1​p2​⋯ps​)=1+(1s​)(−1)+(2s​)(−1)2+⋯+(ss​)(−1)s=0■​ 由上可知，对于整数 i, ji,\\ ji, j ，有 [ gcd⁡(i, j)=1 ]=∑d∣gcd⁡(i, j)μ(d)[\\ \\gcd(i,\\ j)=1\\ ]=\\displaystyle\\sum_{d\\mid \\gcd(i,\\ j)}\\mu(d)[ gcd(i, j)=1 ]=d∣gcd(i, j)∑​μ(d) 。 性质： μ\\muμ 是积性函数。 证明： 线性筛求莫比乌斯函数。 int p[N], cntp;bool st[N];int mu[N];void get_mu(int n)&#123; for(int i = 2; i &lt;= n; i++) &#123; if(!st[i]) &#123; p[++cntp] = i; mu[i] = -1; &#125; for(int j = 1; p[j] &lt;= n / i; j++) &#123; st[p[j] * i] = true; if(i % p[j] == 0) &#123; mu[p[j] * i] = 0; break; &#125; mu[p[j] * i] = -mu[i]; &#125; &#125;&#125; Dirichlet 卷积 定义：若 f, gf,\\ gf, g 是两个数论函数，则 f, gf,\\ gf, g 的狄利克雷卷积是 (f∗g)(n)=∑d∣nf(d)g(nd)(f*g)(n)=\\sum_{d\\mid n}f(d)g(\\dfrac{n}{d})(f∗g)(n)=∑d∣n​f(d)g(dn​) 。 交换律：f∗g=g∗ff*g=g*ff∗g=g∗f 证明：(f∗g)(n)=∑d∣nf(d)g(nd)=∑d∣nf(nd)g(d)=(g∗f)(n)(f*g)(n)=\\sum_{d\\mid n}f(d)g(\\dfrac{n}{d})=\\sum_{d\\mid n}f(\\dfrac{n}{d})g(d)=(g*f)(n)(f∗g)(n)=∑d∣n​f(d)g(dn​)=∑d∣n​f(dn​)g(d)=(g∗f)(n) 。 结合律：f∗(g∗h)=(f∗g)∗hf*(g*h)=(f*g)*hf∗(g∗h)=(f∗g)∗h 证明：设 G=g∗hG=g*hG=g∗h ，(f∗G)(n)=∑ad=nf(a)G(d)=∑ad=nf(d)∑bc=dg(b)h(c)=∑abc=nf(a)g(b)h(c)(f*G)(n)=\\sum_{ad=n}f(a)G(d)=\\sum_{ad=n}f(d)\\sum_{bc=d}g(b)h(c)=\\sum_{abc=n}f(a)g(b)h(c)(f∗G)(n)=∑ad=n​f(a)G(d)=∑ad=n​f(d)∑bc=d​g(b)h(c)=∑abc=n​f(a)g(b)h(c) 。 设 F=f∗gF=f*gF=f∗g ，可得到相同结果。 分配律： f∗(g+h)=f∗g+f∗hf*(g+h)=f*g+f*hf∗(g+h)=f∗g+f∗h 。 等式的性质： f=gf=gf=g 的充要条件是 f∗h=g∗hf*h=g*hf∗h=g∗h ，其中数论函数 hhh 要满足 h(1)≠0h(1)\\ne 0h(1)=0 。 单位元： f∗ε=ff*\\varepsilon=ff∗ε=f 。 逆元： 若函数 f, gf,\\ gf, g 为积性函数，则 f∗gf*gf∗g 也为积性函数。（ ∗*∗ 为狄利克雷卷积） 积性函数的逆元也是积性函数。 常见积性函数的卷积 对于所有的积性函数 fff ，有 f∗ε(n)=f(n)f*\\varepsilon(n)=f(n)f∗ε(n)=f(n) 。 1∗1(n)=∑d∣n1=d(n)1*1(n)=\\sum_{d\\mid n}1=d(n)1∗1(n)=∑d∣n​1=d(n) 。 id∗1(n)=∑d∣nd=σ(n)id*1(n)=\\sum_{d\\mid n}d=\\sigma(n)id∗1(n)=∑d∣n​d=σ(n) 。 μ∗1(n)=∑d∣nμ(d)=[ n=1 ]=ε(n)\\mu*1(n)=\\sum_{d\\mid n}\\mu(d)=[\\ n=1\\ ]=\\varepsilon(n)μ∗1(n)=∑d∣n​μ(d)=[ n=1 ]=ε(n) 。 φ∗1(n)=∑d∣nφ(d)=n=id(n)\\varphi*1(n)=\\sum_{d\\mid n}\\varphi(d)=n=id(n)φ∗1(n)=∑d∣n​φ(d)=n=id(n) 。 设 FFF 是数论函数 fff 的 莫比乌斯变换：则 F=f∗1F=f*1F=f∗1 ，即 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) 。 FFF 也称作 fff 的和函数。 由和函数 FFF 求 fff 的操作称为 莫比乌斯反演 ： F∗μ=(f∗u)∗μ=f∗(u∗μ)=f∗I=fF*\\mu=(f*u)*\\mu=f*(u*\\mu)=f*I=fF∗μ=(f∗u)∗μ=f∗(u∗μ)=f∗I=f ，即 f(n)=∑d∣nμ(d)F(nd)f(n)=\\sum_{d\\mid n}\\mu(d)F(\\dfrac{n}{d})f(n)=∑d∣n​μ(d)F(dn​) 。 nlogn的卷积预处理 已知数论函数 f, gf,\\ gf, g ，求 f∗g(n)=∑d∣nf(d)g(nd)f*g(n)=\\sum_{d\\mid n}f(d)g(\\dfrac{n}{d})f∗g(n)=∑d∣n​f(d)g(dn​) 的前 n 项和。 void Dirichlet(ll *f, ll *g)&#123; // f = f * g 结果保存在 f[]中 int h[N] = &#123;0&#125;; for(int i = 1; i &lt;= n; ++ i) &#123; // 对于每个 i for(int j = i; j &lt;= n; j += i) &#123; // 枚举 i 的倍数，为 n/i个(向下取整) h[j] = (h[j] + f[i] * g[j / i]) % mod; &#125; &#125; for(int i = 1; i &lt;= n; i++) f[i] = h[i]; // 结果保存在 f[]&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"莫比乌斯反演","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/莫反与各种反演","date":"2021-11-11T16:00:00.000Z","updated":"2022-02-18T13:37:21.950Z","comments":true,"path":"posts/9bf12f33/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9bf12f33/","excerpt":"","text":"前置芝士：积性函数与狄利克雷卷积 莫比乌斯变换 用欧拉筛求积性函数的莫比乌斯变换 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) ，积性函数 fff 的莫比乌斯变换 FFF 是积性函数，但如果 fff 不是莫比乌斯函数，那么求 FFF 的递推式会很麻烦，如果 fff 是莫比乌斯函数，就会简单很多。所以若 不是莫比乌斯函数，还是用狄利克雷前缀和。 两个 fff 为莫比乌斯函数的例子 链接 的例四 链接 OI-Wiki 上的大力猛推（ fff 为欧拉函数）：链接 狄利克雷前缀和 更通用，也更简单，但是它是 O(nlog⁡log⁡(n))O(n\\log\\log(n))O(nloglog(n)) 。复杂度同埃氏筛。链接 或者干脆更暴力地，对于 ∑d∣nf(d)\\sum_{d\\mid n}f(d)∑d∣n​f(d) ，把 f(d)f(d)f(d) 加到每个 f(dj)f(dj)f(dj) 中。 for(int i = 1; i &lt;= n; i++) for(int j = 1; j * i &lt;= n; j++) F[i * j] += f(i); 莫比乌斯反演 莫比乌斯反演公式 莫比乌斯反演证明 推导结论 莫反练习 链接： 莫比乌斯反演-让我们从基础开始 ， 莫比乌斯反演-从莫比乌斯到欧拉 。 欧拉反演 链接： 欧拉反演 。 但是注意，如果 gcd⁡(x,y)\\gcd(x, y)gcd(x,y) 出现在分母这种不正常的位置，就不能用那个神奇的欧拉反演，而应该用常规方法。 例题： P2398 GCD SUM 常用技巧 [gcd⁡(x,y)=1]=∑d∣gcd⁡(x,y)μ(d)[\\gcd(x, y)=1]=\\sum_{d\\mid \\gcd(x, y)}\\mu(d)[gcd(x,y)=1]=∑d∣gcd(x,y)​μ(d) 。 欧拉反演： n=∑d∣nφ(d)n=\\sum_{d\\mid n}\\varphi(d)n=∑d∣n​φ(d) 。 对于 ∑k=1n∑d=1⌊nk⌋μ(d)×⌊nkd⌋×⌊mkd⌋\\displaystyle\\sum_{k=1}^{n}\\sum_{d=1}^{\\lfloor \\frac{n}{k}\\rfloor}\\mu(d)\\times \\lfloor\\dfrac{n}{kd}\\rfloor \\times \\lfloor\\dfrac{m}{kd}\\rfloork=1∑n​d=1∑⌊kn​⌋​μ(d)×⌊kdn​⌋×⌊kdm​⌋，看似已经化成最简的式子，我们有一个常用方法可以降低时间复杂度。使用线性筛处理：链接 ，循环预处理： 链接2 。链接 中的例四。 Dirichlet 前缀和 板子： Dirichlet 前缀和 题目 P2303 [SDOI2012] Longge 的问题 HDU 5628 Clarke and math ：快速卷 QwQ [SDOI2015]约数个数和 ：题解 。性质： d(ij)=∑x∣i∑y∣j[gcd(x,y)=1]\\displaystyle d(ij)=\\sum_{x\\mid i}\\sum_{y\\mid j}[gcd(x,y)=1]d(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1] 。 P2257 YY的GCD ：题解 。如果不继续优化则 TLE。⭐ 对于 ∑k=1n∑d=1⌊nk⌋μ(d)×⌊nkd⌋×⌊mkd⌋\\displaystyle\\sum_{k=1}^{n}\\sum_{d=1}^{\\lfloor \\frac{n}{k}\\rfloor}\\mu(d)\\times \\lfloor\\dfrac{n}{kd}\\rfloor \\times \\lfloor\\dfrac{m}{kd}\\rfloork=1∑n​d=1∑⌊kn​⌋​μ(d)×⌊kdn​⌋×⌊kdm​⌋，看似已经化成最简的式子，我们有一个常用方法可以降低时间复杂度。使用线性筛处理：链接 ，循环预处理： 链接2 。 P3911 最小公倍数之和 ⭐ 无聊的数学题 ： P1447 能量采集 P6055 GCD ⭐ P6810 Convex Hull 凸包 给定数组 a，求 ∑i∑jgcd⁡(ai,aj)\\sum_i\\sum_j\\gcd(a_i,a_j)∑i​∑j​gcd(ai​,aj​) 。 分解质因数 + 欧拉反演 + 组合数","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"读书笔记/组合数学/第4章 生成排列与组合","date":"2021-11-09T01:30:50.728Z","updated":"2021-11-25T10:39:14.785Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/组合数学/第3章 鸽巢原理","date":"2021-11-09T01:30:50.728Z","updated":"2021-11-25T10:39:14.784Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/组合数学/第5章 二项式系数","date":"2021-11-09T01:30:50.728Z","updated":"2021-11-25T10:39:14.784Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/组合数学/第6章 容斥原理及其应用","date":"2021-11-09T01:30:50.728Z","updated":"2021-11-25T10:39:14.786Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/组合数学/第8章 特殊计数序列","date":"2021-11-09T01:30:50.728Z","updated":"2021-11-25T10:39:14.787Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/组合数学/第7章 递推关系和生成函数","date":"2021-11-09T01:30:50.728Z","updated":"2021-11-25T10:39:14.787Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"《组合数学》第二章 排列与组合","slug":"读书笔记/组合数学/第2章 排列与组合","date":"2021-11-08T16:00:00.000Z","updated":"2021-11-25T10:39:14.886Z","comments":true,"path":"posts/ee73cf38/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ee73cf38/","excerpt":"","text":"本章探讨四个一般的原理及它们所蕴涵的某些计数公式。而每一个原理又给出也要讨论的“补”原理。最后我们陈述这些原理在有限概率方面的应用。 2.1 四个基本的计数原理 加法原理 乘法原理 减法原理 除法原理 很多计数问题都可归类为下面的类型之一： 计数对象的有序排列的个数或对象的有序选择的个数 任何对象都不重复 允许对象重复（但可能是有限制的） 计数对象的无序排列数目或对象的无序选择数目 任何对象都不重复 允许对象重复（但可能是有限制的） （1）中考虑到顺序的放置或选择通常称为排列（permutition）。（2）中与顺序无关的放置或选择称为组合（combination）。 2.2 集合的排列 \\qquad我们用 P(n, r)P(n,\\ r)P(n, r) 表示 nnn 元素集合的 rrr 排列的数目。如果 r&gt;nr&gt;nr&gt;n ，则 P(n, r)=0P(n,\\ r)=0P(n, r)=0 。对每个正整数 nnn ， P(n, 1)=nP(n,\\ 1)=nP(n, 1)=n 。 nnn 元素集合的 nnn 排列简称为 SSS 的排列或 nnn 个元素的排列。 定理 2.2.1：对于正整数 nnn 和 rrr ， r⩽nr\\leqslant nr⩽n ，有 P(n, r)=∏i=1r(n−i+1)P(n,\\ r)=\\prod_{i=1}^{r}(n-i+1)P(n, r)=∏i=1r​(n−i+1) 。 证明： 对于非负整数 ，我们定义 n!n!n! （读作 nnn 的阶乘）为 n!=∏i=1nin!=\\prod_{i=1}^{n}in!=∏i=1n​i 。并约定 n!=1n!=1n!=1 。 于是可以写成 P(n, r)=n!(n−r)!P(n,\\ r)=\\dfrac{n!}{(n-r)!}P(n, r)=(n−r)!n!​ 。对于 n⩾0n\\geqslant0n⩾0 ，我们定义 P(n, 0)=1P(n,\\ 0)=1P(n, 0)=1 。 2.3 集合的组合（子集） 我们用 (nr)\\dbinom{n}{r}(rn​) 表示 nnn 元素集合的 rrr 子集的数目。 显然 (nr)=0\\dbinom{n}{r}=0(rn​)=0 ，如果 r&gt;nr&gt;nr&gt;n 。(0r)=0\\dbinom{0}{r}=0(r0​)=0 ，如果 r&gt;0r&gt;0r&gt;0 。 对于每个非负整数 nnn ， (n0)=1\\dbinom{n}{0}=1(0n​)=1 ，(n1)=n\\dbinom{n}{1}=n(1n​)=n ，(nn)=1\\dbinom{n}{n}=1(nn​)=1 。特别地， (00)=1\\dbinom{0}{0}=1(00​)=1 。 定理 2.3.1 推论 2.3.2 定理 2.3.3 定理 2.3.4 定理 2.3.4：对于 n&gt;=0n&gt;=0n&gt;=0 ，有 (n0)+(n1)+(n2)+⋯+(nn)=2n\\dbinom{n}{0}+\\dbinom{n}{1}+\\dbinom{n}{2}+\\cdots+\\dbinom{n}{n}=2^n(0n​)+(1n​)+(2n​)+⋯+(nn​)=2n ，且这个共同值等于 nnn 元素集合的子集数量。 证明： 多重集合的排列 多重集合的组合","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"组合数学","slug":"读书笔记/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"关于和式","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/关于和式","date":"2021-11-07T16:00:00.000Z","updated":"2022-01-01T13:34:49.160Z","comments":true,"path":"posts/e0cf0adb/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e0cf0adb/","excerpt":"","text":"视频链接：南大蒋炎岩 、∑：求和符号保姆级教学！ 《具体数学》上也有详细的介绍。（然而我看得很不顺利QwQ 20221.1 更新","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"生成函数入门","slug":"DS_Algorithm证明与讲解/数学/组合数学/生成函数","date":"2021-11-01T16:00:00.000Z","updated":"2022-01-14T13:13:05.787Z","comments":true,"path":"posts/51ade0b4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/51ade0b4/","excerpt":"","text":"一些资源 视频： 南大蒋岩炎 。 博客：小学生都能看懂的生成函数入门教程 【转载】母函数详解 组合数学中的母函数/生成函数 一些我很喜欢的组合证明 从杨辉三角中的奇偶性问题到卢卡斯问题 浅谈 OI 中常用的一些生成函数运算的合法与正确性 浅谈生成函数与组合计数 题目","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"读书笔记/具体数学/第二章 和式","date":"2021-10-31T03:48:53.399Z","updated":"2021-11-25T10:39:14.781Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第七章 乘性函数","slug":"读书笔记/初等数论及其应用/第七章 乘性函数","date":"2021-10-25T16:00:00.000Z","updated":"2021-11-25T10:39:14.900Z","comments":true,"path":"posts/537c89a6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/537c89a6/","excerpt":"","text":"导言 在本章中，我们研究定义在整数集合上的一类称为 乘性函数（或积性函数）的特殊函数。 乘性函数具有这样的性质，即它在一个整数上的函数值等于对该整数做素幂因子分解后所有素数幂上的函数值之积。 我们将证明一些重要的函数是乘性的，包括 因子个数函数、因子和函数 以及 欧拉 φ\\varphiφ 函数。利用这些函数是乘性函数的性质，基于正整数 nnn 的素幂因子分解，我们得到这些函数在 nnn 处的函数值的公式. 进一步，我们将研究一类称为 完全数 的特殊正整数，这类数与其 真因子 之和相等。我 们将证明所有偶完全数由一类称为梅森素数的特殊素数生成，梅森素数是那些形如 2p−12^p-12p−1（ppp 是素数）的素数。人们很早就开始寻找新的梅森素数，而具有很强计算能力的计算机和因特 网的出现加速了这类素数的寻找. 我们还将证明如何用 算术函数（即对所有正整数定义的函数）的 和函数 来得到函数自身的一些信息。函数 fff 的和函数在 nnn 处的函数值等于 fff 在 nnn 的所有正因子处的函数值之和。著名的 莫比乌斯反演公式 证明了如何从和函数的取值得到 fff 的函数取值. 最后，我们将研究关于 无限制拆分 和 受限制拆分 的算术函数。 所谓 拆分 是指将一个正整数表示为若干个正整数的和，不计其中的次序。 受限制拆分则是指拆分项受到一定的约束。 我们将给出一系列令人惊讶的关于这些算术函数之间的等式，并且引入诸多在研究拆分时很重要的概念。 7.1 欧拉函数 在本节中将证明欧拉函数是乘性函数。我们可以通过整数的素幂因子分解来给出乘性函数在该整数上的函数值的计算公式。 定义：定义在所有正整数上的函数称为算术函数。 在本章中，我们关心的是具有某些特殊性质的算术函数。 定义：如果算术函数 fff 对任意两个互素的正整数 n, mn,\\ mn, m ，均有 f(mn)=f(m)f(n)f(mn)=f(m)f(n)f(mn)=f(m)f(n) ，就称为 乘性函数（或积性函数）。如果对任意两个正整数 n, mn,\\ mn, m ，均有 f(mn)=f(m)f(n)f(mn)=f(m)f(n)f(mn)=f(m)f(n) ，就称为 完全乘性（或完全积性）函数。 定理 7.1 乘性函数的计算 如果 fff 是一个乘性函数，那么对于给定的 nnn 的素幂因子分解，能够得到 f(n)f(n)f(n) 的一个简单计算公式。这是一个很有用的结果，它告诉我们在已知 nnn 的素幂因子分解 n=p1a1p2a2⋯psasn=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n=p1a1​​p2a2​​⋯psas​​ 的情况下如何从 f(piai) (i=1,2,⋯ ,s)f(p_i^{a_i})\\ (i=1,2,\\cdots,s)f(piai​​) (i=1,2,⋯,s) 中得到 f(n)f(n)f(n) 的值。 定理 7.1：如果 fff 是一个乘性函数，且对任意正整数 nnn 有素幂因子分解 n=p1a1p2a2⋯psasn=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n=p1a1​​p2a2​​⋯psas​​ ，那么 f(n)=f(p1a1)f(p2a2)⋯f(psas)f(n)=f(p_1^{a_1})f(p_2^{a_2})\\cdots f(p_s^{a_s})f(n)=f(p1a1​​)f(p2a2​​)⋯f(psas​​) 。 证明： 现在回到欧拉函数，首先考虑它在素数与素数幂处的值。分别在定理 7.2、7.3中说明。 定理 7.2 欧拉函数在素数处的值 定理 7.2：如果 ppp 是素数，那么 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 。反之，如果 ppp 是正整数且满足 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 ，那么 ppp 是素数。 证明：如果 ppp 是素数，那么任意小于 ppp 的正整数都是与 ppp 互素的。因为有 p−1p-1p−1 个这样的整数，所以 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 。反之，若 ppp 是正整数且满足 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 ，说明 p≠1p\\ne 1p=1 且 ppp 除了 1 和它本身没有别的因数，所以 ppp 为素数。 证明：如果 ppp 是素数，那么任意小于 ppp 的正整数都是与 ppp 互素的。因为有 p−1p-1p−1 个这样的整数，所以 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 。反之，如果 ppp 不是素数，那么 p=1p=1p=1 或 ppp 是合数。如果 p=1p=1p=1 ，那么 φ(p)≠p−1\\varphi(p)\\ne p-1φ(p)=p−1 ，因为 φ(1)=1\\varphi(1)=1φ(1)=1 。如果 ppp 是合数，那么 ppp 有一个因子 ddd 满足 1&lt;d&lt;p1&lt;d&lt;p1&lt;d&lt;p ，显然 ddd 和 ppp 不互素。由于 p−1p-1p−1 个整数 1,2,⋯ ,p−11,2,\\cdots,p-11,2,⋯,p−1 中至少有一个整数（即 ddd ）是不和 ppp 互素的，故 φ(p)⩽p−2\\varphi(p)\\leqslant p-2φ(p)⩽p−2 。因此，如果 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 ，那么 ppp 必是素数。 定理 7.3 欧拉函数在素数幂处的值 定理 7.3：设 ppp 是素数， aaa 是一个正整数，那么 φ(pa)=pa−pa−1\\varphi(p^a)=p^a-p^{a-1}φ(pa)=pa−pa−1 。 证明：不超过 pap^apa 且和 pap^apa 不互素的正整数就是那些不超过 pap^apa 且能够被 ppp 整除的整数，即 kpkpkp ，其中 1⩽k⩽pa−11\\leqslant k\\leqslant p^{a-1}1⩽k⩽pa−1 ，因为恰有 pa−1p^{a-1}pa−1 个这样的整数，所以存在 pa−pa−1p^a-p^{a-1}pa−pa−1 个不超过 pap^apa 且和 pap^apa 互素的正整数。所以 φ(pa)=pa−pa−1\\varphi(p^a)=p^a-p^{a-1}φ(pa)=pa−pa−1 。 定理 7.4 欧拉函数是乘性函数 给定 nnn 的素幂因子分解，为了给出 φ(n)\\varphi(n)φ(n) 的公式，需要证明 φ\\varphiφ 是乘性函数。 定理 7.5 欧拉函数的计算 由定理 7.3，7.4，我们得到下面关于 φ(n)\\varphi(n)φ(n) 的公式。 定理 7.5：设 n=p1a1p2a2⋯pkakn=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}n=p1a1​​p2a2​​⋯pkak​​ 为正整数 nnn 的素幂因子分解，那么 φ(n)=n(1−1p1)(1−1p2)⋯(1−1pk)\\varphi(n)=n(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots (1-\\dfrac{1}{p_k})φ(n)=n(1−p1​1​)(1−p2​1​)⋯(1−pk​1​) 。 证明：因为 φ\\varphiφ 是乘性函数，故由定理 7.1 可知 φ(n)=φ(p2a2)φ(pkak)⋯φ(p1a1)\\varphi(n)=\\varphi(p_2^{a_2})\\varphi(p_k^{a_k})\\cdots \\varphi(p_1^{a_1})φ(n)=φ(p2a2​​)φ(pkak​​)⋯φ(p1a1​​) 。 另外由定理 7.3，我们知道当 j=1,2,⋯ ,kj=1,2,\\cdots,kj=1,2,⋯,k 时，有 φ(pjaj)=pjaj−pjaj−1=pjaj(1−1pj)\\varphi(p_j^{a_j})=p_j^{a_j}-p_{j}^{a_{j-1}}=p_j^{a_j}(1-\\dfrac{1}{p_j})φ(pjaj​​)=pjaj​​−pjaj−1​​=pjaj​​(1−pj​1​) 。 因此 φ(n)=p1a1(1−1p1)p2a2(1−1p2)⋯pkak(1−1pk)=p1a1p2a2⋯pkak(1−1p1)(1−1p2)⋯(1−1pk)=n(1−1p1)(1−1p2)⋯(1−1pk)\\begin{align*} \\varphi(n)&amp;=p_1^{a_1}(1-\\dfrac{1}{p_1})p_2^{a_2}(1-\\dfrac{1}{p_2})\\cdots p_k^{a_k}(1-\\dfrac{1}{p_k})\\\\ &amp;=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots(1-\\dfrac{1}{p_k})\\\\ &amp;=n(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots(1-\\dfrac{1}{p_k}) \\end{align*} φ(n)​=p1a1​​(1−p1​1​)p2a2​​(1−p2​1​)⋯pkak​​(1−pk​1​)=p1a1​​p2a2​​⋯pkak​​(1−p1​1​)(1−p2​1​)⋯(1−pk​1​)=n(1−p1​1​)(1−p2​1​)⋯(1−pk​1​)​ 定理 7.6 欧拉函数值的奇偶 定理 7.6：设 nnn 是一个大于 2 的正整数，那么 φ(n)\\varphi(n)φ(n) 是偶数。 证明：设 nnn 的素幂因子分解为 n=p1a1p2a2⋯psasn=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n=p1a1​​p2a2​​⋯psas​​ 。因为 φ\\varphiφ 是乘性函数，所以 φ(n)=∏j=1sφ(pjaj)\\varphi(n)=\\displaystyle \\prod_{j=1}^{s}\\varphi(p_j^{a_j})φ(n)=j=1∏s​φ(pjaj​​) 。由定理 7.3，我们知道 φ(pjaj)=pjaj−1(pj−1)\\varphi(p_j^{a_j})=p_j^{a_j-1}(p_j-1)φ(pjaj​​)=pjaj​−1​(pj​−1) 。可以看到当 pjp_jpj​ 是奇素数时， φ(pjaj)\\varphi(p_j^{a_j})φ(pjaj​​) 是偶数，这是因为当 pjp_jpj​ 是奇数时， pj−1p_j-1pj​−1 是偶数；当 pj=2p_j=2pj​=2 且 aj&gt;1a_j&gt;1aj​&gt;1 时， pjaj−1p_j^{a_j-1}pjaj​−1​ 是偶数。给定 n&gt;2n&gt;2n&gt;2 ， pjp_jpj​ 是奇数或者 pj=2p_j=2pj​=2 且 aj&gt;1a_j&gt;1aj​&gt;1 这两个条件中至少满足一个，所以 φ(pjaj)\\varphi(p_j^{a_j})φ(pjaj​​) 在 1⩽j⩽s1\\leqslant j\\leqslant s1⩽j⩽s 时至少有一个是偶数，因此 φ(n)\\varphi(n)φ(n) 是偶数。 和函数 设 fff 是一个算术函数，那么 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) 代表 fff 在 nnn 的所有正因子处的值之和。函数 FFF 称为 fff 的 和函数。 下面证明欧拉函数在 nnn 的所有正因子处的值之和为 nnn ，这个结果在后面也是有用的。这表明欧拉函数的和函数是个 恒等函数，即在 nnn 处的值恰是 nnn 。 定理 7.7 欧拉函数的和函数 定理 7.7：设 nnn 为正整数，那么 ∑d∣nφ(d)=n\\sum_{d\\mid n}\\varphi(d)=n∑d∣n​φ(d)=n 。 证明：我们将从 111 到 nnn 的整数构成的集合进行分类。整数 mmm 如果与 nnn 的最大公因子为 ddd ，则 mmm 属于 CdC_dCd​ 类。也就是说，如果 mmm 属于 CdC_dCd​ ，那么 (m/d, n/d)=1(m/d,\\ n/d)=1(m/d, n/d)=1 。所以 CdC_dCd​ 中所含的整数的个数是所有不超过 n/dn/dn/d 且和 n/dn/dn/d 互素的正整数的个数，即 CdC_dCd​ 中存在 φ(n/d)\\varphi(n/d)φ(n/d) 个正整数。所以我们可以把这 nnn 个数分为互不相交的类。因此 n=∑d∣nφ(n/d)n=\\sum_{d\\mid n}\\varphi(n/d)n=∑d∣n​φ(n/d) 。 因为 ddd 取遍所有整除 nnn 的正整数， n/dn/dn/d 也取遍 nnn 的所有正因子，所以 n=∑d∣nφ(n/d)=∑d∣nφ(d)n=\\sum_{d\\mid n}\\varphi(n/d)=\\sum_{d\\mid n}\\varphi(d)n=∑d∣n​φ(n/d)=∑d∣n​φ(d) 。 欧拉函数的一些性质 性质 1：∀n, n&gt;1\\forall n,\\ n&gt;1∀n, n&gt;1 ，1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 中与 nnn 互质的数的和为 n×φ(n)2n\\times \\dfrac{\\varphi(n)}{2}n×2φ(n)​ 。 性质 2：设 ppp 是 nnn 的因数（无论是质数或素数），若 p∣np\\mid np∣n 且 p2∣np^2\\mid np2∣n ，则 φ(n)=φ(n/p)×p\\varphi(n)=\\varphi(n/p)\\times pφ(n)=φ(n/p)×p 。（因为 p, n/pp,\\ n/pp, n/p 不互质且 nnn 和 n/pn/pn/p 的质因子集合相同） 性质 3：设 ppp 是 nnn 的质因数，若 p∣p\\midp∣ 且 p2∤np^2\\nmid np2∤n ，则 φ(n)=φ(n/p)×φ(p)\\varphi(n)=\\varphi(n/p)\\times \\varphi(p)φ(n)=φ(n/p)×φ(p) 。（因为 p, n/pp,\\ n/pp, n/p 互质，若 ppp 为合数，则 p, n/pp,\\ n/pp, n/p 是否互质不确定） 性质 4：若 i, ji,\\ ji, j 不互质，则 φ(i×j)=φ(i)φ(j)gcd⁡(i, j)φ(gcd⁡(i, j))\\varphi(i\\times j)=\\dfrac{\\varphi(i)\\varphi(j)\\gcd(i,\\ j)}{\\varphi(\\gcd(i,\\ j))}φ(i×j)=φ(gcd(i, j))φ(i)φ(j)gcd(i, j)​ 。 一个关于欧拉函数的方程 设 kkk 是一个给定的正整数，求满足 φ(n)=k\\varphi(n)=kφ(n)=k 的所有正整数 nnn 的解的一个有用的方法就是给出满足方程 φ(n)=∏i=1kpiai−1(pi−1)\\varphi(n)=\\displaystyle\\prod_{i=1}^{k}p^{a_i-1}_{i}(p_i-1)φ(n)=i=1∏k​piai​−1​(pi​−1) 的所有整数解 nnn ，其中 nnn 的素幂因子分解为 n=∏i=1kpiain=\\displaystyle\\prod_{i=1}^{k}p_i^{a_i}n=i=1∏k​piai​​ 。 狄利克雷卷积 定义：两个算术函数 f, gf,\\ gf, g 可以用狄利克雷卷积，定义为 (f∗g)(n)=∑d∣nf(d)g(n/d)(f*g)(n)=\\sum_{d\\mid n}f(d)g(n/d)(f∗g)(n)=∑d∣n​f(d)g(n/d) 。或 (f∗g)(n)=∑ab=nf(a)g(b)(f*g)(n)=\\sum_{ab=n}f(a)g(b)(f∗g)(n)=∑ab=n​f(a)g(b) 。 证明：f∗g=g∗ff*g=g*ff∗g=g∗f 。 证明：(f∗g)∗h=f∗(g∗h)(f*g)*h=f*(g*h)(f∗g)∗h=f∗(g∗h) 。 我们定义 ε\\varepsilonε 函数 ε={1if n=10if n&gt;1\\varepsilon = \\begin{cases} 1 &amp;\\text{if }\\ n=1 \\\\ 0 &amp;\\text{if }\\ n&gt;1 \\end{cases} ε={10​if n=1if n&gt;1​ 证明： ε\\varepsilonε 是乘性函数。 证明：对任意算术函数 fff 有 ε∗f=f∗ε=f\\varepsilon * f=f*\\varepsilon=fε∗f=f∗ε=f 。 算术函数 ggg 称为算术函数 fff 的逆函数，如果满足 f∗g=g∗f=εf*g=g*f=\\varepsilonf∗g=g∗f=ε 。证明算术函数 fff 可逆当且仅当 f(1)≠0f(1)\\ne 0f(1)=0 。证明：如果 fff 可逆，则逆函数是唯一的。 证明：如果 f, gf,\\ gf, g 是乘性函数，那么狄利克雷积 f∗gf*gf∗g 也是乘性函数。 7.2 因子和 与 因子个数 定义：因子和函数 σ\\sigmaσ 定义为整数 nnn 的所有正因子之和，记为 σ(n)\\sigma(n)σ(n) 。 定义：因子个数函数 τ\\tauτ 定义为正整数 nnn 的所有正因子个数，记为 τ(n)\\tau(n)τ(n) 。 用和式表示即为 σ(n)=∑d∣nd\\sigma(n)=\\displaystyle \\sum_{d\\mid n}dσ(n)=d∣n∑​d ， τ(n)=∑d∣n1\\tau(n)=\\displaystyle \\sum_{d\\mid n}1τ(n)=d∣n∑​1 。 定理 7.8 和函数也是积性函数 定理 7.8：如果 fff 是乘性函数，那么 fff 的和函数，即 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) 也是乘性函数。 证明：为了证明 FFF 是一个乘性函数，我们必须证明如果 m, nm,\\ nm, n 是互素的正整数，那么 F(mn)=F(m)F(n)F(mn)=F(m)F(n)F(mn)=F(m)F(n) 。所以首先假设 (m, n)=1(m,\\ n)=1(m, n)=1 ，有 F(mn)=∑d∣mnf(d)F(mn)=\\sum_{d\\mid mn}f(d)F(mn)=∑d∣mn​f(d) 。 由引理 3.7，因为 (m, n)=1(m,\\ n)=1(m, n)=1 ，故每个 mnmnmn 的因子可以唯一地写成 mmm 的因子 d1d_1d1​ 和 nnn 的因子 d2d_2d2​ 之积，并且这两个因子互素，即 d=d1d2d=d_1d_2d=d1​d2​ ，所以有 F(mn)=∑d1∣m, d2∣nf(d1d2)F(mn)=\\sum_{d_1\\mid m,\\ d_2\\mid n}f(d_1d_2)F(mn)=∑d1​∣m, d2​∣n​f(d1​d2​) 。 因为 fff 是乘性的，且 (d1, d2)=1(d_1,\\ d_2)=1(d1​, d2​)=1 ，故（mnmnmn 的因子个数 = mmm 的因子个数 ×\\times× nnn 的因子个数） F(mn)=∑d1∣m,d2∣nf(d1)f(d2)=∑d1∣mf(d1)∑d2∣nf(d2)=F(m)F(n)\\begin{align*} F(mn)&amp;=\\sum_{d_1\\mid m,\\\\ d_2\\mid n}f(d_1)f(d_2)\\\\ &amp;=\\sum_{d_1\\mid m}f(d_1)\\sum_{d_2\\mid n}f(d_2)\\\\ &amp;=F(m)F(n) \\end{align*} F(mn)​=d1​∣m,d2​∣n∑​f(d1​)f(d2​)=d1​∣m∑​f(d1​)d2​∣n∑​f(d2​)=F(m)F(n)​ 引理 7.1 当 n 为一个素数的幂时 定理 7.9 因子和、因子个数函数的计算 7.3 完全数和梅森素数 7.4 莫比乌斯反演 定义：莫比乌斯函数 μ(n)\\mu(n)μ(n) 定义为 μ(n)={1n=1 0n 含有平方因子(−1)kk 为 n 的本质不同质因子个数 \\qquad\\qquad\\qquad \\mu(n)= \\begin{cases} 1 &amp; n=1\\ \\\\ 0 &amp; n\\text{ 含有平方因子}\\\\ (-1)^k &amp; k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\ \\end{cases}μ(n)=⎩⎨⎧​10(−1)k​n=1 n 含有平方因子k 为 n 的本质不同质因子个数 ​ 定理 7.14 莫比乌斯函数是乘性函数 定理 7.15 莫比乌斯函数的和函数 定理 7.15：莫比乌斯函数的和函数在整数 nnn 处的值 F(n)=∑d∣nμ(d)F(n)=\\sum_{d\\mid n}\\mu(d)F(n)=∑d∣n​μ(d) ，满足 ∑d∣nμ(n)={1 如果 n=1 0 如果 n&gt;1\\qquad\\qquad\\qquad \\sum_{d\\mid n}\\mu(n)= \\begin{cases} 1 &amp; \\text{ 如果 }\\ \\ n=1\\ \\\\ 0 &amp; \\text{ 如果 }\\ \\ n&gt;1\\\\ \\end{cases}∑d∣n​μ(n)={10​ 如果 n=1 如果 n&gt;1​ 证明：当 n=1n=1n=1 时，显然。 当 n&gt;1n&gt;1n&gt;1 ， 定理 7.16 莫比乌斯反演公式 定理 7.16：若 fff 是算术函数，FFF 为 fff 的和函数，即对任意正整数 nnn 满足 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) ，则对任意正整数 nnn ， f(n)=∑d∣nμ(d)F(n/d)f(n)=\\sum_{d\\mid n}\\mu(d)F(n/d)f(n)=∑d∣n​μ(d)F(n/d) 。 证明： 莫比乌斯反演公式可以用来构造许多新的等式，这些等式用别的方法是很难证明的。 定理 7.17 定理 7.17：设 fff 是算术函数，它的和函数为 F(n)=∑d∣nf(n)F(n)=\\sum_{d\\mid n}f(n)F(n)=∑d∣n​f(n) 。那么如果 FFF 是乘性函数，则 fff 也是乘性函数。 证明： 7.5 拆分","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P1516 青蛙的约会","slug":"题解/数论/整除/欧几里得算法/青蛙的约会","date":"2021-10-22T16:00:00.000Z","updated":"2021-11-26T06:45:07.127Z","comments":true,"path":"posts/f9b72c1e/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f9b72c1e/","excerpt":"","text":"原题链接：P1516 青蛙的约会 步骤 由 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 得到 ax−my=bax-my=bax−my=b 。最终得到 ad(x−x0)=md(y−y0)\\dfrac{a}{d}(x-x_0)=\\dfrac{m}{d}(y-y_0)da​(x−x0​)=dm​(y−y0​) 。 求 gcd(a, m) 时，a,ma, ma,m 的正负影响 gcd 的正负，但 gcd 的正负不影响 有无整数解的判断。 再得 x=x0+mdnx=x_0+\\dfrac{m}{d}nx=x0​+dm​n ， y=y0+adny=y_0+\\dfrac{a}{d}ny=y0​+da​n 。 遇到的问题 Q：为什么 exgcd((m - n), -L, x, y); 和 exgcd((m - n), L, x, y); 都能 AC？ A：经测试，①m-n 取正，L 为正或负，②m-n 取负，L 为正或负，得到的最大公因子符号相反，x 的符号也相反。所以 x *= (b - a) / d; 这一步得到的 xxx 的值相同。即两种写法均可得到 ax−my=bax-my=bax−my=b 的一个正确特解。且 gcd, x 的正负对后续步骤无影响。 Q：为什么必须使 md\\dfrac{m}{d}dm​ 为正？ A ：若 md\\dfrac{m}{d}dm​ 为负，则 (x0 % md+md) % md(x_0\\ \\%\\ \\dfrac{m}{d}+\\dfrac{m}{d})\\ \\%\\ \\dfrac{m}{d}(x0​ % dm​+dm​) % dm​ 可能得到负数结果。稍作改动： x=x0+(−md)(−n)x=x_0+(-\\dfrac{m}{d})(-n)x=x0​+(−dm​)(−n) ，则 (x0 % md+md) % md(x_0\\ \\%\\ \\dfrac{m}{d}+\\dfrac{m}{d})\\ \\%\\ \\dfrac{m}{d}(x0​ % dm​+dm​) % dm​ 必得到最小非负解。 代码 #include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int a, b, m, n, L, x, y;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) return x = 1, y = 0, a; int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d;&#125;signed main() &#123; // a, b:青蛙A B的起始位置; m, n:青蛙A B一次跳的距离; L:圆的周长 scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;a, &amp;b, &amp;m, &amp;n, &amp;L); int d = exgcd((m - n), -L, x, y); if ((b - a) % d) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; &#125; else &#123; x *= (b - a) / d; int t = abs(L / d); cout &lt;&lt; (x % t + t) % t &lt;&lt; endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P2257 YY的GCD","slug":"题解/数论/积性函数到杜教筛/莫比乌斯反演/P2257 YY的GCD","date":"2021-10-22T16:00:00.000Z","updated":"2021-11-26T06:45:07.125Z","comments":true,"path":"posts/e9bccd7d/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e9bccd7d/","excerpt":"","text":"题目 P2257 YY的GCD 。 循环处理最后的 T=p×dT=p\\times dT=p×d ：P2257 YY的GCD 。（利用质因子分解、莫比乌斯函数的性质即可推出博客中的结论） 线性筛 T=p×dT=p\\times dT=p×d ：P2568 GCD 。","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"第五章 同余的应用","slug":"读书笔记/初等数论及其应用/第五章 同余的应用","date":"2021-10-15T16:00:00.000Z","updated":"2021-11-25T10:39:14.902Z","comments":true,"path":"posts/dce3ec70/","link":"","permalink":"http://xiaoke-jin.github.io/posts/dce3ec70/","excerpt":"","text":"概要 本章广泛涉及了同余的各种类型的有趣应用。 首先，我们将指出如何利用同余进行整除性检验。 然后会推导出一个可以确定历史上任何一天的星期数的同余式。 利用同余编排循环赛赛程。 我们也将讨论同余性质在计算机科学中的一些应用，比如：应用在散列函数上，确定数据存储位置的计算机存储地址。 最后，我们将给出如何利用同余构造校验位。 5.1 整除性检验 在小学大家都学过检验一个整数是否能被 3 整除，只需检验该整数各位数相加之和能否被 3 整除就可以了。这是一个整除性检验的例子，它应用了一个整数的各位数字去检验这个数是否能被一个特定的除数整除，而不是用这个可能的除数直接去除那个整数。在本节中，我们将基于这样的检验给出有关的理论。特别地，将利用同余给出基于 bbb 进制展开的整数的整除性检验，其中 bbb 是一个正整数。取 b=10b=10b=10 即得到著名的用来检验整数能否被 2，3，4，5，7，9，11 和 13 等整除的检验。可能你在很久以前就学过这些整除性检验， 在这里你会明白为什么要那样做。 被 2 的幂整除的检验 被 5 的幂整除的检验 被 3 和 9 整除的检验 被 11 整除的检验 被 7，11，13 整除的检验 基于 b 进制表示的整除性检验 5.2 万年历 5.3 循环赛赛程 5.4 散列函数 5.5 校验位","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"第六章 特殊的同余式","slug":"读书笔记/初等数论及其应用/第六章 特殊的同余式","date":"2021-10-15T16:00:00.000Z","updated":"2021-11-25T10:39:14.904Z","comments":true,"path":"posts/d8e76a98/","link":"","permalink":"http://xiaoke-jin.github.io/posts/d8e76a98/","excerpt":"","text":"概要 在本章中，我们将讨论三个在理论和应用中都很重要的同余式： 威尔逊定理（Wilson’s Theorem）证明了若 ppp 是素数，则 ppp 除 (p−1)!(p-1)!(p−1)! 的余数是 −1-1−1。 费马小定理（Fermat’s Little Theorem）给出了一个整数的 ppp 次幂模 ppp 的同余式。特别地，若 ppp 是素数，aaa 是一个整数， 那么 apa^pap 和 aaa 被 ppp 除有相同的余数。 欧拉定理则将费马小定理推广到模不是素数的情形。 这三个同余式有很广泛的应用。例如，我们将解释费马小定理作为基础理论在素性检验和因子分解方面的应用，还要讨论一类称作 伪素数 的合数，这类合数满足像素数在费马小定理中满足的同余式一样的式子。利用伪素数极其稀少的事实还可以导出一种检验法，它可以提供一个几乎不可抗拒的证据来证明一个整数是素数。 6.1 威尔逊定理与费马小定理 定理 6.1 威尔逊定理 定理 6.1（威尔逊定理）：若 ppp 是素数，则 (p−1)!≡−1( mod p)(p-1)!\\equiv -1(\\bmod p)(p−1)!≡−1(modp) 。 证明： 费马小定理 定理 6.3 费马小定理 定理 6.3：设 ppp 是一个素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，则 ap−1≡1( mod p)a^{p-1}\\equiv 1(\\bmod\\ p)ap−1≡1(mod p) 。 定理 6.4 定理 6.4：设 ppp 是一个素数且 aaa 是一个正整数，则 ap≡a( mod p)a^p\\equiv a(\\bmod\\ p)ap≡a(mod p) 。 定理 6.5 费马小定理求乘法逆元 定理 6.5：若 ppp 是素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，那么 ap−2a^{p-2}ap−2 是 aaa 模 ppp 的逆。 证明：若 ，则由费马小定理知， a×ap−2=ap−1≡1( mod p)a\\times a^{p-2}=a^{p-1}\\equiv 1(\\bmod\\ p)a×ap−2=ap−1≡1(mod p) 。因此， ap−2a^{p-2}ap−2 是 aaa 模 ppp 的逆。 6.2 伪素数 6.3 欧拉定理 定义：设 nnn 是一个正整数，欧拉函数 φ(n)\\varphi(n)φ(n) 定义为不超过 nnn 且与 nnn 互素的正整数的个数。 定义：模 nnn 的既约剩余系 是由 φ(n)\\varphi(n)φ(n) 个整数构成的集合，集合中的每个元素均与 nnn 互素，且任何两个元素模 nnn 不同余。 定理 6.13 下面是一个关于既约剩余系的定理。 定理 6.13：设 r1,r2,⋯ ,rφ(n)r_1,r_2,\\cdots,r_{\\varphi(n)}r1​,r2​,⋯,rφ(n)​ 是模 nnn 的一个既约剩余系，若 aaa 是一个正整数且 (a, n)=1(a,\\ n)=1(a, n)=1 ，那么集合 ar1,ar2,⋯ ,arφ(n)ar_1,ar_2,\\cdots,ar_{\\varphi(n)}ar1​,ar2​,⋯,arφ(n)​ 也是模 nnn 的一个既约剩余系。 证明： 定理 6.14 欧拉定理 定理 6.14（欧拉定理）：设 mmm 是一个正整数， aaa 是一个整数且 (a, m)=1(a,\\ m)=1(a, m)=1 ，那么 aφ(m)≡1 ( mod m)a^{\\varphi(m)}\\equiv 1\\ (\\bmod\\ m)aφ(m)≡1 (mod m) 。 证明：令 r1,r2,⋯ ,rφ(m)r_1,r_2,\\cdots,r_{\\varphi(m)}r1​,r2​,⋯,rφ(m)​ 是由不超过 mmm 且和 mmm 互素的元素组成的既约剩余系。由定理 6.13 ，因 (a, n)=1(a,\\ n)=1(a, n)=1 ，故集合 ar1,ar2,⋯ ,arφ(m)ar_1,ar_2,\\cdots,ar_{\\varphi(m)}ar1​,ar2​,⋯,arφ(m)​ 也是模 mmm 的一个既约剩余系。从而，在一定的顺序下 ar1,ar2,⋯ ,arφ(m)ar_1,ar_2,\\cdots,ar_{\\varphi(m)}ar1​,ar2​,⋯,arφ(m)​ 的最小正剩余一定是 r1,r2,⋯ ,rφ(m)r_1,r_2,\\cdots,r_{\\varphi(m)}r1​,r2​,⋯,rφ(m)​ 。因此，若把每个既约剩余系中的所有项乘起来，可得 ar1ar2⋯arφ(m)≡r1r2⋯rφ(m) ( mod m)ar_1ar_2\\cdots ar_{\\varphi(m)}\\equiv r_1r_2\\cdots r_{\\varphi(m)}\\ (\\bmod\\ m)ar1​ar2​⋯arφ(m)​≡r1​r2​⋯rφ(m)​ (mod m) 。 因而 aφ(m)r1r2⋯rφ(m)≡r1r2⋯rφ(m) ( mod m)a^{\\varphi(m)}r_1r_2\\cdots r_{\\varphi(m)}\\equiv r_1r_2\\cdots r_{\\varphi(m)}\\ (\\bmod\\ m)aφ(m)r1​r2​⋯rφ(m)​≡r1​r2​⋯rφ(m)​ (mod m) ，因为 (r1r2⋯rφ(m), m)=1(r_1r_2\\cdots r_{\\varphi(m)},\\ m)=1(r1​r2​⋯rφ(m)​, m)=1 ，故由推论 4.5.1知， aφ(m)≡1 ( mod m)a^{\\varphi(m)}\\equiv 1\\ (\\bmod\\ m)aφ(m)≡1 (mod m) 。 欧拉定理求乘法逆元 可以利用欧拉定理来求模 mmm 的逆。若 aaa 和 mmm 互素，则 a×aφ(m)−1=aφ(m)≡1 ( mod m)a\\times a^{\\varphi(m)-1}=a^{\\varphi(m)}\\equiv 1\\ (\\bmod\\ m)a×aφ(m)−1=aφ(m)≡1 (mod m) 。因此， aφ(m)−1a^{\\varphi(m)-1}aφ(m)−1 是 aaa 模 mmm 的逆。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"中国剩余定理","slug":"DS_Algorithm证明与讲解/数学/数论/同余/中国剩余定理","date":"2021-10-14T16:00:00.000Z","updated":"2022-02-18T14:32:06.261Z","comments":true,"path":"posts/2cf738e6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/2cf738e6/","excerpt":"","text":"前置芝士：乘法逆元 干货｜中国剩余定理 &amp; 扩展中国剩余定理 中国剩余定理 设 m1,m2,⋯ ,mkm_1, m_2, \\cdots, m_km1​,m2​,⋯,mk​ 两两互质，则同余方程组 {x≡a1(modm1)x≡a2(modm2)⋮x≡ak(modmk)\\begin{cases} x &amp;\\equiv a_1 \\pmod {m_1} \\\\ x &amp;\\equiv a_2 \\pmod {m_2} \\\\ &amp;\\vdots \\\\ x &amp;\\equiv a_k \\pmod {m_k} \\\\ \\end{cases} ⎩⎨⎧​xxx​≡a1​(modm1​)≡a2​(modm2​)⋮≡ak​(modmk​)​ 有模 M=m1m2⋯mkM=m_1m_2\\cdots m_kM=m1​m2​⋯mk​ 的唯一解。（即该方程组所有解模 MMM 同余） 证明：详细过程后续再补 解为 x≡∑i=1kaiMiMi−1( mod M)x\\equiv \\sum_{i=1}^k a_iM_iM_i^{-1}(\\bmod M)x≡∑i=1k​ai​Mi​Mi−1​(modM) 。Mi=M/miM_i=M/m_iMi​=M/mi​ ，Mi−1M_i^{-1}Mi−1​ 为 MiM_iMi​ 的逆元。 Garner算法 CRT 的另一个用途是用一组比较小的质数表示一个大的整数。 扩展：模数不互质的情况 扩展CRT 阮行止 两个方程 \\qquad设两个方程分别是 x≡a1(modm1)x\\equiv a_1 \\pmod {m_1}x≡a1​(modm1​)、x≡a2(modm2)x\\equiv a_2 \\pmod {m_2}x≡a2​(modm2​)； 将它们转化为不定方程：x=m1p+a1=m2q+a2x=m_1p+a_1=m_2q+a_2x=m1​p+a1​=m2​q+a2​，其中 p,qp, qp,q 是整数，则有 m1p−m2q=a2−a1m_1p-m_2q=a_2-a_1m1​p−m2​q=a2​−a1​。 由裴蜀定理，当 (m1,m2)∤(a2−a1)(m_1,m_2)\\nmid (a_2-a_1)(m1​,m2​)∤(a2​−a1​) 时，无解； 其他情况下，可以通过扩展欧几里得算法解出来一组可行解 (p,q)(p, q)(p,q) ； 则原来的两方程组成的模方程组的解为 x≡b(modM)x\\equiv b\\pmod Mx≡b(modM)，其中 b=m1p+a1b=m_1p+a_1b=m1​p+a1​，M=lcm(m1,m2)M=\\text{lcm}(m_1, m_2)M=lcm(m1​,m2​)。 多个方程 用上面的方法两两合并即可。 题目 P1495 【模板】中国剩余定理(CRT)/曹冲养猪","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P1072 Hankson 的趣味题","slug":"题解/数论/整除/欧几里得算法/P1072 Hankson 的趣味题","date":"2021-10-06T16:00:00.000Z","updated":"2021-11-26T08:45:00.794Z","comments":true,"path":"posts/b6c0adcd/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b6c0adcd/","excerpt":"","text":"题目链接：[NOIP2009 提高组] Hankson 的趣味题 思路 暴力 首先，我们知道这两个等式：(a0,x)=a1,[b0,x]=b1(a0,x)=a1,[b0,x]=b1 于是，我们可以设：x=a1p,b1=xtx=a1∗p,b1=x∗t 于是有：a1pt=b1a1∗p∗t=b1 所以我们令：b1/a1=sb1/a1=s 则：pt=sp∗t*=s 即：t=s/pt=s/p 又由最大公约数与最小公倍数的定义与性质可得： (a0/a1,p)=1,(b1/b0,t)=1(a0/a1,p)=1,(b1/b0,t)=1 所以我们令：a0/a1=m,b1/b0=na0/a1=m,b1/b0=n 则有：(p,m)=1,(s/p,n)=1(p,m)=1,(s/p,n)=1 这就是第一个结论，我们称其为结论一。事实上，我们其实已经可以由结论一整理出可以AC的方法，即用sqrt(s)的复杂度枚举s的因数，然后将每个因数放到结论一中，看看是否成立，再统计所有符合结论一的因数的个数，然后输出即可。这种算法的复杂度是：O(sqrt(s)*log(s)*n)。这样其实也能卡过数据，但是还是没有达到理论上的通过。所以我们还要继续优化。 进一步优化 我们考虑(s/p,n)=1。如果s/p与n有相同质因数，则意思那个无法使(s/p,n)=1成立。于是，我们可以将s与n所有相同的质因数从s中去掉，得到剩余的数l（这一点还是很需要技巧的，在程序中会有解析）。于是，s/p就必须是l的约数。 我们继续考虑(p,m)=1。因为s/p是l的约数，那么p就一定可以表示为这样的形式： p=(s/l)rp*=(s/l)∗r 即：p一定是s/l的倍数（因为s/p是l的约数）。而r也必须是l的约数。于是就又有： r|l,(r,m)=1r∣l,(r,m)=1 这就是第二个结论，我们称其为结论二。而解决结论二的方法便很明显了。我们可以用与解决结论一相似的方法，将l与m所有相同的质因数从l中去掉，得到剩余的数q。那么这样，所有符合条件的r都是q的因数了。然后，我们可以用sqrt(q)的复杂度枚举q的所有因数，输出q的因数个数就行了。这样，复杂度便降到了：O((sqrt(s)+log(s))*n)，从理论来说也不会超时了。 还有一点需要注意，那就是特判没有符合要求的x的情况。这种情况出现只有四种可能： ###1、s不为整数 ###2、m不为整数 ###3、n不为整数 ###4、(s/l,m)≠1，即因为p是s/l的倍数，所以无论r取何值，都会有(p,m)≠1 加上这四个特判，这道题便做完了。 暴力代码 // 337ms https://www.luogu.com.cn/record/60566847#include &lt;bits/stdc++.h&gt;using namespace std;// #define int long long // 若开long long(917ms)：https://www.luogu.com.cn/record/60517389const int N = 1e6 + 233;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125;int a[N];signed main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) // 2000 &#123; int a0, a1, b0, b1; scanf(&quot;%d %d %d %d&quot;, &amp;a0, &amp;a1, &amp;b0, &amp;b1); if (b1 % a1) printf(&quot;0\\n&quot;); else &#123; int cnt = 0, ans = 0, x = b1 / a1; for (int i = 1; i * i &lt;= x; i++) // 写成除法(579ms)：https://www.luogu.com.cn/record/60566591 &#123; // 求约数 if (x % i == 0) &#123; a[++cnt] = i; if (x != i * i) a[++cnt] = x / i; &#125; &#125; // printf(&quot;cnt = %d\\n&quot;, cnt); for (int i = 1; i &lt;= cnt; i++) &#123; x = a[i] * a1; if (gcd(x, a0) == a1 &amp;&amp; x / gcd(x, b0) * b0 == b1) ans++; &#125; printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; 优化代码 // 179ms https://www.luogu.com.cn/record/60530753#include &lt;bits/stdc++.h&gt;using namespace std;int a0, a1, b0, b1;int m, s, l;int T;int Div(int a, int b)&#123; //去掉a中与b共有的质因数 int x = sqrt(b); for (int i = 2; i &lt;= x; i++) &#123; if (b % i == 0) while (a % i == 0) a /= i; while (b % i == 0) b /= i; &#125; if (b &gt; 1) while (a % b == 0) a /= b; return a;&#125;int gcd(int a, int b) &#123; return b ? gcd(b, a % b): a; &#125;signed main()&#123; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d %d %d %d&quot;, &amp;a0, &amp;a1, &amp;b0, &amp;b1); if (b1 % a1) &#123; printf(&quot;0\\n&quot;); continue; &#125; m = a0 / a1, s = b1 / a1; l = Div(s, b1 / b0); //求出m、s，然后求出l if (gcd(max(s / l, m), min(s / l, m)) != 1) &#123; printf(&quot;0\\n&quot;); continue; &#125; int q = Div(l, m); int cnt = 0, t = sqrt(q); //求出q，开始枚举q的因数，求出q的因数个数 for (int i = 1; i &lt;= t; i++) if (q % i == 0) cnt += (i == q / i) ? 1 : 2; //这里注意，如果i==q/i，则只加1，否则加2 printf(&quot;%d\\n&quot;, cnt); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"一些优秀的算法博客","slug":"算法竞赛相关优秀博客/各类算法讲解博客","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-21T13:09:33.806Z","comments":true,"path":"posts/60227358/","link":"","permalink":"http://xiaoke-jin.github.io/posts/60227358/","excerpt":"","text":"洛谷日报 洛谷日报 ，都很优秀。 DP 背包儿戏系列概述 - walker shi的文章 动态规划并没有想象中那么难 - walker shi的文章 什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止 数据结构 如何更好地理解和掌握 KMP 算法? - 阮行止的回答 洛谷日报 #35 线段树的扩展之浅谈zkw线段树 数论 整除 同余 积性函数 杂项 ACM比赛常用技巧","categories":[{"name":"优秀博客","slug":"优秀博客","permalink":"http://xiaoke-jin.github.io/categories/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2/"}],"tags":[]},{"title":"罗永军老师的算法博客","slug":"算法竞赛相关优秀博客/罗永军_专题解析","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-13T06:57:55.077Z","comments":true,"path":"posts/5ff535cb/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5ff535cb/","excerpt":"","text":"算法竞赛专题解析（0）：写作计划 算法竞赛专题解析（1）：二分法、三分法 算法竞赛专题解析（2）：尺取法（双指针） 算法竞赛专题解析（3）：并查集 算法竞赛专题解析（4）：杜教筛–以及积性函数的前世今生 算法竞赛专题解析（5）：简单数据结构 算法竞赛专题解析（6）：搜索进阶(1)–搜索基础 算法竞赛专题解析（7）：搜索进阶(2)–剪枝 算法竞赛专题解析（8）：搜索进阶(3)–广搜进阶 算法竞赛专题解析（9）：搜索进阶(4)–A*搜索 算法竞赛专题解析（10）：DP优化(1)–四边形不等式 算法竞赛专题解析（11）：DP概述和常见DP面试题 算法竞赛专题解析（12）：DP优化(2)–斜率(凸壳)优化 算法竞赛专题解析（13）：DP优化(3)–单调队列优化 算法竞赛专题解析（14）：DP应用–区间DP 算法竞赛专题解析（15）：DP应用–状态压缩DP 算法竞赛专题解析（16）：附A-测试数据的构造与对拍 算法竞赛专题解析（17）：DP应用–树形DP 算法竞赛专题解析（18）：数论–素数的判定 算法竞赛专题解析（19）：数论–质因数分解 算法竞赛专题解析（20）：数论–GCD和LCM 算法竞赛专题解析（21）：数论–线性丢番图方程 算法竞赛专题解析（22）：数论–同余 算法竞赛专题解析（23）：树状数组 算法竞赛专题解析（24）：线段树 算法竞赛专题解析（25）：分块 算法竞赛专题解析（26）：莫队算法 算法竞赛专题解析（28）：倍增与ST算法 算法竞赛专题解析（29）：LCA 算法竞赛专题解析（30）：树链剖分 算法竞赛专题精解（31）：Python在竞赛中的应用-测试数据的构造与对拍 算法竞赛专题解析（32）：差分","categories":[{"name":"优秀博客","slug":"优秀博客","permalink":"http://xiaoke-jin.github.io/categories/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2/"}],"tags":[]},{"title":"XCPC算法学习指南","slug":"题目/算法学习指南","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-16T07:23:59.205Z","comments":true,"path":"posts/e8b04cb/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e8b04cb/","excerpt":"","text":"dls、wls整理的 XCPC 知识树 图片 入门 ACM 的正确入门方式是什么？ ACM 的正确入门方式是什么？ - 匿名用户1的回答 ⭐ ACM 的正确入门方式是什么？ - 匿名用户2的回答 大一学生如何系统学习算法，以备ACM竞赛？ - 制糕神的算法工坊的回答 参加ICPC国际编程竞赛的大学生到底有多厉害，在校生该如何准备？ - whzzt的回答 该刷题了 刷题网站：ACWing、洛谷、Codeforces、VJudge 大一试水acm如果5个月0基础全身心投入大概能打到codeforces多少分? - linrany的回答 【洛谷日报#19】Codeforces游玩攻略 - ezoixx130的文章","categories":[{"name":"优秀博客","slug":"优秀博客","permalink":"http://xiaoke-jin.github.io/categories/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2/"}],"tags":[]},{"title":"FHQ Treap 学习笔记","slug":"DS_Algorithm证明与讲解/数据结构/FHQ Treap","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-18T13:47:34.122Z","comments":true,"path":"posts/ee6be228/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ee6be228/","excerpt":"","text":"我可能学了假的 FHQ Treap 算法｜学习笔记：史上最简单的平衡树——无旋Treap","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"DSU on tree","slug":"DS_Algorithm证明与讲解/数据结构/DSU on tree","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-15T06:20:32.369Z","comments":true,"path":"posts/863d7c47/","link":"","permalink":"http://xiaoke-jin.github.io/posts/863d7c47/","excerpt":"","text":"自为风月马前卒 dsu on tree入门","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"前缀和与差分","slug":"DS_Algorithm证明与讲解/数据结构/前缀和与差分","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-05T14:28:27.357Z","comments":true,"path":"posts/77a88a6b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/77a88a6b/","excerpt":"","text":"高维前缀和总结 数据结构专题班：1 前缀和与差分 abcdefgh IJ 基础前缀和 前缀和、前缀积 前缀积：https://ac.nowcoder.com/acm/contest/19483/A 广义前缀和：连续的进行若干次操作，产生一个叠加影响，如果这种影响可以通过某种反向操作“撤销”。 前缀置换 前缀置换：https://ac.nowcoder.com/acm/contest/19483/F 前缀矩阵积 前缀矩阵积：https://ac.nowcoder.com/acm/contest/19483/E 前缀和与差分 区间加一个数、等差数列、平方数列 https://ac.nowcoder.com/acm/contest/19483/H 区间加多项式 数学定理：最高次项为 n 次的 n 阶多项式做 n+1 阶差分后余项为常数。 如何利用这个定理，使我们的前缀和可以做区间加多项式？ https://ac.nowcoder.com/acm/contest/19483/D 高阶前缀和 对于数组a，定义a数组的前缀和为一阶前缀和，定义 a 数组前缀和的前缀和为二阶前缀和。 https://ac.nowcoder.com/acm/contest/19483/C 二维前缀和 高维前缀和（SOSDP） Sum over Subsets ，又被叫做子集前缀和。 https://ac.nowcoder.com/acm/contest/19483/B","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"并查集学习笔记","slug":"DS_Algorithm证明与讲解/数据结构/并查集","date":"2021-10-01T16:00:00.000Z","updated":"2022-03-29T13:09:31.928Z","comments":true,"path":"posts/7c95cc13/","link":"","permalink":"http://xiaoke-jin.github.io/posts/7c95cc13/","excerpt":"","text":"基本并查集 int p[N];// p[x] == x的父结点void init()&#123; for(int i = 0; i &lt; n; i++) p[i] = i;&#125;int find(int x)&#123; return x == p[x] ? p[x] : p[x] = find(p[x]); // 路径压缩&#125;void merge(int a, int b)&#123; p[find(a)] = p[find(b)];&#125; 扩展域并查集 带权并查集 并查集应用 维护 size int sz[N]; // 集合的大小 == size[根结点]，size[子结点]无意义void init()&#123; for(int i = 0; i &lt; n; i++) p[i] = i, size[i] = 1;&#125;void merge(int a, int b)&#123; int x = find(a), y = find(b); if(x == y) return ; p[x] = p[y]; sz[b] += sz[a];&#125; 维护到根节点距离 int p[N], d[N];int find(int x)&#123; if(x != p[x]) &#123; int u = find(p[x]); d[x] += d[u]; p[x] = u; &#125; return p[x];&#125; 题目 基础操作：查询，合并 洛谷 P3367 【模板】并查集 AcWing 1250. 格子游戏 洛谷 P1455 搭配购买 洛谷 P1955 程序自动分析 边带权 和 扩展域 洛谷 P2024 食物链 普通做法：扩展域 带权并查集的做法：AcWing 240. 食物链(带权并查集) 洛谷 P5937 [CEOI1999]Parity Game：注意与 洛谷 P1955 程序自动分析 的区别；是 洛谷 P2024 食物链 简化版 洛谷 P1196 [NOI2002] 银河英雄传说","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线段树学习笔记","slug":"DS_Algorithm证明与讲解/数据结构/线段树","date":"2021-10-01T16:00:00.000Z","updated":"2022-03-11T05:55:31.959Z","comments":true,"path":"posts/c8da5f65/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c8da5f65/","excerpt":"","text":"视频：noip线段树与树状数组 罗勇军的博客：算法竞赛专题解析（24）：线段树 yyb的博客：线段树 by yyb 、线段树补充的题目 、https://www.cnblogs.com/cjyyb/category/1036559.html kuangbin线段树专题 逍遥Fau 的线段树 面向对象设计线段树 清晰的思路使得代码写的更顺畅，DEBUG 更方便。 当然，不需要把每一部分都写成函数，但脑子里要结构清晰。 第一部分 处理lazyTag union_lazy 的实现与区间修改的类型有关，与维护的值的形式无关。 四个函数 init_lazy ：初始化标记 cal_lazy ：计算标记对当前结点表示的区间的影响 union_lazy ：标记下传时与子结点标记的合并 push_down ：标记下传：先 cal_lazy 再对左右子结点 union_lazy ，最后 init_lazy 第二部分 区间合并 需要考虑两个区间如何合并：加、乘、矩阵乘。。。等等。 根据合并的复杂程度，可以考虑是否要重载下 + 运算符。 update ：用子结点更新当前结点。先对左右子结点 push_down ，再更新当前结点 第三部分 愉快的调用 这是对用户开放的三个函数。每棵线段树的这三个函数基本都一样。 build ：建树。左右子树建完后 update 当前结点 change ：对递归到的结点， push_down 。在目标区间打上标记。修改左右子树后 update 当前结点。（这里还要考虑如何打标记，不要无脑模拟题目要求，尝试推式子得到更简单的形式。） query ：对递归到的结点， push_down 。找到目标区间后返回相应的值，要考虑如何区间合并。 什么时候下传标记 标记之间有相互影响时，需要在对子结点打标记前下传当前结点的标记。 什么时候调用 cal_lazy cal_lazy 的调用位置影响 update 和 push_down 的实现。 cal_lazy 的调用可以在两个地方： 打上标记时调用， 需要用到该结点上的值 或者 该结点的子结点的值 时调用 单点修改 单点修改线段树，是在做DP优化类题目中最常见的线段树。同时也是比赛中用的最多的树。 利用树的结构，可以写一个 迭代版的修改函数 。 区间修改 线段树在做区间修改的时候，发现如果每次都递归到叶子去修改，时间复杂度就不对了（除非这种暴力的次数有限，见势能线段树）。 这个时候就引入了LazyTag。 例题：P3372【模板】线段树 1 、P3373【模板】线段树 2 、D 数据结构 、E 线段树 常见的区间操作 线段树+矩阵 例题：线段树套矩阵 &amp; Luogu P7453 [THUSCH2017] 大魔法师 、 斐波 区间mex mex(S) ：集合 S 中没有出现过的最小自然数 模板问题：P4137 Rmq Problem / mex https://www.luogu.com.cn/blog/_post/122661 题解：https://www.cnblogs.com/iceyz/p/15500762.html 、P4137 Rmq Problem / mex (三种解法: 权值线段树+询问离线 / 可持久化线段树 / 莫队+值域分块) https://blog.csdn.net/purple_bro/article/details/85015911 2018 UESTC Training for Data Structures 一棵像样的线段树 区间加数列 关于线段树维护特殊数列的想法 加等差数列：P1438 无聊的数列 P1438 无聊的数列 (三种解法 线段树 / 树状数组) (等差数列 高阶差分 高阶前缀和) 加自然数的平方数列：智乃酱的平方数列 题解：智乃酱的平方数列 (线段树维护三阶前缀和 / 线段树维护二次函数) 关于 高阶差分 及 高阶前缀和 总结 29.牛客网多校第十场D 组合数+多次前缀和 https://blog.csdn.net/animalcoder/article/details/82504847 [CF446C]DZY Loves Fibonacci Numbers——线段树+斐波那契数列 区间位运算 P2574 XOR的艺术 ：对 01串做区间异或 CF242E XOR on Segment ：二进制拆位，建 20 棵线段树（数据范围小于 2202^{20}220）。复杂度为在单棵线段树基础上乘 20。 P2572 [SCOI2010]序列操作 ：对 01串区间赋值为 0或1、区间异或、区间求和、区间最长连续的 1。 其他 牛客寒假训练营 进制 ：单点修改，区间最大值，区间合并 HDU 1540 Tunnel Warface ：包含的 k 的最大连续长度（P11 POJ 2777 Count Color ：区间染色、区间颜色数（P14 SP2713 GSS4 - Can you answer these queries IV ：区间开方、区间求和（P15）。（同理可做区间取模 离线 干货｜线段树|树状数组+离线处理总结 扫描线 P5490【模板】扫描线 算法｜平面扫描–线段树维护的扫描线 练习｜扫描线有关习题 区间最值 OI-Wiki 区间最值操作 &amp; 区间历史最值 hdu 5306 线段树 区间修改 最小值+最大值 最假女选手 动态开点1 最大子段和 Easy version：P1115 最大子段和 SP1043 GSS1 - Can you answer these queries I ：最大子段和 SP1557 GSS2 - Can you answer these queries II ：最大子段和，不重复计算 SP1716 GSS3 - Can you answer these queries III ：最大子段和、单点修改 SP2916 GSS5 - Can you answer these queries V ：限定左右端点的最大子段和 权值线段树 算法｜权值线段树学习（模板+例题） 不可合并信息 虽然信息不可合并，但其具有一定性质，使得暴力操作复杂度仍为 O(nlog⁡n)O(n\\log n)O(nlogn) 。 SP2713 GSS4 - Can you answer these queries IV ：区间开根 CF438D The Child and Sequence ：区间取模 线段树上二分 例题：H 仓鼠的鸡蛋 HDU 5649 线段树+二分 POJ 2828 Buy Tickets 历史区间最值 吉如一线段树：P6242【模板】线段树 3 线段树优化建图 [线段树系列] 线段树优化建图 CF786B 【luogu P5025】炸弹（线段树优化建图）（Tarjan） 线段树维护树上信息 POJ 3321 Apple Tree(线段树 - 维护树上信息) POJ 3321 Apple Tree 线段树的分裂与合并1 【AgOHの数据结构】线段树分裂合并 二维线段树与四分树1 我们经常提及的二维线段树有两种写法，一种是四分树，一种是树套树，写成四分树的都是神仙。 https://www.cnblogs.com/aininot260/p/9375048.html DDP 1：46：20 线段树与树状数组的对比 树状数组的功能是线段树的功能的一部分。但代码要更好些、运行速度更快。 能写树状数组就写树状数组，不要无脑线段树。 但如果「求前缀的逆」比较困难，比如求矩阵的逆，则写线段树更好。 算法｜李超线段树初步（算法讲解+例题）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树状数组学习笔记","slug":"DS_Algorithm证明与讲解/数据结构/树状数组","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-22T15:56:01.703Z","comments":true,"path":"posts/1cd36f55/","link":"","permalink":"http://xiaoke-jin.github.io/posts/1cd36f55/","excerpt":"","text":"树状数组（BIT）—— 一篇就够了 树状数组详解 noip线段树与树状数组 算法讲解｜一个例子看懂树状数组 树状数组思想 规定：原数组：a 原数组的差分数组： b 树状数组：sum 每个正整数都可以表示为若干个 2 的幂次之和。 类似的，每次求前缀和，我们也希望将区间 [1,i] 分解成 log⁡2i\\log_2ilog2​i 个子集的和。 也就是说，如果 i 的二进制表示中如果有 k 个 1，我们就希望将其分解为 k 个子集之和。 示意图 sum[i] 之间的关系是 树状 的。数组下标要从 1 开始。 查询 10 = 1010 8 = 1000 ∑i=110ai\\sum_{i=1}^{10}a_i∑i=110​ai​ = sum[10] + sum[8]，sum[10] 维护 a10,a9a_{10}, a_9a10​,a9​ 的和，sum[8] 维护 a1∼a8a_1\\sim a_8a1​∼a8​ 的和 子集如何划分？ sum[i] 维护的元素个数是 i 的二进制表示中最低位的 1 所在的位置对应的数。（利用 lowbit(x) = x &amp; -x 可 O(1)O(1)O(1) 求出） ans = 0;while(i &gt; 0)&#123; ans += sum[i]; i -= lowbit(i);&#125; 修改 修改 a[i] 后，所有包含 a[i] 的 sum[] 也要修改，那么如和找到这些 sum[] 呢？ 包含 a[3] 的 sum[] 有 sum[3]，sum[4]，sum[8]，sum[16] 包含 a[6] 的 sum[] 有 sum[6]，sum[8]，sum[16] 包含 a[9] 的 sum[] 有 sum[9]，sum[10]，sum[12]，sum[16] n 以内包含 a[i] 的 sum[] 代码实现如下（证明暂略。。。 while(i &lt;= n)&#123; sum[i]; i += lowbit(i);&#125; 一维树状数组 单点修改、区间查询 单点修改：修改 a[i] 并更新所有包含 a[i] 的 sum[] 区间查询： [l, r][l,\\ r][l, r] ：∑i=lrai=∑i=1rai−∑i=1l−1ai\\sum_{i=l}^r a_i=\\sum_{i=1}^{r}a_i - \\sum_{i=1}^{l-1}a_i∑i=lr​ai​=∑i=1r​ai​−∑i=1l−1​ai​ 区间修改、单点查询 先求原数组的差分数组， 区间修改：通过差分数组 b[] 实现 O(1)O(1)O(1) 的区间修改。 单点查询：即 O(log⁡n)O(\\log n)O(logn) 求差分数组的前缀和。 区间修改、区间查询 区间修改：通过差分数组 b[] 实现 O(1)O(1)O(1) 的区间修改。 区间查询：∑i=1xai=∑i=1x∑j=1ibj=(x+1)×∑i=1xbi−∑i=1xbi×i\\sum_{i=1}^x a_i=\\sum_{i=1}^x\\sum_{j=1}^i b_j=(x + 1)\\times\\sum_{i=1}^xb_i - \\sum_{i=1}^xb_i\\times i∑i=1x​ai​=∑i=1x​∑j=1i​bj​=(x+1)×∑i=1x​bi​−∑i=1x​bi​×i 。示意图如下，蓝色部分即为所求。 所以需要维护 bib_ibi​ 和 i×bii\\times b_ii×bi​ 的前缀和。 AcWing 243. 一个简单的整数问题2 ：区间修改、区间查询。 题解：彩色铅笔的题解 第 k 大 区间最值 单点修改、区间查询 二维树状数组 总结｜树状数组小结-二维 题目 POJ 2352 树状数组强行查询区间 log⁡2n\\log^2 nlog2n","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"CP editor","slug":"else/工具/CP editor","date":"2021-10-01T16:00:00.000Z","updated":"2022-03-31T10:41:22.163Z","comments":true,"path":"posts/e6beb12f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e6beb12f/","excerpt":"","text":"cf上的一个博客，很详细：https://codeforces.com/blog/entry/72952 官方文档：https://cpeditor.org/v6.8/zh/docs/ CP editor 配置提交到 CodeForces 。CodeForces 上的一个博客，很详细：https://codeforces.com/blog/entry/72952 需要先下载这个浏览器插件：competitive-companion。 CP editor 这个插件只能提交到 codeforces.com，其他的比如 codeforces.ml 则不行。MD，被这个坑我一晚上的时间，重新配置了好几次。","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"CP editor","slug":"工具/CP-editor","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/CP-editor/"}],"tags":[]},{"title":"数学期望","slug":"DS_Algorithm证明与讲解/数学/杂项/数学期望","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-03T06:44:27.063Z","comments":true,"path":"posts/b9d78651/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b9d78651/","excerpt":"","text":"数论小白都能看懂的数学期望讲解 题目 洛谷题单：【日报配套题单】数论小白都能看懂的数学期望讲解","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"排列组合","slug":"DS_Algorithm证明与讲解/数学/组合数学/排列组合","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-16T05:55:41.886Z","comments":true,"path":"posts/f8e37cbd/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f8e37cbd/","excerpt":"","text":"彻底搞定排列组合各种题型 小学生都能看懂的错排问题解析 求组合数 O(n^2) 递推 O(nlogn) 预处理逆元 卢卡斯定理 排列与组合 X-factor Chains","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"斯特林数","slug":"DS_Algorithm证明与讲解/数学/组合数学/斯特林数","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-18T13:48:20.430Z","comments":true,"path":"posts/f6c6abbe/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f6c6abbe/","excerpt":"","text":"算法｜斯特林数、容斥和反演整理","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"组合数学网课","slug":"DS_Algorithm证明与讲解/数学/组合数学/组合数学网课","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-14T05:44:23.784Z","comments":true,"path":"posts/f1ea6eb8/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f1ea6eb8/","excerpt":"","text":"中科大 链接 。 一次课分两节，偶数第一节，奇数第二节。 从第 17 节课开始，两小节合为一个视频。 每次课前都会讲上次课留下的问题。 目录 排列组合 new 圆排列，可重排列 new set system、anti-chain recursion 递归 new 卡特兰数 （栈） 递推 容斥原理 斯特林数（第一类、第二类） 9：30处 拆分数 new 二次剩余 new 鸽笼原理（老师出差，中间不休息）new 鸽笼原理进阶 new ​ new ​ new 上交 B站 链接 。教材：《组合数学》卢开澄 卢华明 目录 P1~2：排列组合 P3~5：组合的意义、生成排列组合。 P5：（51：35） 母函数与递推关系 P11：（45：10） 容斥原理和鸽巢原理 P16：（32：50） 群 P18 OVER","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"矩阵相关算法","slug":"DS_Algorithm证明与讲解/数学/线性代数/矩阵相关算法","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-13T07:10:02.095Z","comments":true,"path":"posts/55f2dbb7/","link":"","permalink":"http://xiaoke-jin.github.io/posts/55f2dbb7/","excerpt":"","text":"视频： 3B1B线性代数 。 链接： OI wiki 矩阵 矩阵 定义 矩阵的运算律 谨记： 满足结合律，不满足交换律 ！！！ 矩阵的逆 矩阵的加减 矩阵的加减法是逐个元素进行的。 矩阵的乘法 矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。 设 AAA 为 P×MP \\times MP×M 的矩阵，BBB 为 M×QM \\times QM×Q 的矩阵，设矩阵 CCC 为矩阵 AAA 与 BBB 的乘积， 其中矩阵 CCC 中的第 iii 行第 jjj 列元素可以表示为： Ci,j=∑k=1MAi,kBk,jC_{i,j} = \\sum_{k=1}^MA_{i,k}B_{k,j} Ci,j​=k=1∑M​Ai,k​Bk,j​ 如果没看懂上面的式子，没关系。通俗的讲，在矩阵乘法中，结果 CCC 矩阵的第 iii 行第 jjj 列的数，就是由矩阵 AAA 第 iii 行 MMM 个数与矩阵 BBB 第 jjj 列 MMM 个数分别相乘再相加得到的。 矩阵乘法满足结合律，不满足一般的交换律。 利用结合律，矩阵乘法可以利用快速幂的思想来优化。 在比赛中，由于线性递推式可以表示成矩阵乘法的形式，也通常用矩阵快速幂来求线性递推数列的某一项。 一般来说，可以用一个二维数组来模拟矩阵。 struct matrix&#123; ll a[sz][sz]; matrix() &#123; memset(a, 0, sizeof a); &#125; matrix operator-(const matrix &amp;T) const // 减法 &#123; matrix res; for (int i = 0; i &lt; sz; ++i) for (int j = 0; j &lt; sz; ++j) &#123; res.a[i][j] = (a[i][j] - T.a[i][j]) % MOD; &#125; return res; &#125; matrix operator+(const matrix &amp;T) const // 加法 &#123; matrix res; for (int i = 0; i &lt; sz; ++i) for (int j = 0; j &lt; sz; ++j) &#123; res.a[i][j] = (a[i][j] + T.a[i][j]) % MOD; &#125; return res; &#125; matrix operator*(const matrix &amp;T) const // 乘法 &#123; matrix res; int r; for (int i = 0; i &lt; sz; ++i) for (int k = 0; k &lt; sz; ++k) &#123; r = a[i][k]; for (int j = 0; j &lt; sz; ++j) res.a[i][j] += T.a[k][j] * r, res.a[i][j] %= MOD; &#125; return res; &#125;&#125;; 应用 矩阵加速递推 常见的递推形式： f(n)=a1f(n−1)+a2f(n−2)+⋯+akf(n−k)f(n)=a_1f(n-1)+a_2f(n-2)+\\cdots+a_kf(n-k)f(n)=a1​f(n−1)+a2​f(n−2)+⋯+ak​f(n−k) f(n)=a1f(n−1)+a2f(n−2)+Cf(n)=a_1f(n-1)+a_2f(n-2)+Cf(n)=a1​f(n−1)+a2​f(n−2)+C ，CCC 是常数。 f(n)=a1f(n−1)+a2f(n−2)+c2n2+c1n+c0f(n)=a_1f(n-1)+a_2f(n-2)+c_2n^2+c_1n+c_0f(n)=a1​f(n−1)+a2​f(n−2)+c2​n2+c1​n+c0​ f(n)=a11f(n−1)+a12g(n−1)f(n)=a_{11}f(n-1)+a_{12}g(n-1)f(n)=a11​f(n−1)+a12​g(n−1) ，g(n)=a21f(n−1)+a22g(n−1)g(n)=a_{21}f(n-1)+a_{22}g(n-1)g(n)=a21​f(n−1)+a22​g(n−1) 矩阵表达修改 定长路径统计 定长最短路 限长路径计数/最短路 题目 P1962 斐波那契数列 ：板子题。 P3390 【模板】矩阵快速幂 P1349 广义斐波那契数列 斐波那契 洛谷 P1939【模板】矩阵加速（数列）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"线代","slug":"线代","permalink":"http://xiaoke-jin.github.io/tags/%E7%BA%BF%E4%BB%A3/"}]},{"title":"一次不定方程和一元一次同余方程","slug":"DS_Algorithm证明与讲解/数学/数论/同余/一元一次同余方程","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-05T07:57:23.013Z","comments":true,"path":"posts/b4880d8f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b4880d8f/","excerpt":"","text":"前置芝士：[也许你需要一些关于同余的知识]、裴蜀定理、扩展欧几里得。 转自：OI wiki 一次不定方程和一元一次同余方程是等价的，但关于一元一次同余方程有更多内容，所以分开写了。 二元一次不定方程 已知方程 ax+by=cax+by=cax+by=c （其中 a, b, ca,\\ b,\\ ca, b, c 是整数） 特解及其通解 下面的定理说明 什么时候这类方程有解，当有解的时候又如何明确地描述它们。 定理：设 a, ba,\\ ba, b 是整数且 d=(a, b)d=(a,\\ b)d=(a, b) 。如果 d∤cd\\nmid cd∤c ，那么方程 ax+by=cax+by=cax+by=c 没有整数解。如果 d∣cd\\mid cd∣c ，那么存在无穷多个整数解。如果 x=x0x=x_0x=x0​ ，y=y0y=y_0y=y0​ 是方程的一个特解，那么所有的解可以表示为 x=x0+(b/d)ny=y0−(a/d)n\\qquad\\qquad\\qquad\\qquad\\qquad x=x_0+(b/d)n \\qquad y=y_0-(a/d)nx=x0​+(b/d)ny=y0​−(a/d)n 其中 nnn 是整数。 证明：假设 x, yx,\\ yx, y 是整数满足 ax+by=cax+by=cax+by=c 。那么因为 d∣ad\\mid ad∣a ，d∣bd\\mid bd∣b ，所以有 d∣cd\\mid cd∣c 。因此如果 d∤cd\\nmid cd∤c ，那么这个方程就不存在整数解。 \\qquad现在假设 d∣cd\\mid cd∣c ，由裴蜀定理 ，存在整数 s, ts,\\ ts, t 使得 d=as+bt(1)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad d=as+bt \\qquad\\qquad\\qquad\\qquad (1)d=as+bt(1) 因为 d∣cd\\mid cd∣c ，有整数 eee 使得 de=cde=cde=c 。在（1）两边同时乘以 eee ，我们有 c=de=(as+bt)e=a(se)+b(te)c=de=(as+bt)e=a(se)+b(te)c=de=(as+bt)e=a(se)+b(te) 。 因此，x=x0x=x_0x=x0​ ，y=y0y=y_0y=y0​ ，就是方程的一个解，其中 x0=sex_0=sex0​=se ，y0=tey_0=tey0​=te 。（s，t 通过扩欧可得） \\qquad为了证明方程存在无穷多个解，令 x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n ，y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n ，其中 nnn 是整数。 \\qquad首先证明任何一对整数 (x, y)(x,\\ y)(x, y) ，x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n ，y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n ，nnn 是整数，它是方程的解。然后再证明方程的任何一个解都具有这种形式。 \\qquad易知 (x, y)(x,\\ y)(x, y) 是解，这是因为 ax+by=ax0+a(b/d)n+by0−b(a/d)n=ax0+by0=cax+by=ax_0+a(b/d)n+by_0-b(a/d)n=ax_0+by_0=cax+by=ax0​+a(b/d)n+by0​−b(a/d)n=ax0​+by0​=c 。 \\qquad我们现在证明方程 ax+by=cax+by=cax+by=c 的解都具有定理中所描述的那种形式。假设整数 x, yx,\\ yx, y 满足 ax+by=cax+by=cax+by=c 。因为 ax0+by0=cax_0+by_0=cax0​+by0​=c ，做减法得到 (ax+by)−(ax0+by0)=0(ax+by)-(ax_0+by_0)=0(ax+by)−(ax0​+by0​)=0 ，这就说明 a(x−x0)+b(y−y0)=0a(x-x_0)+b(y-y_0)=0a(x−x0​)+b(y−y0​)=0 。因此 a(x−x0)=b(y0−y)a(x-x_0)=b(y_0-y)a(x−x0​)=b(y0​−y) 。两边同时除以 ddd ，得 (a/d)(x−x0)=(b/d)(y0−y)(a/d)(x-x_0)=(b/d)(y_0-y)(a/d)(x−x0​)=(b/d)(y0​−y) 。 (a/d, b/d)=1(a/d,\\ b/d)=1(a/d, b/d)=1 。有 (a/d)∣(y0−y)(a/d)\\mid (y_0-y)(a/d)∣(y0​−y) 。因此，存在整数 nnn 使得 (a/d)n=(y0−y)(a/d)n=(y_0-y)(a/d)n=(y0​−y) 。这就意味着 y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n 。现在将这个 yyy 值代入方程 a(x−x0)=b(y0−y)a(x-x_0)=b(y_0-y)a(x−x0​)=b(y0​−y) ，我们得到 a(x−x0)=b(a/d)na(x-x_0)=b(a/d)na(x−x0​)=b(a/d)n 。这就得到了 x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n 。 求正整数解 ​ 小凯的疑惑 P3951 NOIP2017 提高组 小凯的疑惑/蓝桥杯 2013 省 买不到的数目 没有非负解的最大非负整数（先写个结论：ab-a-b 有多少非负整数使得方程无非负解（答案：12(a−1)(b−1)\\frac{1}{2}(a-1)(b-1)21​(a−1)(b−1) 题目 P5656 【模板】二元一次不定方程 (exgcd) 一个重要的题 多元一次不定方程 略。（也许以后OI、XCPC会考？ 一元一次同余方程 \\qquad设 xxx 是未知整数，形如 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的同余式称为 一元线性同余方程 。（显然可以等价于 ax−my=bax-my=bax−my=b \\qquad首先注意到，若 x=x0x=x_0x=x0​ 是同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的一个解，且 x0≡x1 ( mod m)x_0\\equiv x_1\\ (\\bmod\\ m)x0​≡x1​ (mod m) ，则 ax0≡ax1≡b ( mod m)ax_0\\equiv ax_1\\equiv b\\ (\\bmod\\ m)ax0​≡ax1​≡b (mod m) ，所以 也是一个解。因此，若一个模 mmm 同余类中的某个元素是解，则此同余类的所有元素都是解。于是，我们会问模 mmm 的 mmm 个同余类中有多少个是方程的解，这相当于问方程有多少个模 mmm 不同于的解。 下面的定理告诉我们一元线性同余方程 何时有解 ，在有解时方程 有多少个模 mmm 不同余的解 。 定理1：设 a, b, ma,\\ b,\\ ma, b, m 是整数， m&gt;0, (a, m)=dm&gt;0,\\ (a,\\ m)=dm&gt;0, (a, m)=d 。若 d∤bd\\nmid bd∤b ，则 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 无解。若 d∣bd\\mid bd∣b ，则 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 恰有 ddd 个模 mmm 不同余的解。 证明：线性同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 等价于 ax−my=bax-my=bax−my=b 。整数 xxx 是 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的解当且仅当存在整数 yyy 使得 ax−my=bax-my=bax−my=b 。 \\qquad若 d∤bd\\nmid bd∤b ，则无解。而 d∤bd\\nmid bd∤b 时， 有无穷多解： x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t ， y=y0+(a/d)ty=y_0+(a/d)ty=y0​+(a/d)t 。其中 x0x_0x0​ 和 y0y_0y0​ 是方程的特解。 \\qquad为确定有多少不同余的解，我们要找到两个解 x1=x0+(m/d)t1x_1=x_0+(m/d)t_1x1​=x0​+(m/d)t1​ 和 x2=x0+(m/d)t2x_2=x_0+(m/d)t_2x2​=x0​+(m/d)t2​ 模 mmm 同余的条件。若这两个解同余，则 x0+(m/d)t1≡x0+(m/d)t2 ( mod m)x_0+(m/d)t_1\\equiv x_0+(m/d)t_2\\ (\\bmod\\ m)x0​+(m/d)t1​≡x0​+(m/d)t2​ (mod m) 。两边减去 x0x_0x0​ ，有 (m/d)t1≡(m/d)t2 ( mod m)(m/d)t_1\\equiv (m/d)t_2\\ (\\bmod\\ m)(m/d)t1​≡(m/d)t2​ (mod m) 。因为 (m/d)∣m(m/d)\\mid m(m/d)∣m ，所以 (m, m/d)=m/d(m,\\ m/d)=m/d(m, m/d)=m/d ，此时可使用除法运算得 t1≡t2 ( mod d)t_1\\equiv t_2\\ (\\bmod\\ d)t1​≡t2​ (mod d) 。这表明不同余的解的一个完全集合可以通过取 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 得到，其中 ttt 取遍模 ddd 的完全剩余系。这样的一个集合可由 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 给出，其中 t=0,1,2,⋯ ,d−1t=0,1,2,\\cdots,d-1t=0,1,2,⋯,d−1 。 推论：若 (a, m)=1(a,\\ m)=1(a, m)=1 ，则线性同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 有模 mmm 的唯一解。（唯一指：模 m 不同余的同余类数量） 证明：由定理一易得。 高次同余方程 OI wiki上讲的比较简单 一次不定方程 根据以下两个定理，我们可以求出同余方程 ax≡c(modb)ax \\equiv c \\pmod bax≡c(modb) 的解。 定理 1：方程 ax+by=cax+by=cax+by=c 与方程 ax≡c(modb)ax \\equiv c \\pmod bax≡c(modb) 是等价的，有整数解的充要条件为 gcd⁡(a,b)∣c\\gcd(a,b) \\mid cgcd(a,b)∣c。 根据定理 1，方程 ax+by=cax+by=cax+by=c，我们可以先用扩展欧几里得算法求出一组 x0,y0x_0,y_0x0​,y0​，也就是 ax0+by0=gcd⁡(a,b)ax_0+by_0=\\gcd(a,b)ax0​+by0​=gcd(a,b)，然后两边同时除以 gcd⁡(a,b)\\gcd(a,b)gcd(a,b)，再乘 ccc。然后就得到了方程 acgcd⁡(a,b)x0+bcgcd⁡(a,b)y0=ca\\dfrac{c}{\\gcd(a,b)}x_0+b\\dfrac{c}{\\gcd(a,b)}y_0=cagcd(a,b)c​x0​+bgcd(a,b)c​y0​=c，然后我们就找到了方程的一个解。 定理 2：若 gcd⁡(a,b)=1\\gcd(a,b)=1gcd(a,b)=1，且 x0x_0x0​、y0y_0y0​ 为方程 ax+by=cax+by=cax+by=c 的一组解，则该方程的任意解可表示为：x=x0+btx=x_0+btx=x0​+bt，y=y0−aty=y_0-aty=y0​−at, 且对任意整数 ttt 都成立。 根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个 最小正整数解 ，也就是一个特解 x=(x mod t+t) mod tx=(x \\bmod t+t) \\bmod tx=(xmodt+t)modt，其中 t=bgcd⁡(a,b)t=\\dfrac{b}{\\gcd(a,b)}t=gcd(a,b)b​。 int ex_gcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int r = exgcd(b, a % b, y, x); y -= (a / b) * x; return d;&#125;bool liEu(int a, int b, int c, int&amp; x, int&amp; y) &#123; int d = ex_gcd(a, b, x, y); if (c % d != 0) return 0; int k = c / d; x *= k; y *= k; return 1;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"乘法逆元","slug":"DS_Algorithm证明与讲解/数学/数论/同余/乘法逆元","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-13T12:25:43.623Z","comments":true,"path":"posts/bfaab9bd/","link":"","permalink":"http://xiaoke-jin.github.io/posts/bfaab9bd/","excerpt":"","text":"参考链接： OI Wiki ，扩展欧几里得算法详解 。 本文介绍模意义下 乘法运算的逆元（Modular Multiplicative Inverse） 前置芝士：扩展欧几里得、线性同余方程、费马小定理。 逆元简介 如果一个线性同余方程 ax≡1(modp)ax \\equiv 1 \\pmod pax≡1(modp)，则 xxx 称为 a mod pa \\bmod pamodp 的乘法逆元，记作 a−1a^{-1}a−1。 若 a−1a^{-1}a−1 是 aaa 模 ppp 的逆元，则 a−1a^{-1}a−1 所属的同余类也是 aaa 模 ppp 的逆元。 求逆元 扩欧 费马小定理 费马小定理求逆元：设 ppp 是一个素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，ap−2a^{p-2}ap−2 是 aaa 模 ppp 的逆。 线性方法 线性求逆元 线性求任意 n 个数的逆元 线性求阶乘的逆元 其实是 log⁡n+n\\log n+nlogn+n 的。 先求 n 的阶乘的逆元，invfac[n] = qmi(fac[n], mod) 。然后递推 invfac[i - 1] = invfac[i] * i % mod 。 一个 trick 下面的定理告诉我们哪些整数是其自身模 ppp 的逆，其中 ppp 是素数。 定理：设 ppp 是素数。正整数 aaa 是其自身模 ppp 的逆当且仅当 a≡1 ( mod p)a\\equiv 1\\ (\\bmod\\ p)a≡1 (mod p) 或 a≡−1 ( mod p)a\\equiv -1\\ (\\bmod\\ p)a≡−1 (mod p) 。 证明：若 a≡1 ( mod p)a\\equiv 1\\ (\\bmod\\ p)a≡1 (mod p) 或 a≡−1 ( mod p)a\\equiv -1\\ (\\bmod\\ p)a≡−1 (mod p) ，则 a2≡1 ( mod p)a^2\\equiv 1\\ (\\bmod\\ p)a2≡1 (mod p) 。所以 aaa 是其自身模 ppp 的逆。 反过来，若 aaa 是其自身模 ppp 的逆，则 a2≡1 ( mod p)a^2\\equiv 1\\ (\\bmod\\ p)a2≡1 (mod p) 。因此， p∣(a2−1)p\\mid (a^2-1)p∣(a2−1) 。又因为 a2−1=(a−1)(a+1)a^2-1=(a-1)(a+1)a2−1=(a−1)(a+1) ，所以 p∣(a−1)p\\mid (a-1)p∣(a−1) 或 。因此， p∣(a−1)p\\mid (a-1)p∣(a−1) ，或者 p∣(a+1)p\\mid (a+1)p∣(a+1) 。 题目 洛谷题单：【数论】Exgcd/乘法逆元 P3811 【模板】乘法逆元 ：求 1∽n1\\backsim n1∽n 模 ppp 的逆元。 P5431【模板】乘法逆元 2 ：求任意 nnn 个数模 ppp 的逆元。 「NOIP2012」同余方程 P2054 [AHOI2005]洗牌 「SDOI2016」排列计数","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"同余基础知识","slug":"DS_Algorithm证明与讲解/数学/数论/同余/同余基础知识","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-14T08:06:06.393Z","comments":true,"path":"posts/10504d0f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/10504d0f/","excerpt":"","text":"同余定义及性质 a同余于b模m，b是a对模m的剩余 最小非负剩余、最小正剩余、绝对最小剩余 定理：a同余于b模m的充分必要条件 同余运算 四则运算 模的逆 两个数关于不同模的同余式 定理：若 a≡b( mod m1),a≡b( mod m2),⋯ ,a≡b( mod mk)a\\equiv b(\\bmod m_1),a\\equiv b(\\bmod m_2),\\cdots ,a\\equiv b(\\bmod m_k)a≡b(modm1​),a≡b(modm2​),⋯,a≡b(modmk​) ，其中 a,b,m1,m2,⋯ ,mka,b,m_1,m_2,\\cdots,m_ka,b,m1​,m2​,⋯,mk​ 是整数，则 a≡b( mod [m1,m2,⋯ ,mk])a\\equiv b(\\bmod [m_1,m_2,\\cdots,m_k])a≡b(mod[m1​,m2​,⋯,mk​]) ，其中 [m1,m2,⋯ ,mk][m_1,m_2,\\cdots,m_k][m1​,m2​,⋯,mk​] 是这些数的最小公倍数。 证明：略。（懒 QwQ 剩余类和剩余系 剩余类也叫同余类 我们以 r mod mr\\bmod mrmodm 表示 rrr 所属的模 mmm 的同余类。 同余方程的基本概念 后续 掌握以上内容，你可以继续学习： 快速幂取模 费马-欧拉定理 乘法逆元 一元一次同余方程 威尔逊定理 中国剩余定理 卢卡斯定理 求解多项式同余方程 升幂定理 二次剩余 两种高次同余方程：BSGS + N次剩余 原根 题目 放一些题目 HDU 5776：同余，鸽笼原理 51Nod 3038 数列求和","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论——威尔逊定理","slug":"DS_Algorithm证明与讲解/数学/数论/同余/威尔逊定理","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-02T06:34:31.829Z","comments":true,"path":"posts/39123d8e/","link":"","permalink":"http://xiaoke-jin.github.io/posts/39123d8e/","excerpt":"","text":"详见《初等数论及其应用》P160 威尔逊定理：若 ppp 是素数，则 (p−1)!≡−1( mod p)(p-1)!\\equiv -1(\\bmod p)(p−1)!≡−1(modp) 。 威尔逊定理的逆定理也是成立的。 逆定理：设 nnn 是正整数且 n⩾2n\\geqslant 2n⩾2 ，若 (n−1)!≡−1( mod p)(n-1)! \\equiv -1(\\bmod p)(n−1)!≡−1(modp) ，则 nnn 是素数。 威尔逊定理及其逆命题给出了一种素性检验法。但时间复杂度是 O(n)O(n)O(n) 的！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"费马-欧拉定理","slug":"DS_Algorithm证明与讲解/数学/数论/同余/费马_欧拉定理","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-03T03:39:14.997Z","comments":true,"path":"posts/4171ac2f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/4171ac2f/","excerpt":"","text":"费马小定理 费马小定理：设 ppp 是一个素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，则 ap−1≡1( mod p)a^{p-1}\\equiv 1(\\bmod p)ap−1≡1(modp) 。 定理：设 ppp 是一个素数且 aaa 是一个正整数，则 ap≡a( mod p)a^{p}\\equiv a(\\bmod p)ap≡a(modp) 。 费马小定理求逆元：设 ppp 是一个素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，ap−2a^{p-2}ap−2 是 aaa 模 ppp 的逆。 解线性同余方程：若 a,ba,ba,b 是正整数， ppp 是素数且 p∤ap\\nmid ap∤a ，那么线性同余方程 ax≡b( mod p)ax\\equiv b(\\bmod p)ax≡b(modp) 的解是满足 x≡ap−2b( mod p)x\\equiv a^{p-2}b(\\bmod p)x≡ap−2b(modp) 的整数 。 费马小定理的逆定理不成立。 欧拉定理 既约剩余系 欧拉定理：设 mmm 是一个正整数， aaa 是一个整数且 (a,m)=1(a,m)=1(a,m)=1 ，那么 aφ(m)≡1( mod m)a^{\\varphi(m)}\\equiv 1(\\bmod m)aφ(m)≡1(modm) 。 扩展欧拉定理 ab≡{ab mod φ(m),gcd⁡(a,m)=1,ab,gcd⁡(a,m)≠1,b&lt;φ(m),a(b mod φ(m))+φ(m),gcd⁡(a,m)≠1,b≥φ(m).(modm)a^b \\equiv \\begin{cases} a^{b\\ \\bmod \\ \\varphi(m)}, &amp;\\gcd(a,m) = 1, \\\\ a^b, &amp;\\gcd(a,m)\\ne 1, b &lt; \\varphi(m), \\\\ a^{(b\\ \\bmod\\ \\varphi(m)) + \\varphi(m)}, &amp;\\gcd(a,m)\\ne 1, b \\ge \\varphi(m). \\end{cases} \\pmod m ab≡⎩⎨⎧​ab mod φ(m),ab,a(b mod φ(m))+φ(m),​gcd(a,m)=1,gcd(a,m)=1,b&lt;φ(m),gcd(a,m)=1,b≥φ(m).​(modm) 证明：OI wiki 欧拉定理 tip：第一项和第三项可以合并。 题目 【模板】扩展欧拉定理","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Meissel-Lehmer 算法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/Meissel-Lehmer","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-04T05:45:18.829Z","comments":true,"path":"posts/ee2f0c1f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ee2f0c1f/","excerpt":"","text":"「Meissel-Lehmer 算法」是一种能在亚线性时间复杂度内求出 1∽n1\\backsim n1∽n 内质数个数的一种算法。 挖坑","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Pollard Rho 算法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/Pollard-Rho算法","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-04T05:44:17.276Z","comments":true,"path":"posts/234751a6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/234751a6/","excerpt":"","text":"一些文章 Miller-Rabin与Pollard-Rho学习笔记","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"因数相关算法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/因数","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-13T06:49:51.697Z","comments":true,"path":"posts/5638ece3/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5638ece3/","excerpt":"","text":"分解质因数 直接试除法 任意合数 xxx 最多有一个大于 x\\sqrt{x}x​ 的质因子。 void div(int x)&#123; for(int i = 2; i * i &lt;= x; i++)&#123; if(x % i == 0)&#123; int cnt = 0; while(x % i == 0) x /= i, cnt++; printf(&quot;%d %d\\n&quot;, i, cnt); &#125; &#125; if(x != 1) printf(&quot;%d 1&quot;, x);&#125; 使用质数试除 若一个数是大质数或是两个大质数的乘积，此时会达到 O(n)O(\\sqrt{n})O(n​) 的复杂度，则使用质数试除会更快。 所以如果题目中要对 多个数 进行质因子分解，可先 O(n)O(n)O(n) 预处理，得到 n\\sqrt{n}n​ 内的质数。再进行质因子分解，会快 nln⁡(n)\\dfrac{\\sqrt{n}}{\\ln({\\sqrt{n}})}ln(n​)n​​ 倍（7~10倍）。 int primes[N], cnt;pair&lt;int, int&gt; factor[N], fnct;void get_primes(int n) // 预处理 根号n 内的素数&#123; for(int i = 2; i &lt;= n; i++) &#123; if(!st[i]) primes[++cnt] = i; for(int j = 1; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if(i % primes[i] == 0) break; &#125; &#125;&#125;void Div(int n) // 分解 n&#123; for(int i = 1; primes[i] * primes[i] &lt;= n; i++) &#123; // 一个数最多有 1个大于根号 n的质因子 if(n % i == 0) &#123; int s = 0; while(n % i == 0) n /= i, s++; factor[++fcnt] = &#123;i, s&#125;; &#125; &#125; if(n &gt; 1) factor[++fcnt] = &#123;n, 1&#125;;&#125; 用最小质因子试除 欧拉筛记录最小质因子 Pollard Rho 算法 OI wiki 算法竞赛专题解析（19）：数论–质因数分解 P4718 【模板】Pollard-Rho 算法：Pollard-Rho。 P4358 [CQOI2016] 密钥破解：Pollard-Rho。 P4714 「数学」约数个数和：组合数 + Pollard-Rho。 求所有因数 O(n)O(\\sqrt{n})O(n​) 暴力。 分解质因式+DFS。先分解质因式（一个数最多有一个大于根号 nnn 的质因子） #include&lt;bits/stdc++.h&gt;using namespace std;const int N = 50010;int primes[N], cnt;bool st[N];struct Factor&#123; int p, s;&#125;factor[10]; // 质因子分解int fcnt;int dividor[1601], dcnt; // 存储所有因数void init(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] * i &lt;= n; j ++ ) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;void dfs(int u, int p)&#123; // 根据素幂因子分解 q if (u == fcnt) &#123; dividor[dcnt ++] = p; return; &#125; for (int i = 0; i &lt;= factor[u].s; i ++ ) &#123; dfs(u + 1, p); p *= factor[u].p; &#125;&#125;void div(int n) // 求 n 的所有因数&#123; for (int i = 0; primes[i] * primes[i] &lt;= n; i ++ ) // 小于等于根号 n 的所有质因数 &#123; int p = primes[i]; if (n % p == 0) &#123; int s = 0; while (n % p == 0) n /= p, s ++ ; factor[fcnt ++ ] = &#123;p, s&#125;; &#125; &#125; if (n &gt; 1) factor[fcnt ++ ] = &#123;n, 1&#125;; dcnt = 0; dfs(0, 1);&#125; n的阶乘质因子分解 一些性质 Trick n!n!n! 取模，当 n 大于模数的最大质因数时，得 0 。 题目 比比谁更大 ：题解 。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论基础","slug":"DS_Algorithm证明与讲解/数学/数论/整除/数论基础","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-04T14:45:49.670Z","comments":true,"path":"posts/cc39cba6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/cc39cba6/","excerpt":"","text":"整除 a∣ba\\mid ba∣b ，即 aaa 的任意质因子 ppp 的幂次小于等于 ppp 在 bbb 中的幂次，且 aaa 的所有质因子都是 bbb 的质因子。 一个数的第二小的因子是该数的最小质因子。（1 是第一小） 新的旅程 掌握以上内容，你可以继续学习： 素数相关算法：素性检验、反素数 因数相关算法：求所有因数、质因数分解 素数筛：欧拉筛、埃筛 欧几里得算法：含扩欧、裴蜀 类欧几里得算法 Meissel-Lehmer 算法：useless Pollard-Rho：useless 参考资料 OI wiki 数论基础","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"欧几里得算法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/欧几里得算法","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-07T16:01:18.556Z","comments":true,"path":"posts/b511dfae/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b511dfae/","excerpt":"","text":"辗转相除法、更相减损法 欧几里得算法 含负数的 gcd：直接把负数变正数即可。 两个数的最大公因子 两个不全为0的整数a，b的最大公因子是a，b的线性组合中最小的正整数。 如果 a, b 是正整数，那么所有 a, b 的线性组合构成的集合与所有 (a, b)(a,\\ b)(a, b) 的倍数构成的集合相同。 n 个数的最大公因子 发现最大公因子是所有数的因子且出现次数为 nnn ，且最大。所以求 nnn 个数的所有因子，存入 map ，再遍历 map ，取出现 nnn 次的数的最大值。 map&lt;int, int&gt; a_map;int gcd = 1;for(auto i : a_map) if(i.second == n) gcd = max(gcd, i.first); 稍作改动，可求 nnn 个数中 mmm 个数的的最大公因子。将 if(i.second == n) 改为 if(i.second == m) 即可。 1593D2 Half of Same 如果是先 (nm)\\dbinom{n}{m}(mn​) ，再 gcd⁡(a1,a2,⋯ ,am)\\gcd(a_1, a_2, \\cdots,a_m)gcd(a1​,a2​,⋯,am​) ，则会慢很多。 int g = 0;for(int i = 1; i &lt;= n; i++) g = gcd(a[i], g); 大整数的GCD 扩展欧几里得算法 先看看 OI wiki裴蜀定理 链接：扩展欧几里得算法详解 namo， 互质 相邻的自然数一定互质。 相邻质数互质。 两个数中的较大一个是质数，这两个数一定是互质数。 较大数比较小数的 2 倍多 1 或少 1 ，这两个数一定是互质数。 题目 gcd、lcm、exgcd P4549 【模板】裴蜀定理 ：n个整数的线性组合中最小正整数为其 gcd⁡\\gcdgcd 。 P3951 [NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目 ：一篇题解 。 CF1459C Row GCD CF1152C Neko does Maths CF1612D X-Magic Pair 辗转相除 [NOIP2001 普及组] 最大公约数和最小公倍数问题 ：题解 。 P1072 [NOIP2009 提高组] Hankson 的趣味题 ：题解 。 洛谷 P1516 青蛙的约会 CF1542C Strange Function ：题解 。 P4626 一道水题 II ：题解 。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"素数相关算法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/素数","date":"2021-10-01T16:00:00.000Z","updated":"2022-02-13T04:50:30.035Z","comments":true,"path":"posts/bbcd864f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/bbcd864f/","excerpt":"","text":"一些文章 求十亿内所有质数的和，怎么做最快? - 知乎 - Zhihu 如何编程判断一个数是否是质数？ - 知乎 - Zhihu 数论部分第一节：素数与素性测试 桃子的算法笔记——反素数详解（acm/OI） 确定性 素性判断 试除法 任意合数 nnn 都至少有一个小于等于 n\\sqrt{n}n​ 的质因子。 bool is_prime(int x)&#123; for(int i = 2; i &lt;= x / i; i++) if(x % i == 0) return false; return true;&#125; 对于 多组数据，如果 nnn 是合数，那么它必然有一个小于等于 n\\sqrt{n}n​ 的素因子，只需要对 n\\sqrt{n}n​ 内的素数进行测试即可，也就是预处理求出中的素数。（那么时间复杂度是多少呢？请看后面的「素数分布的初等结果」）答案：O(nln⁡n)O(\\dfrac{\\sqrt{n}}{\\ln{\\sqrt{n}}})O(lnn​n​​) kn+i 法 没用过 在枚举因子时只需要考虑可能为素数的因子即可。 kn+ikn+ikn+i 法即枚举形如 kn+ikn+ikn+i 的数，例如取 k=6k=6k=6 ，那么 6n+2,6n+3,6n+4,6n+66n+2,6n+3,6n+4,6n+66n+2,6n+3,6n+4,6n+6 都不可能为素数（显然它们分别有因子 2，3，2，6 ），因此我们只需要枚举形如 6n+1,6n+56n+1,6n+56n+1,6n+5 的数即可，这样整体的时间复杂度就会降低了 23\\dfrac{2}{3}32​ ，也就是 O(n13)O(n^{\\frac{1}{3}})O(n31​) 。（其实也没降多少 下面是 k=30k=30k=30 的模板： bool isPrime(ll n)&#123; if(n == 2 || n == 3 || n == 5) return 1; if(n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) return 0; ll c = 7, a[8] = &#123;4, 2, 4, 2, 4, 6, 2, 6&#125;; while(c * c &lt;= n) for(auto i : a) &#123; if(n % c == 0) return 0; c += i; &#125; return 1; // 是质数&#125; 筛法 预处理 跑一遍 素数筛 ，再 O(1)O(1)O(1) 查 bool 数组即可。 AKS算法 挖坑 前几年AKS算法轰动世界，它是第一个 多项式的、确定的、无需其它条件的 素性判断算法。当时一篇论文发表出来，题目就叫PRIMES is in P，然后整个世界都疯了。算法主要基于下面的事实：n是一个素数当且仅当(x-a)^n≡(x^n-a) (mod n)。注意这个x是多项式中的未知数，等式两边各是一个多项式。举个例子来说，当a=1时命题等价于如下结论：当n是素数时，杨辉三角的第n+1行除两头的1以外其它的数都能被n整除。 概率性 素性判断 前置芝士：费马小定理 Fermat 素性测试 如果费马小定理的逆定理成立，，，，，，， 很遗憾费马小定理的逆定理并不成立。 伪素数 那我们能否通过随机选取不同的数来进行素性判断呢？ 很遗憾，也不行。 卡迈克尔数 浅谈卡迈克尔数 判断一个数是否为卡迈克尔数：https://vjudge.net/problem/UVA-10006 题解：UVA 10006（卡迈克尔数+素数打表） 1e8 内有 255 个卡迈克尔数。 Miller-Rabin 素性测试 贴一个能用的板子，原题链接：SP288 PON - Prime or Not #include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll mul(ll a, ll b, ll m)&#123; return static_cast&lt;__int128&gt;(a) * b % m;&#125;ll power(ll a, ll b, ll m)&#123; ll res = 1 % m; // m=1则答案为0 for (; b; b &gt;&gt;= 1, a = mul(a, a, m)) if (b &amp; 1) res = mul(res, a, m); return res;&#125;bool isprime(ll n)&#123; if (n &lt; 2) return false; static constexpr int A[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23&#125;; int s = __builtin_ctzll(n - 1); ll d = (n - 1) &gt;&gt; s; for (auto a : A) &#123; if (a == n) return true; ll x = power(a, d, n); if (x == 1 || x == n - 1) continue; bool ok = false; for (int i = 0; i &lt; s - 1; ++i) &#123; x = mul(x, x, n); if (x == n - 1) &#123; ok = true; break; &#125; &#125; if (!ok) return false; // 不是质数 &#125; return true; // 是质数&#125;int main()&#123; int n; cin &gt;&gt; n; while (n--) &#123; long long a; scanf(&quot;%lld&quot;, &amp;a); if (isprime(a)) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; return 0;&#125; 素数分布的初等结果 待更 Mangoldt 函数 Λ(n)\\Lambda(n)Λ(n) （曼戈尔特函数，也称：第二切比雪夫函数）Λ(n)={log⁡ pn=pk, k⩾10 其他 \\Lambda(n)= \\begin{cases} \\log\\ {p} &amp; n=p^k,\\ \\ k\\geqslant 1 \\\\ 0 &amp; \\text{ 其他 }\\ \\end{cases}Λ(n)={log p0​n=pk, k⩾1 其他 ​ Liouville 函数（刘维尔） λ(n)\\lambda(n)λ(n) ， λ(n)=(−1)Ω(n)\\lambda(n)=(-1)^{\\Omega(n)}λ(n)=(−1)Ω(n) nnn 的全部素因子的个数（重复计数） Ω(n)\\Omega(n)Ω(n) Ω(1)=0\\Omega(1)=0Ω(1)=0 Ω(n)=∑i=1sαi, n=p1α1p2α2⋯psαs\\Omega(n)=\\displaystyle\\sum_{i=1}^{s}{\\alpha_i},\\ \\ n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_s^{\\alpha_s}Ω(n)=i=1∑s​αi​, n=p1α1​​p2α2​​⋯psαs​​ nnn 的不同的素因子的个数 ω(n)\\omega(n)ω(n) ω(1)=0\\omega(1)=0ω(1)=0 ω(n)=s, n=p1α1p2α2⋯psαs\\omega(n)=s,\\ \\ n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_s^{\\alpha_s}ω(n)=s, n=p1α1​​p2α2​​⋯psαs​​ 素数间隔 1e7 内间隔 100 以上的相邻素数对有 218 对，间隔 150 以上的相邻素数对有 2 对（间隔分别为 154、152）。 1e8 内间隔 100 以上的相邻素数对有 6931 对，间隔 150 以上的相邻素数对有 166 对，间隔 200 以上的有三对。 结论：1e8 内素数间隔并不大，所以求小于等于 n 的最大质数时可以考虑枚举 + 暴力判断。 #include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 5761455 + 10, M = 1e8; // 1e8 内素数 5761455 个int p[N], cnt;bool st[M];void getp(int n = 1e8)&#123; for (int i = 3; i &lt;= n; i += 2) &#123; if (!st[i]) p[++cnt] = i; for (int j = 1; 1ll * p[j] * i &lt;= n; j++) &#123; st[p[j] * i] = true; if (i % p[j] == 0) break; &#125; &#125;&#125;int main()&#123; getp(); int res = 0; int ans[10000], anscnt = 0; for (int i = 1; i &lt; cnt; i++) &#123; if(p[i + 1] - p[i] &gt;= 200) res++, ans[++anscnt] = i; &#125; for (int i = 1; i &lt;= anscnt; i++) printf(&quot;%d %-6d - %-6d = %3d\\n&quot;, i, p[ans[i] + 1], p[ans[i]], p[ans[i] + 1] - p[ans[i]]); printf(&quot;\\nres = %d\\n&quot;, res); return 0;&#125; 反素数 挖坑 一些性质 Trick 连续相邻质数的乘积增长的很快，前 9 个素数的乘积： 2×3×5×7×11×13×17×19×23=2_2309_28702\\times 3\\times 5 \\times 7\\times 11 \\times 13\\times 17\\times 19\\times 23=2\\_2309\\_28702×3×5×7×11×13×17×19×23=2_2309_2870 ，前 10 个素数相乘爆 int。前 15 个素数的乘积： 2×3×5×7×11×13×⋯×43×47=61_4889_7825_8849_14102\\times 3\\times 5 \\times 7\\times 11 \\times 13\\times \\cdots\\times 43\\times 47=61\\_4889\\_7825\\_8849\\_14102×3×5×7×11×13×⋯×43×47=61_4889_7825_8849_1410 ，前 16 个素数相乘爆 long long（922_3372_0368_5477_5807） 。关于阶乘的增长详见斯特林公式。 同理， lcm 的增长也很快。 题目 洛谷 P2043 质因子分解：n!n!n! 的质因子分解。①暴力法，②数论定理。 Sum of Consecutive Prime Numbers CF1444A Division Prime Distance 更强的伪素数——另一种素性测试 update 2022.2.12 这是一个垃圾方法 对部分卡迈克尔数判断时仍会出错。 这是一种小范围内（1亿内）适用的 概率性 素性测试！！！（由于我笔记本硬件问题，没有测更大范围的数） 对于较小的数直接打表判断。（较小的数：大于下面取的 a 的范围） 具体内容：在 2~300 内枚举 a，求 an−1 mod na^{n-1}\\bmod nan−1modn 的值，若不等于 1，则 n 必为合数，若全部通过，则 n 为素数。 即使用费马小定理进行的必要不充分测试。 定义下文的「a值」指：对于一个合数，首次得到 an−1 mod n≠1a^{n-1}\\bmod n \\ne 1an−1modn=1 时，a的值。 虽然费马小定理的逆定理并不成立，但我们还是可以用费马小定理来做素性测试。 对于一个数 n ，从 2 开始枚举 a，判断 an−1 mod na^{n-1}\\bmod nan−1modn 是否等于 1 。 下面的表中，给出了 14 到 1e8 内的 94238538 个合数，得到 an−1 mod n≠1a^{n-1}\\bmod n \\ne 1an−1modn=1 时 a 的值及其个数。个数小于 10 时给出了的具体值。 可以看到 0.9999781724118 的合数都倒在了 2 ，只有 82929001 挺到了 281。 显然这种写法卡迈克尔数是防不住的，而且好像少有特意卡这种写法？（有些黑红巨巨都不知道） 在 SP288 PON - Prime or Not 这道题中，我对 10000 内的数打表，然后只判断 a=2 时的值，居然也过了！！而且只用了 20ms，而这道题下用 miller-rabin 的最优解是 10ms。 最后：出题人不特意卡的话，选到 a 值较大的合数概率几乎为 0（密度实在太低了）。而这种写法又比 miller-rabin 更好写、更好记 。如果选取 a 的范围为 2 — 13 ，那么 1e8 内就还剩 113 个漏网之鱼。而且不比 miller-rabin 慢多少，所以可以放心冲一冲。 如果出题人要卡的话，比如选取 82929001 ，这个数在 a=281 时才能判断出来是合数，跑得就太慢了。那就老实写米勒拉宾吧（上文那个板子跑得飞快的！）。 update 2022/01/27 我发现使得 1 亿内的合数 n 得到 an−1 mod na^{n-1}\\bmod nan−1modn 的 a 都是质数。这对于更大范围的合数应该也是成立的。 namo，哪些质数能通过这种方法检验出一个合数是合数呢？有什么规律？ 100以内有25个质数，其中21个质数出现在下表中。 对于 a值 等于其最小质因子的合数 n，在枚举 a 时 an−1 mod na^{n-1}\\bmod nan−1modn 的值很有规律。其他合数则杂乱无章。 1e8 内打表得到的结果 all Composite = 94238538 MAX a = 281 a = 2 num[2] = 94236481 max number 100000000 a = 3 num[3] = 1572 max number 99898801 a = 5 num[5] = 228 max number 99971821 a = 7 num[7] = 82 max number 96904081 a = 11 num[11] = 32 max number 81954133 a = 13 num[13] = 30 max number 81638401 a = 17 num[17] = 14 max number 87318001 a = 19 num[19] = 16 max number 84311569 a = 23 num[23] = 2 1615681 9494101 a = 29 num[29] = 6 3581761 5444489 18307381 45890209 64774081 65241793 a = 31 num[31] = 13 max number 78091201 a = 37 num[37] = 7 294409 488881 1461241 8134561 36765901 38624041 48321001 a = 41 num[41] = 7 252601 410041 1909001 5148001 7519441 38151361 83966401 a = 43 num[43] = 10 max number 80282161 a = 53 num[53] = 4 2508013 4335241 17316001 99830641 a = 61 num[61] = 6 6189121 9439201 15247621 35703361 60957361 99036001 a = 67 num[67] = 1 10267951 a = 71 num[71] = 3 10024561 14676481 31405501 a = 73 num[73] = 2 14469841 26280073 a = 89 num[89] = 1 19384289 a = 97 num[97] = 2 23382529 50201089 a = 101 num[101] = 1 3828001 a = 103 num[103] = 1 90698401 a = 107 num[107] = 1 84350561 a = 109 num[109] = 4 6733693 37964809 62756641 96895441 a = 113 num[113] = 1 17098369 a = 139 num[139] = 1 79624621 a = 151 num[151] = 2 17236801 68154001 a = 157 num[157] = 1 53711113 a = 163 num[163] = 1 64377991 a = 181 num[181] = 1 92625121 a = 191 num[191] = 1 34657141 a = 193 num[193] = 1 79411201 a = 211 num[211] = 2 29111881 56052361 a = 281 num[281] = 1 82929001 代码 先用费马小定理做必要不充分测试，没通过测试的一定是合数。对于通过的数再和欧拉筛出的结果对拍。 #include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e8 + 10;int p[N], cnt;bool st[N];void getp(int n = 1e5)&#123; for (int i = 2; i &lt;= n; i++) &#123; if(!st[i]) p[++cnt] = i; for (int j = 1; 1ll * p[j] * i &lt;= n; j++) &#123; st[p[j] * i] = true; if(i % p[j] == 0) break; &#125; &#125;&#125;int qp(int a, int b, int p)&#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;signed main()&#123; getp(); int ok = 1; int x = 17; int all = 0, MAX = -1, num[20]; memset(num, 0, sizeof num); printf(&quot;begin--------------\\n&quot;); for (int j = 13; j &lt;= 100000000; j++) &#123; if(!st[j]) // 只对合数测试，因为质数一定能通过 continue; x = j; for (int i = 2; i &lt;= 300; i++) &#123; if (qp(i, x - 1, x) != 1) &#123; // printf(&quot;Not prime\\n&quot;); num[i]++; MAX = max(MAX, i); all++; // printf(&quot;%lld %lld\\n&quot;, i, x); ok = 0; if(i == 7) &#123; printf(&quot;%lld\\n&quot;, x); &#125; break; &#125; &#125; if(ok) // printf(&quot;Is prime\\n&quot;, x); if(st[x]) // 是合数，一个强大的伪素数 printf(&quot;111\\n&quot;); &#125; for (int i = 2; i &lt;= 13; i++) printf(&quot;cnt of %lld = %lld\\n&quot;, i, num[i]); printf(&quot;all = %lld MAX = %lld\\n&quot;, all, MAX); printf(&quot;over------------------\\n&quot;); return 0;&#125; 找一个数的规律的代码 #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll qp(ll a, ll b, ll p)&#123; ll ans = 1; while(b) &#123; if(b &amp; 1) ans = ans * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; ll a = 19, n = 84311569; for (int i = 1; i &lt;= 4000; i++) &#123; if((i - 1) % a == 0) puts(&quot;&quot;); ll ans = qp(i, n - 1, n); printf(&quot;%lld &quot;, ans); // if(ans != 1 &amp;&amp; i % a == 0) // printf(&quot;%d / %lld = %d &quot;, i, a, i / a); &#125;&#125; 1e8到1e9的测试 代码 先用费马小定理做必要不充分测试，没通过测试的一定是合数。对于通过的数再和 miller-rabin 的结果对拍。 #pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e8 + 10, L = 1e8 + 1, R = 1e9;int mul(int a, int b, int m)&#123; return static_cast&lt;__int128&gt;(a) * b % m;&#125;int power(int a, int b, int m)&#123; int res = 1 % m; for (; b; b &gt;&gt;= 1, a = mul(a, a, m)) if (b &amp; 1) res = mul(res, a, m); return res;&#125;bool isprime(int n)&#123; if (n &lt; 2) return false; static constexpr int A[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23&#125;; int s = __builtin_ctzll(n - 1); int d = (n - 1) &gt;&gt; s; for (auto a : A) &#123; if (a == n) return true; int x = power(a, d, n); if (x == 1 || x == n - 1) continue; bool ok = false; for (int i = 0; i &lt; s - 1; ++i) &#123; x = mul(x, x, n); if (x == n - 1) &#123; ok = true; break; &#125; &#125; if (!ok) return false; &#125; return true;&#125;int qp(int a, int b, int p)&#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;signed main()&#123; clock_t start_time = clock(); int x; int all = 0, MAX = -1, error = 0; map&lt;int, int&gt; num; printf(&quot;begin--------------\\n&quot;); for (int j = L; j &lt;= R; j++) &#123; int ok = 1; x = j; for (int i = 2; i &lt;= 500; i++) &#123; if (qp(i, x - 1, x) != 1) &#123; // printf(&quot;Not prime\\n&quot;); num[i]++; MAX = max(MAX, i); all++; ok = 0; break; &#125; &#125; if(ok) &#123; // printf(&quot;Is prime\\n&quot;, x); if(!isprime(x)) &#123; // 通过了上述测试的伪素数 printf(&quot;ERROR x = %lld\\n&quot;, x); error++; &#125; &#125; &#125; for (auto i : num) printf(&quot;cnt of %d = %d\\n&quot;, i.first, i.second); printf(&quot;all = %d error_Number = %d\\n&quot;, all, error); printf(&quot;over------------------\\n&quot;); clock_t end_time = clock(); cout &lt;&lt; &quot;The run time is: &quot; &lt;&lt; (double)(end_time - start_time) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl; return 0;&#125; 打表的结果 begin--------------ERROR x = 413138881cnt of 2 = 854910381cnt of 3 = 2753 cnt of 5 = 359 cnt of 7 = 102 cnt of 11 = 73 cnt of 13 = 45 cnt of 17 = 22 cnt of 19 = 31 cnt of 23 = 5 cnt of 29 = 13cnt of 31 = 17cnt of 37 = 12cnt of 41 = 9cnt of 43 = 6cnt of 47 = 4cnt of 53 = 4cnt of 59 = 1cnt of 61 = 5cnt of 67 = 1cnt of 71 = 4cnt of 73 = 2cnt of 83 = 1cnt of 89 = 2cnt of 97 = 3cnt of 103 = 2cnt of 109 = 4cnt of 113 = 1cnt of 127 = 2cnt of 131 = 5cnt of 137 = 2cnt of 149 = 1cnt of 151 = 3cnt of 157 = 4cnt of 163 = 3cnt of 179 = 1cnt of 181 = 2cnt of 193 = 3cnt of 199 = 3cnt of 211 = 1cnt of 229 = 3cnt of 239 = 2cnt of 241 = 2cnt of 251 = 1cnt of 257 = 2cnt of 263 = 2cnt of 271 = 2cnt of 277 = 1cnt of 281 = 1cnt of 307 = 3cnt of 311 = 1cnt of 331 = 1cnt of 337 = 1cnt of 367 = 1cnt of 373 = 1cnt of 401 = 2cnt of 421 = 1cnt of 461 = 1all = 854913920 error_Number = 1 413138881 = 617 * 661 * 1013over------------------The run time is: 8469.25s // 2.3525h 只有 413138881 出错，413138881 在 a = 617 时得到617413138881−1 mod 413138881=214939354617^{413138881 - 1}\\bmod 413138881=214939354617413138881−1mod413138881=214939354 。 413138881 = 617 ×\\times× 661 ×\\times× 1013，但其实 a 的值和其最小质因子并无必然关系。 结论 1e8 内 a 大于 13 的数有 113 个，1e8+1 到 1e9 a 大于 13 的数有 208 个。 a的范围取 2 到 13 足矣。 想卡的话还是很容易卡的。 但如果没有刻意卡，随机数据基本卡不住。效率不比 Miller-Rabin 慢，还好写很多。 （a的范围取大了就比 miller-rabin 慢了，看题目要求可适当调大范围） 1e8到2e9 1e8到2e9之间，a值大于13的合数有292个。 a值最大为 617，是 413138881 的最小质因子。 begin--------------ERROR x = 413138881 413138881 = 617 * 661 * 1013ERROR x = 1207252621 1207252621 = 613 * 919 * 2143ERROR x = 1299963601 1299963601 = 601 * 1201 * 1801ERROR x = 1540454761 1540454761 = 541 * 811 * 3511ERROR x = 1632785701 1632785701 = 547 * 1093 * 2731cnt of 2 = 1807533689cnt of 3 = 4249 cnt of 5 = 577cnt of 7 = 179cnt of 11 = 103cnt of 13 = 74cnt of 17 = 35cnt of 19 = 43cnt of 23 = 9cnt of 29 = 14cnt of 31 = 25cnt of 37 = 16cnt of 41 = 12cnt of 43 = 7cnt of 47 = 4cnt of 53 = 6cnt of 59 = 1cnt of 61 = 9cnt of 67 = 1cnt of 71 = 6cnt of 73 = 3cnt of 83 = 1cnt of 89 = 3cnt of 97 = 4cnt of 101 = 1cnt of 103 = 3cnt of 107 = 1cnt of 109 = 6cnt of 113 = 2cnt of 127 = 2cnt of 131 = 6cnt of 137 = 2cnt of 149 = 1cnt of 151 = 4cnt of 157 = 4cnt of 163 = 4cnt of 179 = 1cnt of 181 = 4cnt of 191 = 1cnt of 193 = 3cnt of 199 = 3cnt of 211 = 4cnt of 229 = 3cnt of 239 = 2cnt of 241 = 4cnt of 251 = 1cnt of 257 = 2cnt of 263 = 2cnt of 271 = 2cnt of 277 = 2cnt of 281 = 2cnt of 293 = 1cnt of 307 = 4cnt of 311 = 1cnt of 331 = 2cnt of 337 = 2cnt of 349 = 1cnt of 367 = 1cnt of 373 = 1cnt of 379 = 1cnt of 401 = 3cnt of 421 = 1cnt of 433 = 1cnt of 461 = 1cnt of 487 = 1all = 1807539163 error_Number = 5over------------------The run time is: 19206.8s // 5.35h","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"谷歌浏览器访问慢","slug":"else/工具/浏览器/谷歌浏览器访问慢","date":"2021-09-30T16:00:00.000Z","updated":"2021-11-25T10:39:14.855Z","comments":true,"path":"posts/1f6d5f9/","link":"","permalink":"http://xiaoke-jin.github.io/posts/1f6d5f9/","excerpt":"","text":"原文链接：一招解决 Chrome 打开网页速度巨慢的问题 今天偶然发现谷歌旗下的 Chrome 浏览器打开某些网页的时候速度慢的出奇。一经排查，排除了网络或者DNS解析慢的问题，初步锁定是 Chrome 内置的安全机制引起的 Bug。 由于你懂得原因，谷歌服务在墙内大多都是不可用的，而谷歌浏览器自带的网址安全检测功能由于网络不通，不断重试，则可能会导致浏览器打开部分网页时产生几秒的延迟。 解决方法很简单： 点击 Chrome 右上角的小图标，进入“设置” → “显示高级设置”； 找到“隐私设置”选项下的“保护您和您的设备不受危险网站的侵害” 去掉这个设置项前面的对勾，关闭浏览器重新打开，网页打开速度立马秒速全开！","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"浏览器","slug":"工具/浏览器","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"","slug":"读书笔记/初等数论及其应用/第九章 原根","date":"2021-09-27T09:38:22.996Z","updated":"2021-11-25T10:39:14.901Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/初等数论及其应用/第十章 原根与整数的阶的应用","date":"2021-09-27T09:38:22.996Z","updated":"2021-11-25T10:39:14.906Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第四章 同余","slug":"读书笔记/初等数论及其应用/第四章 同余","date":"2021-09-25T16:00:00.000Z","updated":"2021-11-25T10:39:14.905Z","comments":true,"path":"posts/570a5d3f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/570a5d3f/","excerpt":"","text":"概要 德国大数学家高斯发明了同余的语言，这使得我们差不多能像处理等式一样来处理整除关系。 在本章中， 我们将给出同余的基本性质，描述如何进行同余式的算术运算， 还将研究含有未知数的 同余方程，例如线性同余方程。 我们还将研究 线性同余方程组，它们来源于古代中国难题：求一个数，它被 3，5 和 7 除所得余数分别为 2，3 和 2。我们将学习如何运用著名的 中国剩余定理 来解像上面那样的线性同余方程组难题。 我们还将学习怎样解 多项式同余方程。最后，我们用同余的语言来介绍一种整数分解方法，即 波拉德 ρ\\rhoρ 方法 。 4.1 同余概述 定义：设 mmm 是正整数，若 a,ba,ba,b 是正整数，且 m∣(a−b)m|(a-b)m∣(a−b) ，则称 aaa 和 bbb 模 mmm 同余 ，记为 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 。若 m∤(a−b)m\\nmid (a-b)m∤(a−b) ，则记 a≢b( mod m)a\\not\\equiv b(\\bmod m)a≡b(modm) ，并称 aaa 模 mmm 不同余于 bbb 。并称整数 mmm 称为同余的模。 定理 4.1 定理 4 .1：若 aaa 和 bbb 是整数，则 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，当且仅当存在整数 kkk ，使得 a=b+kma=b+kma=b+km 。 证明：若 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，则 m∣(a−b)m|(a-b)m∣(a−b) 。这说明存在整数 kkk ，使得 km=a−bkm=a-bkm=a−b ，所以 a=b+kma=b+kma=b+km 。 反过来，若存在整数 kkk 使得 a=b+kma=b+kma=b+km ，则 km=a−bkm=a-bkm=a−b 。于是 m∣(a−b)m|(a-b)m∣(a−b) ，因而 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 。 定理 4.2 同余的性质 定理 4 .2：设 mmm 是正整数。模 mmm 的同余满足下面的性质 （i）自反性：若 aaa 是整数，则 a≡a( mod m)a\\equiv a(\\bmod m)a≡a(modm) 。 （ii）对称性：若 a,ba,ba,b 是整数，且 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，则 b≡a( mod m)b\\equiv a(\\bmod m)b≡a(modm) 。 （iii）传递性：若 a,b,ca,b,ca,b,c 是整数，且 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 和 b≡c( mod m)b\\equiv c(\\bmod m)b≡c(modm) ，则 a≡c( mod m)a\\equiv c(\\bmod m)a≡c(modm) 。 证明： （i）因为 m∣(a−a)m\\mid (a-a)m∣(a−a) ，所以 a≡a( mod m)a\\equiv a(\\bmod m)a≡a(modm) 。 （ii） （iii） 同余类 由定理 4.2 可见，整数的集合被分成 mmm 个不同的集合，这些集合称为 模 mmm 剩余类（同余类），每个同余类中的任意两个整数都是模 mmm 同余的。注意，当 m=2m=2m=2 时，整数被分成奇、偶两类。 设 mmm 是正整数，给定整数 aaa ，由带余除法有 a=bm+ra=bm+ra=bm+r ，其中 0≤r≤m−10\\le r\\le m-10≤r≤m−1 ，称 rrr 为 aaa 的模 mmm 最小非负剩余。类似的，当 mmm 不整除 aaa 时，称 rrr 为 aaa 的模 mmm 最小正剩余。 定理 4.3 定理 4.3：如 a, ba,\\ ba, b 为整数， mmm 为正整数，则 a≡b ( mod m)a\\equiv b\\ (\\bmod m)a≡b (modm) 当且仅当 a mod m=b mod ma\\bmod m=b\\bmod mamodm=bmodm 。 证明： 定理 4.4 见定理 4.6 见定理 4.6 定理 4.5 同余式除法 同余式不能随便做除法运算。 定理 4.5：若 a, b, c, ma,\\ b,\\ c,\\ ma, b, c, m 是整数， m&gt;0m&gt;0m&gt;0 ，d=(c, m)d=(c,\\ m)d=(c, m) ，且有 ac≡bc ( mod m)ac\\equiv bc\\ (\\bmod m)ac≡bc (modm) ，则 a≡b ( mod m/d)a\\equiv b\\ (\\bmod m/d)a≡b (modm/d) 。 证明：若 ac≡bc ( mod m)ac\\equiv bc\\ (\\bmod\\ m)ac≡bc (mod m) ，则 m∣(ac−bc)=c(a−b)m\\mid (ac-bc)=c(a-b)m∣(ac−bc)=c(a−b) 。所以，存在整数 kkk ，使得 c(a−b)=kmc(a-b)=kmc(a−b)=km 。两边同时除以 ddd ，得到 (c/d)(a−b)=k(m/d)(c/d)(a-b)=k(m/d)(c/d)(a−b)=k(m/d) 。因为 (m/d,c/d)=1(m/d,c/d)=1(m/d,c/d)=1 。所以根据引理 3.4 ，有 m/d∣(a−b)m/d\\mid (a-b)m/d∣(a−b) 。因此 a≡b ( mod m/d)a\\equiv b\\ (\\bmod m/d)a≡b (modm/d) 。 定理 4.6 同余式加减乘 定理 4.6：若 a, b, c, d, ma,\\ b,\\ c,\\ d,\\ ma, b, c, d, m 是整数， m&gt;0m&gt;0m&gt;0 ，a≡b ( mod m)a\\equiv b\\ (\\bmod m)a≡b (modm) ，且 c≡d ( mod m)c\\equiv d\\ (\\bmod m)c≡d (modm) ，则 （i）a+c≡b+d ( mod m)a+c\\equiv b+d\\ (\\bmod m)a+c≡b+d (modm) （ii）a−c≡b−d ( mod m)a-c\\equiv b-d\\ (\\bmod m)a−c≡b−d (modm) （iii）ac≡bd ( mod m)ac\\equiv bd\\ (\\bmod m)ac≡bd (modm) 证明： 引理 4.1 完全剩余系 由方程 a=bm+ra=bm+ra=bm+r 有 a≡r ( mod m)a\\equiv r\\ (\\bmod\\ m)a≡r (mod m) 。因此，每个整数都和 0,1,⋯ ,m−10,1,\\cdots,m-10,1,⋯,m−1 （也就是 aaa 被 mmm 除所得的余数）中的一个模 mmm 同余。因为 0,1,⋯ ,m−10,1,\\cdots,m-10,1,⋯,m−1 中的任何两个都不是模 mmm 同余的，所以需要 mmm 个整数使得每个整数每个整数都恰与此集合中的一个元素模 mmm 同余。 定义：一个 模 mmm 完全剩余系 是一个整数的集合，使得每个整数恰和此集合中的一个元素模 mmm 同余。 下面的引理帮助我们判定一个 mmm 元集合是否为模 mmm 的完全剩余系。 引理 4.1：mmm 个模 mmm 不同余的整数的集合是一个模 mmm 的完全剩余系。 证明： 定理 4.7 完全剩余系的扩展 定理 4.7：若 r1,r2,⋯ ,rmr_1,r_2,\\cdots,r_mr1​,r2​,⋯,rm​ 是一个模 mmm 的完全剩余系，且正整数 aaa 满足 (a,m)=1(a,m)=1(a,m)=1 ，则对任何整数 bbb ，ar1+b,ar2+b,⋯ ,arm+bar_1+b,ar_2+b,\\cdots,ar_m+bar1​+b,ar2​+b,⋯,arm​+b 都是模 mmm 的完全剩余系。 证明： 定理 4.8 同余式取幂 下面的定理表明同余式两边同时取相同的正整数幂仍保持同余。 定理 4.9 两个数关于不同模的同余式 下面的定理说明如何将两个数关于不同模的同余式结合起来。 定理 4.9： 推论 4.9.1 推论 4.9.1： 证明： 快速模指数运算（快速幂） 4.2 线性同余方程 \\qquad设 xxx 是未知整数，形如 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的同余式称为 一元线性同余方程 。在本节中，我们会看到研究这类同余方程与研究二元线性丢番图方程是类似的。（见 3.7节） \\qquad首先注意到，若 x=x0x=x_0x=x0​ 是同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的一个解，且 x0≡x1 ( mod m)x_0\\equiv x_1\\ (\\bmod\\ m)x0​≡x1​ (mod m) ，则 ax0≡ax1≡b ( mod m)ax_0\\equiv ax_1\\equiv b\\ (\\bmod\\ m)ax0​≡ax1​≡b (mod m) ，所以 也是一个解。因此，若一个模 mmm 同余类中的某个元素是解，则此同余类的所有元素都是解。于是，我们会问模 mmm 的 mmm 个同余类中有多少个是方程的解，这相当于问方程有多少个模 mmm 不同于的解。 定理 4.11 下面的定理告诉我们一元线性同余方程何时有解，在有解时方程有多少个模 mmm 不同余的解。 定理 4.11：设 a, b, ma,\\ b,\\ ma, b, m 是整数， m&gt;0, (a, m)=dm&gt;0,\\ (a,\\ m)=dm&gt;0, (a, m)=d 。若 d∤bd\\nmid bd∤b ，则 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 无解。若 d∣bd\\mid bd∣b ，则 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 恰有 个 ddd 模 mmm 不同余的解。 证明：由定理 4.1 ，线性同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 等价于二元线性丢番图方程 ax−my=bax-my=bax−my=b 。整数 xxx 是 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的解当且仅当存在整数 yyy 使得 ax−my=bax-my=bax−my=b 。 \\qquad由定理 3.23 可知，若 d∤bd\\nmid bd∤b ，则无解。而 d∤bd\\nmid bd∤b 时， 有无穷多解： x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t ， y=y0+(a/d)ty=y_0+(a/d)ty=y0​+(a/d)t 。其中 x=x0x=x_0x=x0​ 和 y=y0y=y_0y=y0​ 是方程的特解。上述 xxx 的值 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 是线性同余方程的解，有无穷多个这样的解。 \\qquad为确定有多少不同余的解，我们找来两个解 x1=x0+(m/d)t1x_1=x_0+(m/d)t_1x1​=x0​+(m/d)t1​ 和 x2=x0+(m/d)t2x_2=x_0+(m/d)t_2x2​=x0​+(m/d)t2​ 模 mmm 同余的条件。若这两个解同余，则 x0+(m/d)t1≡x0+(m/d)t2 ( mod m)x_0+(m/d)t_1\\equiv x_0+(m/d)t_2\\ (\\bmod\\ m)x0​+(m/d)t1​≡x0​+(m/d)t2​ (mod m) 。两边减去 x0x_0x0​ ，有 (m/d)t1≡(m/d)t2 ( mod m)(m/d)t_1\\equiv (m/d)t_2\\ (\\bmod\\ m)(m/d)t1​≡(m/d)t2​ (mod m) 。因为 (m/d)∣m(m/d)\\mid m(m/d)∣m ，所以 (m, m/d)=m/d(m,\\ m/d)=m/d(m, m/d)=m/d ，再由定理 4.5 ， t1≡t2 ( mod d)t_1\\equiv t_2\\ (\\bmod\\ d)t1​≡t2​ (mod d) 。这表明不同余的解的一个完全集合可以通过取 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 得到，其中 ttt 取遍模 ddd 的完全剩余系。这样的一个集合可由 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 给出，其中 t=0,1,2,⋯ ,d−1t=0,1,2,\\cdots,d-1t=0,1,2,⋯,d−1 。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 推论 4.11.16 推论 4.11.1：若 (a, m)=1(a,\\ m)=1(a, m)=1 ，则线性同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 有模 mmm 的唯一解。 证明： 模的逆 现在考虑特殊的同余方程 ax≡1 ( mod m)ax\\equiv 1\\ (\\bmod\\ m)ax≡1 (mod m) 。由定理 4.11 ，此方程有解当且仅当 (a, m)=1(a,\\ m)=1(a, m)=1 ，于是其所有的解都模 mmm 同余。 定义：给定整数 aaa ，且满足 (a, m)=1(a,\\ m)=1(a, m)=1 。称 ax≡1 ( mod m)ax\\equiv 1\\ (\\bmod\\ m)ax≡1 (mod m) 的一个解为 aaa 模 mmm 的逆。 当我们有 aaa 模 mmm 的一个逆时，可以用它来解形如 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的任何同余方程。为看清这一点，令 aˉ\\bar{a}aˉ 是 aaa 模 mmm 的一个逆。于是，若 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) ，则将同余方程两边同时乘以 aˉ\\bar{a}aˉ ，得到 aˉ(ax)≡aˉb ( mod m)\\bar{a}(ax)\\equiv \\bar{a}b\\ (\\bmod\\ m)aˉ(ax)≡aˉb (mod m) ，所以 x≡aˉb ( mod m)x\\equiv \\bar{a}b\\ (\\bmod\\ m)x≡aˉb (mod m) 。 定理 4.12 下面的定理告诉我们哪些整数是其自身模 ppp 的逆，其中 ppp 是素数。 定理 4.12：设 ppp 是素数。正整数 aaa 是其自身模 ppp 的逆当且仅当 a≡1 ( mod p)a\\equiv 1\\ (\\bmod\\ p)a≡1 (mod p) 或 a≡−1 ( mod p)a\\equiv -1\\ (\\bmod\\ p)a≡−1 (mod p) 。 证明：若 a≡1 ( mod p)a\\equiv 1\\ (\\bmod\\ p)a≡1 (mod p) 或 a≡−1 ( mod p)a\\equiv -1\\ (\\bmod\\ p)a≡−1 (mod p) ，则 a2≡1 ( mod p)a^2\\equiv 1\\ (\\bmod\\ p)a2≡1 (mod p) 。所以 aaa 是其自身模 ppp 的逆。 反过来，若 aaa 是其自身模 ppp 的逆，则 a2≡1 ( mod p)a^2\\equiv 1\\ (\\bmod\\ p)a2≡1 (mod p) 。因此， p∣(a2−1)p\\mid (a^2-1)p∣(a2−1) 。又因为 a2−1=(a−1)(a+1)a^2-1=(a-1)(a+1)a2−1=(a−1)(a+1) ，所以 p∣(a−1)p\\mid (a-1)p∣(a−1) 或 。因此， p∣(a−1)p\\mid (a-1)p∣(a−1) ，或者 p∣(a+1)p\\mid (a+1)p∣(a+1) 。 4.3 中国剩余定理 我们考虑仅有一个未知数但有不同模的同余方程组。这样的方程组来源于古代中国难题。 定理 4.13 中国剩余定理 定理 4.13（中国剩余定理）：设 m1,m2,⋯ ,mrm_1,m_2,\\cdots,m_rm1​,m2​,⋯,mr​ 是两两互素的正整数，则同余方程组 x≡a1 ( mod m1)x≡a2 ( mod m2)⋮x≡ar ( mod mr)\\begin{align*} x&amp;\\equiv a_1\\ (\\bmod\\ m_1)\\\\ x&amp;\\equiv a_2\\ (\\bmod\\ m_2)\\\\ &amp;\\vdots\\\\ x&amp;\\equiv a_r\\ (\\bmod\\ m_r)\\\\ \\end{align*} xxx​≡a1​ (mod m1​)≡a2​ (mod m2​)⋮≡ar​ (mod mr​)​ 有模 M=m1m2⋯mrM=m_1m_2\\cdots m_rM=m1​m2​⋯mr​ 的唯一解。 证明：首先，构造同余方程组的一个联立解。为此，令 Mk=M/mk=m1m2⋯mk−1mk+1⋯mrM_k=M/m_k=m_1m_2\\cdots m_{k-1}m_{k+1}\\cdots m_rMk​=M/mk​=m1​m2​⋯mk−1​mk+1​⋯mr​ ，得 (Mk,mk)=1(M_k,m_k)=1(Mk​,mk​)=1 。因此由定理 4.11，可求得 MkM_kMk​ 模 mkm_kmk​ 的一个逆 yky_kyk​ ，所以 Mkyk≡1 ( mod mk)M_ky_k\\equiv 1\\ (\\bmod\\ m_k)Mk​yk​≡1 (mod mk​) 。现在构造和 x=a1M1y1+a2M2y2+⋯+arMryrx=a_1M_1y_1+a_2M_2y_2+\\cdots+a_rM_ry_rx=a1​M1​y1​+a2​M2​y2​+⋯+ar​Mr​yr​ 。 整数 xxx 就是 rrr 个同余方程的联立解。要证明这一点，只需证明对于 k=1,2,⋯ ,rk=1,2,\\cdots,rk=1,2,⋯,r 有 x≡ak ( mod mk)x\\equiv a_k\\ (\\bmod\\ m_k)x≡ak​ (mod mk​) 。因为 j≠kj\\ne kj=k 时 mk∣Mjm_k\\mid M_jmk​∣Mj​ ，所以 Mj≡0 ( mod mk)M_j\\equiv 0\\ (\\bmod\\ m_k)Mj​≡0 (mod mk​) 。因此，在 xxx 的和式中，除了第 kkk 项之外的所有项都和 000 模 mkm_kmk​ 同余。从而 x≡akMkyk≡ak ( mod mk)x\\equiv a_kM_ky_k\\equiv a_k\\ (\\bmod\\ m_k)x≡ak​Mk​yk​≡ak​ (mod mk​) 。现在来证任意两个解都是模 MMM 同余的。设 x0x_0x0​ 和 x1x_1x1​ 都是同余方程组中 rrr 个方程的联立解。则对每个 kkk ，x0≡x1≡ak ( mod mk)x_0\\equiv x_1\\equiv a_k\\ (\\bmod\\ m_k)x0​≡x1​≡ak​ (mod mk​) ，由定理 4.9 可知， M∣(x0−x1)M\\mid (x_0-x_1)M∣(x0​−x1​) 。因此， x0≡x1 ( mod M)x_0\\equiv x_1\\ (\\bmod\\ M)x0​≡x1​ (mod M) 。这说明同余方程组的 rrr 个方程的联立解是模 MMM 唯一的。 4.4 求解多项式同余方程 4.5 线性同余方程组 定理 4.20 4.6 利用波拉德方法分解整数","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"题单汇总","slug":"题目/题单汇总","date":"2021-09-20T16:00:00.000Z","updated":"2022-02-27T14:11:07.882Z","comments":true,"path":"posts/53fb7dd2/","link":"","permalink":"http://xiaoke-jin.github.io/posts/53fb7dd2/","excerpt":"","text":"2021-09-21 ​ 题单汇总，整理中 Stop learning useless algorithms, go and solve some problems, learn how to use binary search. 如果要刷专题请在右上角搜索相应算法。 题单可以在洛谷、Vjudge 上找。 牛客题单：【新手上路】语法入门&amp;算法入门题单 牛客题单2：【算法进阶题单】DP、数据结构、图论、数学 CF 好题推荐 数学 数论 一些好玩的数学题 44题，难度较大 一些好玩的数论题 Part 1 50题，各个难度都有 一些好玩的数论题 Part 2 22题，难度较大 MGA初等数论 这个是在 Vjudge 上无意中看到的，当个乐子 组合数学 蒟蒻lndjy的基础组合数学题单 洒水车生成函数/计数练习 19 ~ 22 难度较大（这三个生成函数题单有较多重复，日后我刷完了再自己开一个题单doge 生成函数基础 难度较大 生成函数之 OGF &amp; EGF - 从入门到入土 难度较大 线性代数 【线性代数】线性代数基础题 难度较大 多项式 多项式全家桶 菜鸡 Karry5307 的多项式题单 1 群论 Burnside引理、Pólya定理 博弈论 https://vjudge.net/contest/299140#overview https://vjudge.net/contest/244011#overview 博弈论题目汇总 DP 【DP专辑】ACM动态规划总结 Codeforces DP细化分类专题——Vjudge 背包问题 线性DP 区间DP （个人题单 树形DP、换根树形DP （个人题单 状压DP （个人题单 数位DP DP优化 数据结构 智乃 前缀和与差分 ST表 并查集 单调栈、单调队列 树的基础 CMの树状数组 MKの线段树 这是一个相对简单的线段树题单 Limit の线段树题单 Part2 Part1 中的洛谷里的题，45题 Limit の线段树题单 Part1 CF和SPOJ上的题。题单描述里有对线段树的系统的分类，34题 莫队 分块 平衡树 树链剖分 可持久化 【数据结构】高级数据结构-1 ：useless。43题，难度较大（各种树 NOIP数据结构：useless。31题 图论 【图论】省选图论 最短路 最小生成树 二分图（二分图判定、匈牙利算法） 拓扑排序 差分约束 LCA 连通分量 欧拉回路与欧拉路径 网络流 2-SAT Prufer编码 字符串 菜鸡LCA的基础字符串（KMP&amp;ACAM） KMP 和 AC自动机 字符串从提高到省选#1 包含很多字符串算法 【字符串】后缀系列 后缀数组, 后缀自动机 搜索 贪心 计算几何","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"}]},{"title":"KMP","slug":"DS_Algorithm证明与讲解/字符串/KMP","date":"2021-09-20T16:00:00.000Z","updated":"2022-02-18T14:32:42.117Z","comments":true,"path":"posts/ad32db8f/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ad32db8f/","excerpt":"","text":"链接：KMP算法及其优化（超详解） 干货｜扩展kmp模板 题目 【模板】KMP字符串匹配 [BOI2009]Radio Transmission 无线传输 [NOI2014] 动物园 [HNOI2008]GT考试 [POI2006]OKR-Periods of Words","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"字符串哈希","slug":"DS_Algorithm证明与讲解/字符串/字符串哈希","date":"2021-09-20T16:00:00.000Z","updated":"2022-02-18T14:04:41.444Z","comments":true,"path":"posts/51e82117/","link":"","permalink":"http://xiaoke-jin.github.io/posts/51e82117/","excerpt":"","text":"算法｜哈希从入门到精通（造福入门选手！） 算法讲解｜hash进阶：使用字符串hash乱搞的姿势 三个卡哈希的题 https://darkbzoj.tk/problem/3097 https://darkbzoj.tk/problem/3098 https://darkbzoj.tk/problem/3099 生日悖论","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"离散数学 第二版 屈婉玲","slug":"读书笔记/离散数学及其应用/离散 屈婉玲","date":"2021-09-20T16:00:00.000Z","updated":"2021-11-25T10:39:14.887Z","comments":true,"path":"posts/94ee3211/","link":"","permalink":"http://xiaoke-jin.github.io/posts/94ee3211/","excerpt":"","text":"\\qquad取值1或0的变元称作命题变项，可以用命题变项表示真值可以变化的陈述句。用p、q、r等表示命题变项。 \\qquad定义：命题变项及其否定统称为文字。仅由有限个文字构成的析取式称作简单析取式，仅由有限个文字构成的合取式称作简单合取式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS题目","date":"2021-09-19T09:52:14.926Z","updated":"2022-02-02T03:54:55.992Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"剪枝与优化 洛谷 P1120 小木棍 洛谷 P1731 [NOI1999] 生日蛋糕","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-剪枝与优化","date":"2021-09-19T08:44:47.214Z","updated":"2021-11-25T10:39:14.885Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"常用优化方法 优化搜索顺序：大部分情况下，我们应该优先搜索分支较少的结点。 排除等效冗余： 比如按照组合数枚举而不是排列数。 可行性剪枝 最优性剪枝","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-IDAstar","date":"2021-09-19T08:44:30.425Z","updated":"2021-11-25T10:39:14.780Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-迭代加深","date":"2021-09-19T08:44:30.425Z","updated":"2021-11-25T10:39:14.783Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-双向DFS","date":"2021-09-19T08:44:30.425Z","updated":"2021-11-25T10:39:14.782Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"逻辑基础","slug":"读书笔记/离散数学及其应用/逻辑","date":"2021-09-11T16:00:00.000Z","updated":"2021-11-25T10:39:14.897Z","comments":true,"path":"posts/352a7c0a/","link":"","permalink":"http://xiaoke-jin.github.io/posts/352a7c0a/","excerpt":"","text":"必要条件：如果没有A，则必然没有B；如果有A而未必有B，则A就是B的必要条件，记作B→\\to→A，读作“B含于A”。数学上简单来说就是如果由结果B能推导出条件A，我们就说A是B的必要条件。 充分条件：如果A能推出B，那么A就是B的充分条件。其中A为B的子集，即属于A的一定属于B，而属于B的不一定属于A。 链接：“当且仅当”是充要条件吗？ 当且仅当 当且仅当 与 充要条件 这两个概念并没有天然的等价，否则也不会有那么多人提问类似的问题了。 当且仅当（ If and only if ），表示“在，并且仅在这些条件成立的时候”的缩写，缩写为 iff 用 P当且仅当Q 来举例。 当： 当Q成立时，P成立。 所以P的充分条件是Q 仅当： 仅当Q成立时，P才成立。也就是说，当Q不成立时，P也不成立。故其等价的 逆否命题 是，当P成立时，Q才成立。所以P的必要条件是Q 综合“当”和“仅当”，可得P的充要条件是Q。 结论: 当且仅当 等价于 充要条件 。 对 p→qp\\to qp→q 的理解 原文链接：[对 p→qp\\to qp→q 的理解]((3 封私信 / 18 条消息) “p仅当q”和“p蕴含q”有什么区别? - 知乎 (zhihu.com)) 在经典主义逻辑框架下， p→qp\\to qp→q 被称为「实质蕴含」，就是说，这句话 不应该 被解释成自然语言中的”如果 ppp，则 qqq “，而是应该解释成”如果 ppp 为真，那么 qqq 也为真“。因为 ppp 和 qqq 可以完全不相干。实质蕴含最让初学者糊涂的地方是，如果 ppp 为假时， p→qp\\to qp→q 居然必然为真。不要小看这点区别，这会引起很多的「反直觉」结论： 反直觉命题一： p→q∨q→pp\\to q\\lor q\\to pp→q∨q→p 这个在经典主义框架下是永真的，这个可以被误读成：世界上的所有东西都是相互关联的。 反直觉命题二： Pierce’s Law ((p→q)→p)→p((p\\to q)\\to p)\\to p((p→q)→p)→p 这个在经典主义框架下也是永真的，解释下试试看，如果一个蕴含式能蕴含它的前件，那么它的前件 p 就为真。请用「如果……，那么……」解释下试试看？ 反直觉命题三：著名的 Drinker’s Paradox，饮酒者悖论 ∃x∈P.D(x)→∀y∈P.D(x)\\exists x\\in P.D(x)\\to \\forall y\\in P.D(x)∃x∈P.D(x)→∀y∈P.D(x) 「如果一个酒吧里面存在一个饮酒者，”那么“ 酒吧里面所有的人都在饮酒。」这句话是不是很荒唐？我们之所以认为荒唐，正是因为我们把蕴含符号「错误解读」成为了”如果……，那么……“。 在经典主义逻辑框架下，「 p→qp\\to qp→q 等价于 ¬p∨q\\neg p\\lor q¬p∨q 」，可以解读为「要么条件 p 为假，要么结论 q 为真」，实际上也还是在解释「实质蕴含」。 当 ppp 为假时，蕴含关系始终是成立的。这是为了保证反证法（或者说逆否命题与原命题的等价性，即 p→qp\\to qp→q 与 ¬q→¬p\\neg q\\to \\neg p¬q→¬p 等价）成立而特别规定的。这常常被称为「假前件可以得出任意结论」。 逻辑学上，若p则q型的命题，等价于“非p或q”，其否定形式是“p且非q”。这在中学数学里虽然避而不讲，但是却经常被不加证明地使用，都用在哪了呢？用在反证法解题中了 。大家回忆一下，反证法为什么第一步要假设与结论相反的的结果，然后与条件结合起来导出矛盾?这其实就是在证明最初命题的否定“p且非q”是假命题，然后依据排中律，说明要证的命题为真。 这是一个老话题，却似乎常聊常新。原因还在于黑格尔那句老话，人是天生的形而上学家，他们直觉地太看重把事情“说通”，而其实把事情“做通”才是更重要的。说通，是语言逻辑的重任，但数理逻辑关心的却是做通。p-&gt;q，语言中是要用p得到q，数学中则不然，可能p根本不存在，根本不存在由p得到q的问题，但却要求p-&gt;q形式地存在。这时你不能从语言角度去纠结 p→qp\\to qp→q 究竟是什么意思，它没有什么意思，它就是数学上一种形式性的或构造性的要求，有了它推导或运算的过程才能进行，事情才能做通。实际上罗素在使用 实质蕴涵 一词来指这个数理逻辑中的所谓蕴涵时就已经制止了把它与自然语言中的蕴涵一词视作同义的想当然，罗素清楚指出这个所谓的蕴涵，其含义不是来自自然语言，而是由其规定的运算或赋值规则本身来定义，这些规则规定才是这个所谓蕴涵的实质，因此它叫做实质蕴涵。 这么定义只是为了 保证前者的「内涵」比后者小 ，集合包含关系的定义就是用蕴含定义的。蕴含关系表示的就是这么一种强弱关系，真真假假的根本不重要，他本身就和若则的语义不相同，其他的解释多少都是别扭的。 对于集合A，B，A ⊆ B 当且仅当∀x ∈ A，x ∈ B(或者说命题P(x):「若x属于A，则x属于B」对于任意x为真)。 那么问题来了，我们应该都承认对于任意集合S，∅ ⊆ S。这意味着命题「若x属于∅，则x属于S」对于任意x为真。然而没有任何x是属于空集的，所以前提(x属于∅)就一定是假的，而原命题(等价于∅ ⊆ S)却总是真的。也就是题主问的蕴含关系 本质上题主说的这种蕴含关系就是一种数学上的约定，方便我们处理类似∅ ⊆ S的问题。就像0这个数字一样，最开始是不显然的，我们完全可以不要它就可以数数(用自然数)，我们引入0只是为了方便数学的发展。这个问题也是一样，只能努力试着去接受大家约定俗成的东西，至少经验上证明它是很好用的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"Java概观","slug":"读书笔记/最近/Java/Java基础","date":"2021-09-09T16:00:00.000Z","updated":"2022-03-31T05:39:52.160Z","comments":true,"path":"posts/f7ede91d/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f7ede91d/","excerpt":"","text":"Java平台 Java平台主要由两部分组成：Java虚拟机、Java应用程序接口（API） Java虚拟机 Java虚拟机 是 Java的核心和基础，是Java编译器和操作平台之间的虚拟处理机，利用软件方法实现的抽象的计算机，它有自己完善的架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机执行的是Java的字节码程序，这个字节码可能来自本地计算机，也可能来自网络。Java虚拟机通过类装载，字节码验证，最后执行。 Java的跨平台性都是由 Java虚拟机来实现的。 Java API Java API 是Java的应用程序编程基础，是Java标准类的集合，程序员在开发程序的时候，可以直接调用这些现成的类。 Java程序若想运行，必须提供Java的运行环境 JRE（JRE提供了运行Java程序所必需的类库）、Java API、Java虚拟机及其一些必要的组件。 如果进行Java程序开发，我们要有 Java开发程序包 JDK，这个程序包，包含了JRE 、API 和进行Java程序开发的编译和调试工具。最新版的 JDK11将 JRE和 JDK整合在一起，在安装目录下只有 JDK。 三种Java平台 不同的 Java应用程序，需要不同的 Java平台，Java平台版本主要有三种：Java SE、EE、ME。 Java SE提供了标准的JDK开发平台，主要开发 Java桌面应用程序 ，是我们这门课使用的开发平台； Java EE是构建 企业级 的服务应用，包含了 Java SE平台，并增加了附加类库，以支持目录管理、交易管理和企业级消息处理等功能； Java ME用于 嵌入式 的消费产品开发。 要想进行 Java的开发，需要先安装Java开发程序包 JDK； Java程序开发 java 核心 ： 万物皆类 。 Java程序的开发流程 编辑源文件：编辑 .java 文件 编译源文件，生成字节码文件：javac XXX.java ，生成 XXX.class 字节码文件并保存在源文件所在目录下。 运行字节代码：java XXX 例子 对于源文件 Hello.java （F:\\Codefield\\LearnJava\\src\\Hello.java ） public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 运行包内的 java 文件、关于 CLASSPATH ： 使用java命令运行class文件提示“错误：找不到或无法加载主类“的问题分析","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"}]},{"title":"筛法","slug":"DS_Algorithm证明与讲解/数学/数论/整除/筛法","date":"2021-09-02T16:00:00.000Z","updated":"2022-02-07T11:37:25.658Z","comments":true,"path":"posts/ba9781b9/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ba9781b9/","excerpt":"","text":"埃氏筛 O(nlog⁡log⁡n)O(n\\log\\log n)O(nloglogn) for(int i = 2; i &lt;= n; i++)&#123; if(is_prime[i]) continue; primes[++cnt] = i; for(int j = i * i; j &lt;= n; j += i)&#123; is_prime[j] = true; &#125;&#125; 欧拉筛 也称线性筛，O(n)O(n)O(n) 的复杂度筛出 1~n 的所有素数。1e8内共 576_1455个素数。 在1e6时与埃氏筛差不多，在1e7时快一倍。 基本思想 每个合数被其最小质因子筛掉。 线性复杂度证明 每个合数都会被筛掉； 设合数 xxx 的最小质因子为 ppp ，当 iii 遍历到 x/px/px/p 时， xxx 被筛掉。 每个合数只会被筛掉一次； 任意合数 xxx 可被唯一地表示为 x=p×ix=p\\times ix=p×i ，ppp 是 xxx 的最小质因子，iii 是循环变量。 正确性证明 如何保证当前质数是被筛掉的数的最小质因子 for j=1 to n （从小到大枚举质数） 当第一次得到 i mod p[j]=0i\\bmod p[j] = 0imodp[j]=0 ，p[j]p[j]p[j] 是 p[j]∗ip[j] * ip[j]∗i 和 iii 的最小质因子。 代码实现 int primes[N], cnt;bool st[N];for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[++cnt] = i; for(int j = 1; primes[j] &lt;= n / i; j++)&#123; // 如有可能溢出,需要使用除法 /*不需要添加条件 j &lt;= cnt; primes[j] &lt;= i 1.若 i为合数,则 primes[]中，一定包含了其最小质因数,会在 if处结束。 2.若 i为质数，则 i已经加入primes[]中,会在 if处结束。 */ st[primes[j] * i] = true; if(i % primes[j] == 0) break; &#125;&#125; 其他应用 欧拉筛求积性函数 此处不展开讲，详见：链接 。 欧拉筛记录最小质因子 遍历质数可以加速质因子分解。 如果记录一下某个数的最小质因子，则可以更快地进行质因子分解。 更强的素数筛 Wheel Factorization 能在短时间内筛到 10910^9109 。运用了类似分块的思想 更快的质数筛: Wheel Factorization 、 Leasier 的博客 。 题目 SP6488 PRIMES2 - Printing some primes (Hard)：Wheel Factorization。 SP6489 KPRIMES2 - Finding the Kth Prime (Hard)：SP6488 加强版。 题目 由于筛法只是求解问题的第一步，所以此处不再放置题目。 还是放两道吧 AcWing 868. 筛质数：欧拉筛板题 Forsaken喜欢数论 洛谷 P1835 素数密度：区间筛 漂亮数","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论分块","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/数论分块","date":"2021-09-02T16:00:00.000Z","updated":"2022-02-18T14:02:58.107Z","comments":true,"path":"posts/4a670895/","link":"","permalink":"http://xiaoke-jin.github.io/posts/4a670895/","excerpt":"","text":"链接： OI-Wiki 数论分块 ， 作者@Luckyblock ， ThinkofBlank 的博客 ， 新数论分块的推广及其复杂度证明 。算法讲解｜莫比乌斯反演的前置知识——数论分块 数论分块可以快速计算一些含有除法向下取整的和式（即形如 ∑i=1nf(i)g(⌊ni⌋)\\sum_{i=1}^nf(i)g(\\left\\lfloor\\dfrac ni\\right\\rfloor)∑i=1n​f(i)g(⌊in​⌋) 的和式）。当可以在 O(1)O(1)O(1) 内计算 f(r)−f(l)f(r)-f(l)f(r)−f(l) 或已经预处理出 fff 的前缀和时，数论分块就可以在 O(n)O(\\sqrt n)O(n​) 的时间内计算上述和式的值。 它主要利用了富比尼定理（Fubini’s theorem），将 ⌊ni⌋\\left\\lfloor\\dfrac ni\\right\\rfloor⌊in​⌋ 相同的数打包同时计算。 富比尼定理 又称“算两次”，以意大利数学家圭多 · 富比尼（Guido Fubini）命名。 富比尼定理的积分形式：只要二重积分 ∫∫∣f(x,y)∣dxdy\\int\\int |f(x,y)|dxdy∫∫∣f(x,y)∣dxdy 有界，则可以逐次计算二重积分，并且可以交换逐次积分的顺序。 积分号也是特殊的求和号，因此在一般求和中，富比尼定理往往呈现为更换计数顺序，即交换两个求和号。 组合数学中的富比尼定理表现为，用两种不同的方法计算同一个量，从而建立相等关系。 定理： ∀a,b,c∈Z,⌊abc⌋=⌊⌊ab⌋c⌋\\forall a,b,c\\in\\mathbb{Z},\\left\\lfloor\\dfrac{a}{bc}\\right\\rfloor=\\left\\lfloor \\dfrac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor∀a,b,c∈Z,⌊bca​⌋=⌊c⌊ba​⌋​⌋ 证明： ab=⌊ab⌋+r(0≤r&lt;1) ⌊abc⌋=⌊ab⋅1c⌋=⌊1c(⌊ab⌋+r)⌋=⌊⌊ab⌋c+rc⌋=⌊⌊ab⌋c⌋ ■\\begin{aligned} &amp;\\frac{a}{b}=\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r(0\\leq r&lt;1)\\ \\\\ &amp;\\left\\lfloor\\frac{a}{bc}\\right\\rfloor =\\left\\lfloor\\frac{a}{b}\\cdot\\frac{1}{c}\\right\\rfloor =\\left\\lfloor \\frac{1}{c}\\left(\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r\\right)\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c} +\\frac{r}{c}\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor\\ &amp;&amp;\\blacksquare \\end{aligned} ​ba​=⌊ba​⌋+r(0≤r&lt;1) ⌊bca​⌋=⌊ba​⋅c1​⌋=⌊c1​(⌊ba​⌋+r)⌋=⌊c⌊ba​⌋​+cr​⌋=⌊c⌊ba​⌋​⌋ ​​■​ 题目 kb的数列分块&amp;整除分块入门题单 UVA11526 H(n) P2261 余数求和 P2424 约数和","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"欧拉筛、欧拉函数","slug":"DS_Algorithm证明与讲解/数学/数论/积性函数到杜教筛/欧拉函数","date":"2021-09-02T16:00:00.000Z","updated":"2022-02-18T14:03:12.576Z","comments":true,"path":"posts/37843ca4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/37843ca4/","excerpt":"","text":"数论｜欧拉函数的几个性质及证明 欧拉函数 定义：设 nnn 是一个正整数，欧拉函数 φ(n)\\varphi(n)φ(n) 定义为不超过 nnn 且与 nnn 互素的正整数的个数。 欧拉函数的性质 具体证明请参考《初等数论及其应用》第6，7章。 欧拉函数是积性函数。 int 范围的数 nnn ， φ(n)\\varphi(n)φ(n) 最大为 1600。 n=∑d∣nφ(d)n = \\sum_{d \\mid n}{\\varphi(d)}n=∑d∣n​φ(d)。 若 n=pkn = p^kn=pk，其中 ppp 是质数，那么 φ(n)=pk−pk−1\\varphi(n) = p^k - p^{k - 1}φ(n)=pk−pk−1。 由唯一分解定理，设 n=∏i=1spikin = \\prod_{i=1}^{s}p_i^{k_i}n=∏i=1s​piki​​，其中 pip_ipi​ 是质数，有 φ(n)=n×∏i=1spi−1pi\\varphi(n) = n \\times \\prod_{i = 1}^s{\\dfrac{p_i - 1}{p_i}}φ(n)=n×∏i=1s​pi​pi​−1​。 ∀n, n&gt;1\\forall n,\\ n&gt;1∀n, n&gt;1 ，1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 中与 nnn 互质的数的和为 n×φ(n)2n\\times \\dfrac{\\varphi(n)}{2}n×2φ(n)​ 。 当 n&gt;2n&gt;2n&gt;2 时， φ(n)\\varphi(n)φ(n) 为偶数。 ∑i=1n∑j=1n[gcd⁡(i,j)=1]=(2∑i=1nφ(i))−1\\displaystyle\\sum_{i=1}^{n}\\sum_{j=1}^{n}[\\gcd(i,j)=1]= \\big( 2\\sum_{i=1}^{n}\\varphi(i)\\big) -1i=1∑n​j=1∑n​[gcd(i,j)=1]=(2i=1∑n​φ(i))−1 。 证明：由 ∑i=1n∑j=1nf(i,j)=2∑i=1n∑j=1if(i,j)−∑i=1nf(i,i)\\displaystyle\\sum_{i=1}^n\\sum_{j=1}^nf(i,j)=2\\sum_{i=1}^n\\sum_{j=1}^if(i,j)-\\sum_{i=1}^nf(i,i)i=1∑n​j=1∑n​f(i,j)=2i=1∑n​j=1∑i​f(i,j)−i=1∑n​f(i,i) ， ∑i=1n∑j=1i[gcd⁡(i,j)=1]=∑i=1nφ(i)\\displaystyle\\sum_{i=1}^n\\sum_{j=1}^i[\\gcd(i, j)=1]=\\sum_{i=1}^n\\varphi(i)i=1∑n​j=1∑i​[gcd(i,j)=1]=i=1∑n​φ(i) 即可得出。 若 i,ji,ji,j 不互质，则 φ(i×j)=φ(i)φ(j)gcd⁡(i,j)φ(gcd⁡(i,j))\\varphi(i\\times j)=\\dfrac{\\varphi(i)\\varphi(j)\\gcd(i, j)}{\\varphi(\\gcd(i,j))}φ(i×j)=φ(gcd(i,j))φ(i)φ(j)gcd(i,j)​ 。 设 n=i×dkn=i\\times d^kn=i×dk ，若 k&gt;2k&gt;2k&gt;2 ，则 φ(n)=d×φ(nd)\\varphi(n)=d\\times \\varphi(\\dfrac{n}{d})φ(n)=d×φ(dn​) 。 若 互质，则 φ(ijdk+2)=dkφ(ijd2)=dk×φ(id)×φ(jd)φ(d)\\varphi(ijd^{k+2})=d^k\\varphi(ijd^2)=d^k\\times \\dfrac{\\varphi(id)\\times\\varphi(jd)}{\\varphi(d)}φ(ijdk+2)=dkφ(ijd2)=dk×φ(d)φ(id)×φ(jd)​ 。 分解质因数求欧拉函数 如果只要求一个数的欧拉函数值，那么直接根据定义质因数分解的同时求就好了。这个过程可以用 Pollard Rho 算法优化。 int div(int n)&#123; int ans = n; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; while(x % i == 0) x /= i; &#125; ans -= ans / i; &#125; if(n &gt; 1) ans -= ans / n; return ans;&#125; 筛法求欧拉函数 注意到在线性筛中，每一个合数都是被最小的质因子筛掉。比如设 p1p_1p1​ 是 nnn 的最小质因子，n′=np1n&#x27; = \\dfrac{n}{p_1}n′=p1​n​，那么线性筛的过程中 nnn 通过 n′×p1n&#x27; \\times p_1n′×p1​ 筛掉。 观察线性筛的过程，我们还需要处理两个部分，下面对 n′ mod p1n&#x27; \\bmod p_1n′modp1​ 分情况讨论。 如果 n′ mod p1=0n&#x27; \\bmod p_1 = 0n′modp1​=0，那么 n′n&#x27;n′ 包含了 nnn 的所有质因子。 φ(n)=n×∏i=1spi−1pi=p1×n′×∏i=1spi−1pi=p1×φ(n′)\\begin{aligned} \\varphi(n) &amp; = n \\times \\prod_{i = 1}^s{\\frac{p_i - 1}{p_i}} \\\\ &amp; = p_1 \\times n&#x27; \\times \\prod_{i = 1}^s{\\frac{p_i - 1}{p_i}} \\\\ &amp; = p_1 \\times \\varphi(n&#x27;) \\end{aligned} φ(n)​=n×i=1∏s​pi​pi​−1​=p1​×n′×i=1∏s​pi​pi​−1​=p1​×φ(n′)​ 那如果 n′ mod p1≠0n&#x27; \\bmod p_1 \\neq 0n′modp1​=0 呢，这时 n′n&#x27;n′ 和 p1p_1p1​ 是互质的，因为欧拉函数是乘性函数，我们有： φ(n)=φ(p1)×φ(n′)=(p1−1)×φ(n′)\\begin{aligned} \\varphi(n) &amp; = \\varphi(p_1) \\times \\varphi(n&#x27;) \\\\\\\\ &amp; = (p_1 - 1) \\times \\varphi(n&#x27;) \\end{aligned} φ(n)​=φ(p1​)×φ(n′)=(p1​−1)×φ(n′)​ // C++ Versionvoid pre() &#123;// 初始化 memset(is_prime, 0, sizeof(is_prime)); int cnt = 0; phi[1] = 1; int n = 5000000; for (int i = 2; i &lt;= n; i++) &#123; if (!is_prime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; i * prime[j] &lt;= n; j++) &#123; is_prime[i * prime[j]] = 1; if (i % prime[j]) phi[i * prime[j]] = phi[i] * phi[prime[j]]; else &#123; // i % p == 0 phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; &#125; &#125;&#125; 欧拉反演 链接： 欧拉反演 。 但是注意，如果 gcd⁡(x,y)\\gcd(x,y)gcd(x,y) 出现在分母这种不正常的位置，就不能用那个神奇的欧拉反演，而应该用常规方法。 题目 洛谷题单：欧拉函数与欧拉定理 [SDOI2008] 仪仗队 三维版本：SP7001 VLATTICE - Visible Lattice Points [SDOI2012] Longge 的问题 ：题解 。 [SDOI2015]约数个数和 ：题解 。性质： d(ij)=∑x∣i∑y∣j[gcd(x,y)=1]\\displaystyle d(ij)=\\sum_{x\\mid i}\\sum_{y\\mid j}[gcd(x,y)=1]d(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1] 。 P2350 [HAOI2012]外星人 ：题解 。性质：由质因子分解式计算 φ(n)\\varphi(n)φ(n) 。 P2568 GCD ：题解 。性质：1~n 中互质的数对。推荐用莫反得出的更一般的结果，时间复杂度也没有高很多，即这道题 P2257 YY的GCD 。这两道题几乎完全一样，但第二道需要进一步优化。 SP5971 LCM Sum ：题解 。性质：1~n 中与 n 互质的数的和。最后可以用狄利克雷前缀和。（也可用莫反嗯推（id∗μ=φid*\\mu=\\varphiid∗μ=φ）） P5091 【模板】扩展欧拉定理","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"BFS-A*算法证明与详解","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS A-star","date":"2021-09-01T16:00:00.000Z","updated":"2021-11-25T10:39:14.878Z","comments":true,"path":"posts/8096044c/","link":"","permalink":"http://xiaoke-jin.github.io/posts/8096044c/","excerpt":"","text":"写的好垃圾，，，什么时候觉得满意了就删掉，，， ​ 符号说明 g(state)g(state)g(state) ：从初态 st 到当前状态 state 的当前距离；（不一定最短） g∗(state)g^*(state)g∗(state)：从初态 st 到当前状态的实际最小距离； h(state)h(state)h(state) ：从当前状态 state 到终点的估价距离； h∗(state)h^*(state)h∗(state) ：从当前状态 state 到终点的真实距离； f(state)=g(state)+h(state)f(state)=g(state)+h(state)f(state)=g(state)+h(state) ，从初始状态出发经过状态 state 再到达终点的最小代价预估； open list：存储可到达的状态，close list：存储已到达的状态； 估价距离与真实距离： h(state)≤h∗(state)h(state)\\le h^*(state)h(state)≤h∗(state) ； 一旦估价函数确定，则对任意状态 state 的 h(state)h(state)h(state) 就确定了，随着搜索过程变化的是 g(state)g(state)g(state) ，显然，当 g∗(state)=g(state)g^*(state)=g(state)g∗(state)=g(state) 时，g(state)g(state)g(state) 不会再被更新； A* 应用场景 状态空间非常大，普通BFS无脑暴搜则时间复杂度无法接受。若空间比较小不适用，因为使用了优先队列，加入和取出状态的时间复杂度是 O(log⁡n)O(\\log{n})O(logn) 。 有解（无解时，仍然会把所有空间搜索，会比一般的BFS慢，因为优先队列的操作是 log⁡n\\log nlogn 的） 边权非负，如果是负数，那么终点的估值有可能是负无穷，终点可能会直接出堆。 A* 算法流程 while(q.size()) 小根堆 // 谁的d[u]+f[u]更小 谁先出队列 t ← 优先队列的队头 当终点第一次出队时 break ; // 终点第一次出队，到终点距离最小 从该状态向周围状态扩展： if state 未遍历过 || g(state) 可松弛 （松弛时使用 g() 而不是 f() 入队 A*只能保证终点出队时到终点距离最小，不能保证其他点，因为估价距离是相对于终点而言的。 A* 不对状态判重 结点可能会被重复遍历。 当某状态 state 的 d+fd+fd+f 较短时，从该状态出发未必能找到最短路，但是从 state 出发遍历到的点可能是最短路上的点，在未来会再次被访问。 只要搜到的状态 state 未访问过 或 g(state)g(state)g(state) 可松弛 ，就要加入优先队列。 A* 算法证明 设最短路径 Pst−end=start(v0)→v1→v2→⋯→end(vm)P_{st-end}=start(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=start(v0​)→v1​→v2​→⋯→end(vm​) 。 ​ 对于路径上的任意一点 vkv_kvk​，1≤k≤m1\\le k\\le m1≤k≤m ，当其前驱点出堆后，使用前驱点更新 g(k)g(k)g(k)，才能得到 g(k)=g∗(k)g(k)=g^*(k)g(k)=g∗(k) 且 vkv_kvk​ 一定在堆中（被更新或刚加入）且 g∗(k)+h(k)≤g∗(k)+h∗(k)=g∗(end)g^*(k)+h(k)\\le g^*(k)+h^*(k)=g^*(end)g∗(k)+h(k)≤g∗(k)+h∗(k)=g∗(end) 。 ​ 显然，在未取到 g∗(end)g^*(end)g∗(end) 时，end(vm)end(v_m)end(vm​) 一定不是按照最短路一步步更新得到的，即从 start(v0)start(v_0)start(v0​) 开始的最短路尚未走完，则「堆中一定存在最短路径上的某点」。 f()≤g∗(end)f()\\le g^*(end)f()≤g∗(end) 的点未必在最短路上，最短路上的点一定满足 f()≤g∗(end)f()\\le g^*(end)f()≤g∗(end) 。 每次出堆的状态有两种： 若是非最短路上的点，一定会在搜索到 end(vm)end(v_m)end(vm​) 或搜到 end(vm)end(v_m)end(vm​) 之前，得到某个状态 y （包括终点）的 f(y)&gt;g∗(end)f(y)&gt;g^*(end)f(y)&gt;g∗(end)，此时堆中一定存在最短路径上的点。然后会从另一个 f()f()f() 最小的点出发。 若选取到最短路上的点，则离终点更近一步。最终搜到终点使得 g(end)=g∗(end)g(end)=g^*(end)g(end)=g∗(end) 。搜到终点后，堆中可能还会有 f()f()f() 更小的点存在，但这些点向外扩展时都不再改变到 g(end)g(end)g(end) 。 最终 end(vm)end(v_m)end(vm​) 第一次出堆时，即得到最短路。 若最短路径有多条，同理，结论不变。 反证法证明：终点第一次出队列即最优解 1 假设终点第一次出队时不是最优 说明按当前路径得到的 g(终点) 一定严格大于从起点到终点的最小距离 g*(终点) 则说明当前队列中存在点 u 属于最短路径 g(终点) &gt; g*(终点) = g(u) + h*(u) &gt;= g(u) + h(u) 即队列中存在比 g(终点 ) 小的值 2 但我们维护的是一个小根堆，没有比g(队头终点)小的g(u)+h(u)，产生矛盾 证毕 如果当前状态 x 不是最短路上的节点，那么即使 f(x)f(x)f(x) 当前最小，从 x 向外搜索一定会在搜索到 end(vm)end(v_m)end(vm​) 或搜到 end(vm)end(v_m)end(vm​) 之前，得到某个状态 y 的 f(y)&gt;g∗(end)f(y)&gt;g^*(end)f(y)&gt;g∗(end)。 A* 优势 摘抄自《算法竞赛进阶指南》 普通优先队列BFS算法维护了一个优先队列（二叉堆），不断从堆中取出“当前代价最小”的状态（堆顶）进行扩展。每个状态第一次从堆中取出来时，就得到了从初态到该状态的最小代价。 如果给定一个”目标状态”，需要求出从初态到目标状态的最小代价，那么优先队列BFS的这个“优先策略”显然是 不完善 的。一个状态的当前代价最小，只能说明从初态到该状态的代价很小，而在未来的搜索中，从该状态到目标状态的可能会花费很大的代价。另外一些状态虽然当前代价略大，但是未来到目标状态的代价可能会很小，于是从起始状态到目标状态的总代价反而更优。 从 g+hg+hg+h 最短的状态出发未必能搜到最短距离，但概率一定会更大，这样就减少了对 g+hg+hg+h 较大的点的搜索，使得只搜索一部分点就可以保证搜到最短路，使运行效率大大提升。 像这样由估价函数引导的、能优先选择一些点的搜索方式称为启发式搜索。 A* 常见估价函数 在可上下左右四个方向扩展的平面图，使用曼哈顿距离作为估价函数。 欧拉距离 严谨证明 链接：A*算法证明与详解 算法本身性质一：每次队头的状态是 f(n)=g(n)+h(n)f(n)=g(n)+h(n)f(n)=g(n)+h(n) 最小的状态。而且 open list上任一具有 f(n)&lt;f∗(end)f(n)&lt;f^*(end)f(n)&lt;f∗(end) 的状态 n ，一定会在 end 出队前出队并进行扩展 。（最短路径上的点一定会在终点出队前出队） 算法本身性质二：h(n)≤h∗(n)h(n)\\le h^*(n)h(n)≤h∗(n)，预估代价小于等于实际最小代价。 首先证明：如果有解，那么算法一定可以找到终点。 有限图：边、点有限的图，无限图：边、点无限的图。 定理一：对有限图，如果从初始节点 st 到目标节点 end 有路径存在，则A*算法一定成功结束。 首先证明算法必定结束。由于搜索图为有限图，如果算法能找到解，则会成功结束；如果算法找不到解，那么必然会因为 open list 为空而结束。因此A*算法必然会结束。 然后证明算法一定会成功结束。由于至少存在一条由初始点到目标点的路径，设此路径为 Pst−end=st(v0)→v1→v2→⋯→end(vm)P_{st-end}=st(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=st(v0​)→v1​→v2​→⋯→end(vm​) 。 对于无限图，略。（算法题中都是有限图） 再证明：如果有解，算法找的解一定是最优解 。 我们利用反证法进行证明： 假设A*算法求出的不是最优解，那么我们通过A*算法寻到了一条从 st 到 end 的路径 PA∗P_{A*}PA∗​ ，而这条路径并不是最短路径。 那么存在最短路径 Pst−endP_{st-end}Pst−end​ ，有 ∣Pst−end∣&lt;∣PA∗∣|P_{st-end}|&lt;|P_{A*}|∣Pst−end​∣&lt;∣PA∗​∣。 设最短路径 Pst−end=st(v0)→v1→v2→⋯→end(vm)P_{st-end}=st(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=st(v0​)→v1​→v2​→⋯→end(vm​) 。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS-最小步数模型","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS-最小步数模型","date":"2021-09-01T16:00:00.000Z","updated":"2021-11-25T10:39:14.880Z","comments":true,"path":"posts/5a386d8/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5a386d8/","excerpt":"","text":"八数码 判断是否有解 链接：八数码问题有解的条件及其推广 将矩阵从上到下从左到右的顺序分布成一个数列，并去掉空格，例如： 2 8 3 (0为空格) 分布成数列后： 1 0 4 2 8 3 1 4 7 6 5 7 6 5 如果此 初始状态的数列(矩阵) 与 目标状态的数列(矩阵) 的 逆序对数 的 奇偶性相同 ，则此问题有解。 必要性证明：若有解，逆序对数奇偶性一定相同；反之一定不同。 充分性证明：若逆序对数奇偶性相同，一定有解；反之一定无解。 状态存储 判重 康托展开 unordered_map","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS双向广搜","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS双向广搜","date":"2021-09-01T16:00:00.000Z","updated":"2021-11-25T10:39:14.881Z","comments":true,"path":"posts/5dc538ff/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5dc538ff/","excerpt":"","text":"应用场景 最小步数模型","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"sublime配置","slug":"else/工具/sublime配置","date":"2021-08-31T16:00:00.000Z","updated":"2022-03-31T10:43:13.412Z","comments":true,"path":"posts/8eb6098d/","link":"","permalink":"http://xiaoke-jin.github.io/posts/8eb6098d/","excerpt":"","text":"将Sublime Text打造为轻量级的C++ IDE Sublime C/C++配置指南","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"sublime","slug":"工具/sublime","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/sublime/"}],"tags":[]},{"title":"第一章 基础：逻辑和证明","slug":"读书笔记/离散数学及其应用/第一章 基础：逻辑和证明","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.889Z","comments":true,"path":"posts/ff885b50/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ff885b50/","excerpt":"","text":"本章将解释一个正确的数论证是如何组成的，并介绍构造这样的论证的工具。 我们将开发一系列不同的证明方法以「证明许多不同类型的结论」。 在介绍了多种不同证明方法后，我们将介绍一些「构造证明的策略」。 我们还将介绍猜想的概念，并通过研究来解释数学发展的过程。 命题逻辑 逻辑规则给出数学语句的准确含义，这些规则可以用来区分数学论证的有效或无效。 逻辑的基本构件——命题。命题是一个陈述语句，它的真值或真或假，但不能既真又假。（真值：真实值） 有些命题的真假目前不知道，但可以确定其真值是唯一的。（例：2050年元旦是晴天） 我们用字母来表示 命题变量（或称为语句变量），即表示命题的变量。如果一个命题是真命题，则它的真值为真，用 TTT 表示；如果它是假命题，则其真值为假，用 FFF 表示。不能用简单的命题来表示的命题称为 原子命题 。 涉及命题的逻辑领域称为 命题演算 或 命题逻辑。它最初是 2300 多年前由古希腊哲学家亚里士多德系统地创建的。 从已有命题产生新命题的方法：许多数学陈述都是由一个或多个命题组成的。由已知命题用 逻辑运算符 组合而来的新命题也被称为 复合命题 。二元逻辑运算符也称为 联结词 。 逻辑运算符 令 p、qp、qp、q 为命题， ppp 的否定记作 ¬p\\neg p¬p ，指“ 不是 ppp 所指的情形 ”。命题 ¬p\\neg p¬p 读作“ 非 ppp ”。 ¬p\\neg p¬p 的真值与 ppp 的真值相反。 p、qp、qp、q 的合取即命题“ ppp 并且 qqq ”，记作 p∧qp\\land qp∧q 。当 p、qp、qp、q 都是真命题时，p∧qp\\land qp∧q 命题为真，否则为假。 p、qp、qp、q 的析取即命题“ ppp 或 qqq ” ，记作 p∨qp\\lor qp∨q 。当 p、qp、qp、q 均为假命题时，p∨qp\\lor qp∨q 命题为假，否则为真。 p、qp、qp、q 的异或记作 p⊕qp\\oplus qp⊕q 。当 p、qp、qp、q 中只有一个为真时命题为真，否则为假。 条件语句 p→qp\\to qp→q 是命题”若 ppp ，则 qqq &quot;。当 ppp 为真而 qqq 为假时，条件语句 p→qp\\to qp→q 为假，否则为真。在条件语句 p→qp\\to qp→q 中，ppp 称为假设（前提），qqq 称为结论。等价于「 ¬p∨q\\neg p\\lor q¬p∨q 」。 双条件语句 p↔qp\\leftrightarrow qp↔q 是命题“ ppp 但且仅当 qqq ”。当 p、qp、qp、q 有同样的真值时，双条件语句为真，否则为假。双条件语句也称为 双向蕴含 。等价于：(p→q)∧(q→p)(p\\to q)\\land (q\\to p)(p→q)∧(q→p) 。 用或表示异或： p⊕q=(¬p∧q)∨(p∧¬q)p\\oplus q=(\\neg p\\land q)\\lor (p\\land\\neg q)p⊕q=(¬p∧q)∨(p∧¬q) 。 语句 p→qp\\to qp→q 称为条件语句，因为 p→qp\\to qp→q 可以判定在条件 ppp 成立时 qqq 为真。条件语句也称为 蕴含。 表达 p→qp\\to qp→q 的术语也很多：ppp 蕴含 qqq ，ppp 是 qqq 的充分条件，ppp 的必要条件是 qqq ，ppp 仅当 qqq ，qqq 除非 ¬p\\neg p¬p 对条件语句的表达方式的理解：「 ppp 仅当 qqq 」说的是当 qqq 不为真时 ppp 不能为真。也就是说，如果 ppp 为真但 qqq 为假，则这个语句为假。当 ppp 为假时，qqq 可以为真也可以为假，因为语句没有谈及 qqq 的真值。「 qqq 除非 ¬p\\neg p¬p 」：如果 ¬p\\neg p¬p 是假的，则 qqq 必是真的。也就是说，当 ppp 为真，而 qqq 为假时，语句“ qqq 除非 ¬p\\neg p¬p ”是假的，否则是真的。 表达 p↔qp\\leftrightarrow qp↔q 的术语：“ ppp 是 qqq 的充要条件”、“如果 ppp 那么 qqq ，反之亦然”、“ ppp 当且仅当 qqq ”、“ ppp 恰好当 qqq ”。当且仅当（if and only if）可以用 iff 代替。 在数学推理中我们考虑的条件语句比语言中使用的要广泛一些。条件语句作为一个数学概念不依赖于假设和结论之间的因果关系。 逆命题： 逆否命题： 反命题： 逆否命题与原命题真值相同。 逻辑运算符的优先级： 运算符 优先级 ¬\\neg¬ 1 ∧\\land∧ 2 ∨\\lor∨ 3 →\\to→ 4 ↔\\leftrightarrow↔ 5 逻辑运算和比特运算：比特是一个具有两个可能值的符号，即 0 和 1 。如果一个变量的值或真或假，则此变量称为 布尔变量 。 模糊逻辑： 命题逻辑的应用 语句翻译 系统规范说明 布尔搜索 逻辑谜题 逻辑电路 命题等价式 \\qquad数学证明中的一个重要步骤就是用真值相同的一个语句替换另一条语句。因此，从给定复合命题生成具有相同真值命题的方法广泛用于数学证明的构造。 定义：一个真值永远是真的复合命题（无论其中出现的命题变量的真值是什么），称为 永真式（ tautology ），也称为重言式。一个真值永远为假的复合命题称为 矛盾式（ contradiction ）。既不是永真式也不是矛盾式的复合命题称为 可能式（ contingency ）。 定义：如果 p↔qp\\leftrightarrow qp↔q 是永真式，则命题 p,qp,qp,q 称为是逻辑等价的。用记号 p≡qp\\equiv qp≡q 表示 p,qp,qp,q 是 逻辑等价 的。 常见等价式： 名称 等价式 双重否定律 p≡¬¬pp\\equiv \\neg\\neg pp≡¬¬p 幂等律 p≡p∨pp\\equiv p\\lor pp≡p∨p，p≡p∧pp\\equiv p\\land pp≡p∧p 交换律 p∨q≡q∨pp\\lor q\\equiv q\\lor pp∨q≡q∨p，p∧q≡q∧pp\\land q\\equiv q\\land pp∧q≡q∧p 结合律 (p∧q)∧r≡p∧(q∧r)(p\\land q)\\land r\\equiv p\\land (q\\land r)(p∧q)∧r≡p∧(q∧r) (p∨q)∨r≡p∨(q∨r)(p\\lor q)\\lor r\\equiv p\\lor (q\\lor r)(p∨q)∨r≡p∨(q∨r) 分配律 p∧(q∨r)≡(p∧q)∨(p∧r)p\\land (q\\lor r)\\equiv (p\\land q)\\lor (p\\land r)p∧(q∨r)≡(p∧q)∨(p∧r)，∧\\land∧ 对 ∨\\lor∨ 的分配律 p∨(q∧r)≡(p∨q)∧(p∨r)p\\lor (q\\land r)\\equiv (p\\lor q)\\land (p\\lor r)p∨(q∧r)≡(p∨q)∧(p∨r)，∨\\lor∨ 对 ∧\\land∧ 的分配律 德 · 摩根律 ¬(p∨q)≡¬p∧¬q\\neg(p\\lor q)\\equiv \\neg p\\land \\neg q¬(p∨q)≡¬p∧¬q，¬(p∧q)≡¬p∨¬q\\neg(p\\land q)\\equiv \\neg p\\lor \\neg q¬(p∧q)≡¬p∨¬q 吸收律 p∨(p∧q)≡pp\\lor (p\\land q)\\equiv pp∨(p∧q)≡p，p∧(p∨q)≡pp\\land(p\\lor q)\\equiv pp∧(p∨q)≡p 排中律 p∨¬q≡1p\\lor \\neg q\\equiv 1p∨¬q≡1 矛盾律 p∧¬p≡0p\\land \\neg p\\equiv 0p∧¬p≡0 归谬论 (p→q)∧(p→¬q)≡¬p(p\\to q)\\land (p\\to \\neg q)\\equiv \\neg p(p→q)∧(p→¬q)≡¬p 蕴涵等值式 p→q≡¬p∨qp\\to q\\equiv \\neg p\\lor qp→q≡¬p∨q 德 · 摩根律可以扩展为 ¬(p1∨p2∨⋯∨pn)≡(¬p1∧¬p2∧⋯∧¬pn)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\neg(p_1\\lor p_2 \\lor \\cdots\\lor p_n)\\equiv (\\neg p_1\\land\\neg p_2\\land\\cdots\\land\\neg p_n)¬(p1​∨p2​∨⋯∨pn​)≡(¬p1​∧¬p2​∧⋯∧¬pn​) ¬(p1∧p2∧⋯∧pn)≡(¬p1∨¬p2∨⋯∨¬pn)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\neg(p_1\\land p_2\\land\\cdots\\land p_n)\\equiv (\\neg p_1\\lor\\neg p_2\\lor\\cdots\\lor\\neg p_n)¬(p1​∧p2​∧⋯∧pn​)≡(¬p1​∨¬p2​∨⋯∨¬pn​) 我们有时用符号 ⋁j=1npj\\displaystyle \\bigvee_{j=1}^{n} p_jj=1⋁n​pj​ 来表示 p1∨p2∨⋯∨pnp_1\\lor p_2 \\lor \\cdots\\lor p_np1​∨p2​∨⋯∨pn​ ，用 ⋀j=1npj\\displaystyle \\bigwedge_{j=1}^{n} p_jj=1⋀n​pj​ 来表示 p1∧p2∧⋯∧pnp_1\\land p_2\\land\\cdots\\land p_np1​∧p2​∧⋯∧pn​ 。采用这种记法扩展的德 · 摩根律就可以简洁地写成 ¬(⋁j=1npj)≡⋀j=1n¬pj\\neg(\\displaystyle \\bigvee_{j=1}^{n} p_j)\\equiv \\bigwedge_{j=1}^{n}\\neg p_j¬(j=1⋁n​pj​)≡j=1⋀n​¬pj​ 和 ¬(⋀j=1npj)≡⋁j=1n¬pj\\neg(\\displaystyle \\bigwedge_{j=1}^{n} p_j)\\equiv \\bigvee_{j=1}^{n}\\neg p_j¬(j=1⋀n​pj​)≡j=1⋁n​¬pj​ 。 \\qquad有 n 个命题变量的复合命题的真值表有 2n2^n2n 行，由于随着 n 的增加，行数增加异常迅速，所以随着变量数的增加，利用真值表来建立等价式就变得不切实际。其他方法就会更快捷一些，比如利用我们已知的逻辑等价式。 可满足性 \\qquad一个复合命题称为是 可满足的，如果这个命题不是永假式。不可满足式是永假式，也就是说：一个命题是不可满足的当且仅当它的否定是永真式。 \\qquad当我们找到一个特定的使得复合命题为真的真值赋值时，就证明了它是可满足的。这样的一个赋值称为这个特定的可满足性问题的一个 解。可是，要证明一个复合命题是不可满足的，我们需要证明每一组变量的真值赋值都使其为假。 可满足性的应用 \\qquad在机器人学、软件测试、人工智能规划、计算机辅助设计、机器视觉、集成电路分析、计算机网络以及遗传学等不同的领域中许多问题都可以用命题的可满足性来建立模型。 n 皇后问题 \\qquadnnn 皇后问题要求在一个 n×nn\\times nn×n 的棋盘上放置 nnn 个皇后，目的是使皇后之间可以共存，即任意两个皇后不能在同一列、同一行或同一对角线上。（八皇后问题于 1848 年由 Max Bezzel 提出，由 Franz Nauck 在 1850 年彻底解决。 数独 可满足性问题求解 \\qquad当许多应用建模涉及成千上万个变量的复合命题的可满足性时，问题就来了。当变量数为 1000 时，要检查 210002^{1000}21000 种（这是一个超过 300 位的十进制数）可能的真值组合中的每一种，一台计算机在几万亿年之内都不可能完成。 \\qquad迄今尚没有其他已知的计算过程能使计算机在合理的时间之内判定变量数这么大的复合命题是否为可满足式。 \\qquad可是，在实际应用中某些特定类型的复合命题的可满足性问题求解方法还是有一些进展，比如数独迷题的求解。已经开发出许多计算机程序可以用来求解有实际应用的可满足性问题。 \\qquad在第 3 章讨论算法主题时，我们将进一步讨论这个问题。特别是，我们将解释命题的可满足性问题在算法复杂度学习中扮演的重要角色。 谓词和量词 \\qquad在 1.1~1.3 节中所学习的命题逻辑不能表达数学语言和自然语言中所有语句的确切意思。本节我们将介绍一种表达能力更强的逻辑，即 谓词逻辑。为了理解谓词逻辑，我们首先需要介绍谓词的概念，之后我们将介绍量词的概念。它可以让我们对这样的语句进行推理：某一性质对于某一类型的所有对象均成立，存在一个对象使得某一特性成立。 \\qquad语句“ x 大于 3”有两个部分。第一部分即变量 x 是语句的主语。第二部分（ 谓词 “大于 3”）表明语句的主语具有的一个性质。我们可以用 P(x)P(x)P(x) 表示语句“ x &gt; 3”，其中 PPP 表示谓词“大于 3”，而 x 是变量。语句 P(x)P(x)P(x) 也可以说成是命题函数 PPP 在 x 的值。一旦给变量 x 赋一个值，语句 P(x)P(x)P(x) 就成为命题且具有真值。 \\qquad有些语句还可以含有不止一个变量。例如，考虑语句“x = y + 3”。我们可以用 Q(x,y)Q(x,y)Q(x,y) 表示这个语句，其中 x , y 为变量，QQQ 为谓词。当 x , y 被赋值时，语句 Q(x,y)Q(x,y)Q(x,y) 就有真值了。 \\qquad一般地，涉及 n 个变量 x1,x2,⋯ ,xnx_1,x_2,\\cdots,x_nx1​,x2​,⋯,xn​ 的语句可以表示成 P(x1,x2,⋯ ,xn)P(x_1,x_2,\\cdots,x_n)P(x1​,x2​,⋯,xn​) 。形式为 P(x1,x2,⋯ ,xn)P(x_1,x_2,\\cdots,x_n)P(x1​,x2​,⋯,xn​) 的语句是 命题函数 PPP 在 n 元组 (x1,x2,⋯ ,xn)(x_1,x_2,\\cdots,x_n)(x1​,x2​,⋯,xn​) 的值，PPP 也称为 n位谓词 或 n元谓词。 \\qquad量化 也可以从命题函数生成一个命题。量化表示在何种程度上谓词对于一定范围的个体成立。在自然语言中，“所有、某些、没有、少量“这些词都可以用在量化上。这里我们集中讨论两类量化：全称量化，它告诉我们一个谓词对所考虑范围内的每一个体都为真；存在量化，它告诉我们一个谓词对所考虑范围内的一个或多个个体为真。处理谓词和量词的逻辑领域称为 谓词演算。 命题 什么时候为真 什么时候为假 ∀x P(x)\\forall x\\ P(x)∀x P(x) 对每个 x，P(x)P(x)P(x) 都为真 存在 x，使 P(x)P(x)P(x) 为假 ∃x P(x)\\exists x\\ P(x)∃x P(x) 存在 x，使 P(x)P(x)P(x) 为真 对每个 x，P(x)P(x)P(x) 都为假 全称量词：许多数学命题断言某一性质对于变量在某一特定域内的所有值都为真，这一特定域称为变量的 论域（domain of discourse）（或 全体域（universe of discourse）），时常简称为 域（domain）。这类语句可以用全称量化表示。对特定论域而言 P(x)P(x)P(x) 的全称量化是这样一个命题：它断言 P(x)P(x)P(x) 对 x 在其论域中的所有值均为真。注意，论域规定了变量 x 所有可能取的值。当论域改变时， P(x)P(x)P(x) 的全称量化的意义也随之改变。在使用全称量词时必须指定论域，否则语句的全称量化就是无定义的。 定义：P(x)P(x)P(x) 的全称量化是语句” P(x)P(x)P(x) 对 x 在其论域的所有值为真“ ，用符号 ∀x P(x)\\forall x\\ P(x)∀x P(x) 来表示，其中 $\\forall $ 称为全称量词。命题 ∀x P(x)\\forall x\\ P(x)∀x P(x) 读作 ”对所有 x ，P(x)P(x)P(x) “。一个使 P(x)P(x)P(x) 为假的个体称为 ∀x P(x)\\forall x\\ P(x)∀x P(x) 的反例。 存在量词： 嵌套量词 推理规则 证明导论 证明的方法和策略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第九章 关系","slug":"读书笔记/离散数学及其应用/第九章 关系","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.890Z","comments":true,"path":"posts/dfce29a8/","link":"","permalink":"http://xiaoke-jin.github.io/posts/dfce29a8/","excerpt":"","text":"关系及其性质 nnn原关系及其应用 关系的表示 关系的闭包 等价关系 偏序","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第二章 基本结构：集合、函数、序列、求和与矩阵","slug":"读书笔记/离散数学及其应用/第二章 基本结构：集合、函数、序列、求和与矩阵","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.891Z","comments":true,"path":"posts/a771d767/","link":"","permalink":"http://xiaoke-jin.github.io/posts/a771d767/","excerpt":"","text":"集合 集合运算 函数 序列与求和 集合的基数 矩阵","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第三章 算法","slug":"读书笔记/离散数学及其应用/第三章 算法","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.888Z","comments":true,"path":"posts/53d93201/","link":"","permalink":"http://xiaoke-jin.github.io/posts/53d93201/","excerpt":"","text":"算法 函数的增长 算法的复杂度","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第五章 归纳与递归","slug":"读书笔记/离散数学及其应用/第五章 归纳与递归","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.892Z","comments":true,"path":"posts/f01eb1e4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f01eb1e4/","excerpt":"","text":"数学归纳法 强归纳法与良序性 递归定义与结构归纳法 递归算法 程序正确性","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第六章 计数","slug":"读书笔记/离散数学及其应用/第六章 计数","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.894Z","comments":true,"path":"posts/9e4062f0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9e4062f0/","excerpt":"","text":"计数的基础 鸽巢原理 排列与组合 二项式系数和恒等式 排列与组合的推广 生成排列和组合","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十一章 树","slug":"读书笔记/离散数学及其应用/第十一章 树","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.893Z","comments":true,"path":"posts/173dcaef/","link":"","permalink":"http://xiaoke-jin.github.io/posts/173dcaef/","excerpt":"","text":"树的概述 树的应用 树的遍历 生成树 最小生成树","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第八章 高级计数技术","slug":"读书笔记/离散数学及其应用/第八章 高级计数技术","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.893Z","comments":true,"path":"posts/dff6f4e9/","link":"","permalink":"http://xiaoke-jin.github.io/posts/dff6f4e9/","excerpt":"","text":"递推关系的应用 求解线性递推关系 分治算法和递推关系 生成函数 容斥 容斥原理的应用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十章 图","slug":"读书笔记/离散数学及其应用/第十章 图","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.896Z","comments":true,"path":"posts/f7c95ce1/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f7c95ce1/","excerpt":"","text":"图和图模型 图的术语和几种特殊的图 图的表示和图的同构 连通性 欧拉通路与哈密顿通路 最短通路问题 平面图 图着色","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十二章 布尔代数","slug":"读书笔记/离散数学及其应用/第十二章 布尔代数","date":"2021-08-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.895Z","comments":true,"path":"posts/8d4fa534/","link":"","permalink":"http://xiaoke-jin.github.io/posts/8d4fa534/","excerpt":"","text":"布尔函数 布尔函数的表示 逻辑门电路 电路的极小化","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"VSCode输出中文乱码如何解决","slug":"else/工具/VSCode/VSCode输出中文乱码","date":"2021-08-31T16:00:00.000Z","updated":"2022-02-13T04:31:06.250Z","comments":true,"path":"posts/4486e5d2/","link":"","permalink":"http://xiaoke-jin.github.io/posts/4486e5d2/","excerpt":"","text":"在code runner的settings中， &quot;code-runner.executorMap&quot;: &#123; // chcp 65001的作用是让终端（CMD、PowerShell）的编码格式变为UTF-8 &quot;cpp&quot;: &quot;chcp 65001 &amp;&amp; cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt.exe &amp;&amp; $dir$fileNameWithoutExt.exe&quot;,&#125;","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"工具/VSCode","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/VSCode/"}],"tags":[]},{"title":"","slug":"else/Windows/鼠标右键菜单设置","date":"2021-08-31T13:01:39.022Z","updated":"2022-03-31T08:51:51.175Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"增加和删除win右键的Open Folder as PyCharm Project，Jetbrains系列 Typora如何添加到右键菜单中可以打开文件夹 使用火狐右键管理","categories":[],"tags":[]},{"title":"","slug":"读书笔记/初等数论及其应用/第二章 整数的表示法和运算","date":"2021-08-23T03:26:59.246Z","updated":"2021-11-25T10:39:14.788Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第三章 素数和最大公因子","slug":"读书笔记/初等数论及其应用/第三章 素数和最大公因子","date":"2021-08-22T16:00:00.000Z","updated":"2022-01-02T13:23:06.498Z","comments":true,"path":"posts/2b24089a/","link":"","permalink":"http://xiaoke-jin.github.io/posts/2b24089a/","excerpt":"","text":"大纲 要点：素数无穷，素数分布（素数定理），唯一分解定理，最大公因子，欧几里得算法，整数分解，费马数，丢番图方程。 尽管数学家做了几百年的努力，仍有关于素数的许多问题未被解决。 我们将选取讨论其中的一些，包括最著名的两个：孪生素数猜想 和 哥德巴赫（Goldbach）猜想。 在数论中常常研究具有特殊形式的数。本章中，我们将介绍 费马数 ，即形如 2n+12^n+12n+1 的整数。（费马猜想它们都是素数，但是这被证明是不对的）。 最后，我们将介绍 丢番图方程，它是只考虑整数解的方程。 我们将证明如何用最大公因子来帮助求解 线性丢番图方程。 与其他丢番图方程不同，线性丢番图方程能够容易地系统解决。 3.1 素数 定义：素数是大于 111 的正整数，并且除了 111 和它本身外不能被其他正整数所整除。 定义：大于 111 的不是素数的正整数称为合数。 本节将讨论 给定正整数集中素数的分布 并 证明该分布的一些基础性质 。同时还将讨论关于素数分布的一些更强的结论。 在我们将要介绍的定理中包含了数论中一些最著名的结论。 「素数的无限性」：我们从证明有无穷多个素数开始，为此需要下面的引理。 我们将在本章的后面介绍一些证明素数无穷性的其他方法。（见这一节末尾的习题8以及3.3、3.5和3.6节的习题）。 引理 3.1-每个大于 1 的正整数都有一个素因子 引理3.1：每个大于 111 的正整数都有一个素因子。 证明：反证法。假设存在一个大于 1 的正整数没有素因子，那么大于 1 且没有素因子的正整数构成的集合非空，由良序性知集合中存在一个大于 1 且没有素因子的最小正整数 nnn 。由于 nnn 能被 nnn 整除且 nnn 没有素因子，因此 nnn 不是素数。于是 nnn 可以写成 n=a×bn=a\\times bn=a×b ，其中 1&lt;a&lt;n1&lt;a&lt;n1&lt;a&lt;n ，1&lt;b&lt;n1&lt;b&lt;n1&lt;b&lt;n 。因为 a&lt;na&lt;na&lt;n ，所以 aaa 一定有素因子。由定理 1.8，aaa 的任何因子也是 nnn 的因子，因此 nnn 必有素因子。与假设矛盾。所以我们就得到结论：任何一个大于 111 的正整数至少有一个素因子。 定理 3.1-素数无限性 定理3.1：存在无穷多个素数。 证明：假设只有有限个素数 p1,p2,⋯ ,pnp_1,p_2,\\cdots,p_np1​,p2​,⋯,pn​ ，其中 nnn 是正整数，考虑整数 Qn=p1p2⋯pn+1Q_n=p_1p_2\\cdots p_n+1Qn​=p1​p2​⋯pn​+1 。由引理 3.1， QnQ_nQn​ 至少有一个素因子，设为 qqq 。如果 q=pjq=p_jq=pj​ ，其中 jjj 为某个整数且 1≤j≤n1\\le j\\le n1≤j≤n 。由于 Qn−p1p2⋯pn=1Q_n-p_1p_2\\cdots p_n=1Qn​−p1​p2​⋯pn​=1 ，且 qqq 可以整除 QnQ_nQn​，p1p2⋯pnp_1p_2\\cdots p_np1​p2​⋯pn​ ，因此由定理 1.9， q∣1q\\mid 1q∣1 。这显然是不可能的，因为 1 不能被任何素数整除。于是 qqq 不是 pjp_jpj​ 的任何一个。这与假设矛盾。 证毕。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理 3.1 的证明过程不是构造性的，因为我们在证明中构造的整数 QnQ_nQn​（由前 nnn 个素数的积加 1 得到）可以是素数也可以不是（见习题11）。因此，在证明过程中我们只是知道存在一个新的素数但是并没有求得它。 求素数：在下面的章节中，我们将把兴趣放在 如何求大素数 和 使用大素数 上。 定理 3.2 合数必有一个小于等于 sqrt(n) 的素因子 将素数和合数加以区分的测试是至关重要的，这种测试叫做 素性检验。最基本的素性检验是「试除法」。 bool is_prime()&#123; for(int i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false;y &#125; return true;&#125; 定理3.2：如果 nnn 是一个合数，那么 nnn 一定有一个不超过 n\\sqrt{n}n​ 的素因子。 证明：既然 nnn 是合数，那么 nnn 可以写成 n=a×bn=a\\times bn=a×b，其中 a, b 为整数且 1&lt;a≤b&lt;n1&lt;a≤b&lt;n1&lt;a≤b&lt;n 。 我们一定有 a≤na\\le \\sqrt{n}a≤n​ ，否则若 b≥a&gt;nb\\ge a&gt;\\sqrt{n}b≥a&gt;n​，那么有 a×b&gt;n×n=na\\times b&gt;\\sqrt{n}\\times\\sqrt{n}=na×b&gt;n​×n​=n 。由引理3.1，aaa 至少有一个素因子，再由定理1.8，aaa 的因子一定也是 nnn 的因子，显然这个因子小于等于 n\\sqrt{n}n​ 。 证毕。 ■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 给定一个正整数 nnn ，使用定理 3.2 可以找到所有小于等于 nnn 的素数。这种方法就是「埃拉托色尼斯筛法」。 int primes[1000], cnt;bool is_prime[1000];for(int i = 2; i &lt;= n; i++)&#123; if(is_primes[i]) continue; primes[++cnt] = i; if(i &lt;= sqrt(n)) &#123; // 使用小于等于sqrt(n)的所有质数即可 for(int j = i * i; j &lt;= n; j += i) is_primes[j] = true; &#125;&#125; 对于一个特定的整数 nnn ，我们将在后面给出一个更好的方法来判断一个整数是否是素数，即定理 6.11。 定理 3.3 狄利克雷 定理3.3（狄利克雷关于「等差数列中素数的定理」）：假设 a,ba,ba,b 是互素的整数，那么等差数列 an+b (n=1,2,3,⋯ )an+b\\ (n=1,2,3,\\cdots)an+b (n=1,2,3,⋯) 包含了无穷多的素数。 目前为止狄利克雷定理没有简单的证法。（狄利克雷的原始证明使用了复变量。后来爱尔迪希（Erdos）和塞尔伯格（Selberg）在 20世纪 50年代给出了一个初等但较复杂的证明）。 但是狄利克雷定理的一些特例很容易证。我们将通过在 3.5 节中证明有无穷多个 4n+34n+34n+3 型的素数来说明这一点。 已知的最大素数：在近千百年的历史中，数学家和一些数学爱好者们总是试图找到一个比已知的最大素数更大的素数。一个人会因为找到这样的素数而至少在当时一举成名，并且他或她的名字也将被载入史册。因为有无穷多的素数，因而总有素数比当时的已知最大素数要大。寻找新素数也有一些系统化的方法。人们并不是随机挑选一些数来检验其是否为素数，而是选取一些特殊形式的数。例如，我们将在第7章中讨论具有 2p−12^p-12p−1 形式的素数，其中是 ppp 素数；这种数被称为 梅森素数（Mersenne primes）。我们将看到用一种特殊的测试可以检验出 2p−12^p-12p−1 是否为素数，而不需要用试除法。过去几百年中多数时间里最大的素数一直是梅森素数。目前已知的最大素数的世界纪录是 243 112 609−12^{43\\ 112\\ 609}-1243 112 609−1 。 素数公式 是否有一个公式只产生素数呢？ 关于一个变元的多项式没有这种性质，习题23证明了这一点。同样，关于 nnn 个变元的多项式不能只产生素数，其中 nnn 是一个正整数（这个结论超出了本书的范围）。 有一些可以只产生素数的公式但是不实用。例如，米尔斯（Mills）证明了存在一个常数 Θ\\varThetaΘ 使得函数 f(n)=[Θ3n]f(n)=[\\varTheta^{3^n}]f(n)=[Θ3n] 只生成素数，我们只知道 Θ\\varThetaΘ 的近似值 Θ≈1.3064\\varTheta\\approx1.3064Θ≈1.3064 。 如果没有一个实用的公式可以产生大素数，那么怎么才能生成它们呢？在第6章中将介绍如何用概率素性检验法来生成大素数。 素性证明 在 广义黎曼猜想 成立的条件下，米勒（G. L. Miller）于1975年给出了一个可用 O((log⁡n)5)O((\\log{n})^5)O((logn)5) 次位运算来证明一个整数是素数的算法。但可惜的是，广义黎曼猜想到现在尚未被证明。 ★\\bigstar★ 由于广义黎曼猜想并没有被证明，其后由Michael O. Rabin教授作出修改，提出了不依赖于该假设的 随机化算法。 在1983年，Leonard Adleman、Carl Pomerance和Robert Rumely建立了一个计算复杂度为 (log⁡n)c log⁡log⁡log⁡n(\\log n)^{c\\ \\log\\log\\log{n}}(logn)c logloglogn 的算法，其中 ccc 是常数。 虽然他们的算法不是 多项式时间 ，但是它已经接近多项式时间了，因为 log⁡log⁡log⁡n\\log\\log\\log{n}logloglogn 增长得非常慢。 使用他们的算法结合现在的计算机确定一个100位的整数是否为素数只需几毫秒，确定一个400位的整数是否为素数用时不超过 1 秒，而确定一个1000位的整数是否为素数用时少于一个小时。 素性验证的多项式时间算法 2002年，一位印度计算机教授 我们现在只是讨论了素性检验中的「确定性算法」（deterministic algorithms），即用来确定一个整数是否为素数的算法。 在第6章中我们将讨论 概率素性检验法，即 米勒-拉宾算法，定理6.11 。这个测试将告诉我们一个整数有很高的可能性是素数，但并不确定其为素数。 3.2 素数的分布 在18世纪后期，数学家们通过手算建立了素数表。通过这些数值，他们开始寻找函数来估计 π(x)\\pi(x)π(x) 。 定理 3.4-素数定理 定义：函数 π(x)\\pi(x)π(x) 表示不超过 xxx 的素数的个数，其中 xxx 是正实数。 定理3.4（素数定理）：随着 xxx 的无限增长，π(x)\\pi(x)π(x) 和 xln⁡x\\dfrac{x}{\\ln{x}}lnxx​ 的比趋于 111。 如果用极限的语言来表述，我们有 lim⁡x→∞π(x)(x/ln⁡x)=1\\lim\\limits_{x \\to \\infty} \\dfrac{\\pi(x)}{(x/\\ln x)}=1x→∞lim​(x/lnx)π(x)​=1。 用一个简单的方法来表述素数定理是写成 π(x)∽xln⁡x\\pi(x)\\backsim\\dfrac{x}{\\ln{x}}π(x)∽lnxx​。这里符号 ∽\\backsim∽ 表示渐进于。 推论 3.4.1 第 n 个素数的大小 推论3.4.1：令 pnp_npn​ 是第 nnn 个素数，其中 nnn 是正整数，那么 pn∽nlog⁡np_n\\backsim n\\log npn​∽nlogn ，即第 nnn 个素数渐进于 log⁡n\\log{n}logn 。 随机选到素数的概率 如果随机地选择一个正整数，那么它是素数的概率有多大呢？ 定理 3.5 定理3.5：对于任意的正整数 nnn，存在至少 nnn 个连续的正合数。 证明： 关于素数的猜想 伯兰特猜想； 「孪生素数猜想」； 「哥德巴赫猜想」：每个大于 222 的正偶数可以写成两个素数的和。 素数等差数列的「厄尔多斯猜想」：对任意的正整数 n≥3n\\ge 3n≥3，有一个由素数组成的长度为 nnn 的等差数列。 2006年Ben Green和陶哲轩取得了突破性进展从而证明了该猜想。 n2+1n^2+1n2+1 猜想：存在无穷多个形如 n2+1n^2+1n2+1 的素数，其中 nnn 是正整数。 勒让德猜想 3.3 最大公因子及其性质 定理 3.6 定理3.6 ：a,ba,ba,b 是整数，且 (a,b)=d(a,b)=d(a,b)=d ，那么 (ad,bd)=1(\\dfrac{a}{d},\\dfrac{b}{d})=1(da​,db​)=1 。（换言之，a/da/da/d 与 b/db/db/d 互素）。 证明：假设还有其他正整数 eee 使得 e∣(a/d)e\\mid (a/d)e∣(a/d) 且 e∣(b/d)e\\mid (b/d)e∣(b/d) ，那么存在整数 kkk 和 lll 使得 a/d=kea/d=kea/d=ke ，b/d=leb/d=leb/d=le ，于是 a=dkea=dkea=dke ，b=dleb=dleb=dle 。因此 dedede 是 a,ba,ba,b 的公因子。因为 ddd 是 a,ba,ba,b 的最大公因子，故 de⩽dde\\leqslant dde⩽d ，于是 e=1e=1e=1 。因此 (ad,bd)=1(\\dfrac{a}{d},\\dfrac{b}{d})=1(da​,db​)=1 。 推论 3.6.1 如果 (p ,q)=1(p\\ ,q)=1(p ,q)=1 ，则分数 p/qp/qp/q 被称为既约分数。 下面的推论告诉我们每一个分数都与另一个既约分数相等。 推论3.6.1：如果 a,ba,ba,b 为整数，且 b≠0b\\neq 0b=0 ，则 ab=pq\\dfrac{a}{b}=\\dfrac{p}{q}ba​=qp​ ，其中 p,qp,qp,q 为整数，且 (p,q)=1,q≠0(p,q)=1,q\\neq 0(p,q)=1,q=0 。 证明：假设 a,ba,ba,b 为整数且 b≠0b\\ne 0b=0 ，令 p=a/dp=a/dp=a/d ，q=b/dq=b/dq=b/d ，其中 d=(a,b)d=(a,b)d=(a,b) ，则 p/q=(a/d)/(b/d)p/q=(a/d)/(b/d)p/q=(a/d)/(b/d) 。由定理 3.6 可知 (p,q)=1(p,q)=1(p,q)=1 。 定理 3.7 (a,b)=(a+cb,b) 定理3.7：令 a,b,ca,b,ca,b,c 是整数，那么 (a,b)=(a+cb,b)(a,b)=(a+cb,b)(a,b)=(a+cb,b) 。 证明：令 eee 是 a,ba,ba,b 的公因子，由定理 1.9 可知 e∣a+cbe\\mid a+cbe∣a+cb ，所以 eee 是 a+cba+cba+cb 和 bbb 的公因子。如果 fff 是 a+cba+cba+cb 和 bbb 的公因子，那么由定理 1.9 可知 fff 整除 (a+cb)−cb=a(a+cb)-cb=a(a+cb)−cb=a ，所以 fff 是 a,ba,ba,b 的公因子。即 a,ba,ba,b 的公因子与 a+cb,ba+cb,ba+cb,b 的公因子相同。因此 (a+cb,b)=(a,b)(a+cb,b)=(a,b)(a+cb,b)=(a,b) 。 定理 3.8 gcd与线性组合 定义：如果 a,ba,ba,b 是整数，那么它们的 线性组合 具有形式 ma+nbma+nbma+nb ，其中 m,nm,nm,n 都是整数。 定理3.8：两个不全为零的整数 a,ba,ba,b 的最大公因子是 a,ba,ba,b 的线性组合中 最小 的正整数。 证明： 令 ddd 是 a,ba,ba,b 的线性组合中最小的正整数。（因为当 a≠0a\\neq 0a=0 时，两个线性组合 1×a+0×b1\\times a+0\\times b1×a+0×b 和 0×a+1×b0\\times a+1\\times b0×a+1×b 中必有一个为正，因此根据良序性，存在最小的正整数）。 我们有 d=ma+nbd=ma+nbd=ma+nb ，其中 m,nm,nm,n 是整数 。\\qquad\\qquad （1） 我们先证明 d∣ad\\mid ad∣a ， d∣bd\\mid bd∣b 。 由带余除法，得到 a=dq+ra=dq+ra=dq+r，0≤r&lt;d0\\le r&lt;d0≤r&lt;d 。由这个方程和（1）可以得到 r=a−dq=a−q(ma+nb)=(1−mq)a−qnbr=a-dq=a-q(ma+nb)=(1-mq)a-qnbr=a−dq=a−q(ma+nb)=(1−mq)a−qnb 。这就证明了整数 rrr 是 a,ba,ba,b 的线性组合。因为 0≤r&lt;d0\\le r&lt;d0≤r&lt;d 且 ddd 是 a,ba,ba,b 的线性组合中最小的正整数，于是我们得到 r=0r=0r=0，因此 d∣ad\\mid ad∣a 。同理可得 d∣bd\\mid bd∣b 。 接下来证明它是 a,ba,ba,b 的最大公因子。为此只需证明 a,ba,ba,b 所有的公因子 ccc 都可整除 ddd 。 由于 d=ma+nbd=ma+nbd=ma+nb ，因此如果 c∣ac\\mid ac∣a 且 c∣bc\\mid bc∣b ，那么由定理 1.9 有 c∣dc\\mid dc∣d ，因此 d≥cd\\ge cd≥c 。 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 推论 3.8.1 贝祖定理 推论3.8.1（Bezout，贝祖定理）：如果 a,ba,ba,b 均为整数，则有整数 m,nm,nm,n ，使得 ma+nb=gcd⁡(a,b)ma+nb=\\gcd(a,b)ma+nb=gcd(a,b) 。 虽然该推论被称作是 Bezout 定理，但多年以前 Claude Gaspar Bachet 已经证明了该结果。 方程 ma+nb=(a,b)ma+nb=(a,b)ma+nb=(a,b) 被称为 Bezout 等式，对给定的整数 a,ba,ba,b 满足该等式的整数 m,nm,nm,n 被称为是 a,ba,ba,b 的 Bezout 系数或 Bezout 数。 推论 3.8.2 推论3.8.2：整数 a,ba,ba,b 互素当且仅当存在整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 。（充要条件的证明） 证明：若 (a,b)=1(a,b)=1(a,b)=1 。由定理 3.8 可知，1 是 a,ba,ba,b 的线性组合的最小正整数。于是存在整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 。反之，如果有整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 ，则由定理 3.8 可得 (a,b)=1(a,b)=1(a,b)=1 。这是由于 a,ba,ba,b 不为 0 且 1 显然是 a,ba,ba,b 的线性组合中的最小正整数。 定理 3.9 线性组合与gcd的倍数 定理3.9：如果 a, ba,\\ ba, b 是正整数，那么所有 a, ba,\\ ba, b 的线性组合构成的集合与所有 (a, b)(a,\\ b)(a, b) 的倍数构成的集合相同。 证明： 假设 d=(a, b)d=(a,\\ b)d=(a, b) ， 我们首先证明每个 a,ba,ba,b 的线性组合是 ddd 的倍数。 我们现在证明每一个 ddd 的倍数也是 a,ba,ba,b 的线性组合。 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理 3.10 一种定义gcd的方式 不依赖于整数的有序性定义最大公因子。 定理3.10：如果 a,ba,ba,b 是不全为 000 的整数，那么正整数 ddd 是 a,ba,ba,b 的最大公因子，当且仅当 \\qquad\\qquad（i） d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b； \\qquad\\qquad（ii） 如果 ccc 是整数且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b ，那么 c∣dc\\mid dc∣d； 证明：\\qquad假设 d=(a,b)d=(a,b)d=(a,b) ， 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 引理 3.2 多个数的最大公因子 定义：令 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 是不全为零的整数。这些整数的公因子中最大的整数就是最大公因子。 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 的最大公因子记为 (a1,a2,a3,…,an)(a_1,a_2,a_3,\\dots,a_n)(a1​,a2​,a3​,…,an​) 。（注意 aia_iai​ 在这里面出现的顺序不影响结果） 引理3.2：如果 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 是不全为零的整数，那么 (a1,a2,a3,…,an)=(a1,a2,a3,…,(an−1,an))(a_1,a_2,a_3,\\dots,a_n)=(a_1,a_2,a_3,\\dots,(a_{n-1},a_n))(a1​,a2​,a3​,…,an​)=(a1​,a2​,a3​,…,(an−1​,an​)) 。 互素，两两互素 3.4 欧几里得算法 引理 3.3 (a，b) = (b，a % b) 引理3.3：如果 e,de,de,d 是整数且 e=dq+re=dq+re=dq+r ，其中 q,rq,rq,r 是整数，那么 (e,d)=(d,r)(e,d)=(d,r)(e,d)=(d,r) 。 证明：在定理 3.7 中，取 a=ra=ra=r ， b=db=db=d ， c=qc=qc=q 即得到该引理。 定理 3.11 欧几里得算法 定理3.11（欧几里得算法） 证明：令 r0=ar_0=ar0​=a ，r1=br_1=br1​=b 是正整数且满足 a⩾ba\\geqslant ba⩾b ，那么通过连续运用带余除法，我们求得 r0=r1q1+r20⩽r2&lt;r1,r1=r2q2+r30⩽r3&lt;r2, ⋮rj−2=rj−1qj−1+rj0⩽rj&lt;rj−1, ⋮rn−4=rn−3qn−3+rn−20⩽rn−2&lt;rn−3,rn−3=rn−2qn−2+rn−10⩽rn−1&lt;rn−2,rn−2=rn−1qn−1+rn 0⩽rn&lt;rn−1,rn−1=rnqn\\begin{align*} r_0&amp;=r_1q_1+r_2\\qquad\\qquad 0\\leqslant r_2&lt;r_1,\\\\ r_1&amp;=r_2q_2+r_3\\qquad\\qquad 0\\leqslant r_3&lt;r_2,\\\\ \\qquad&amp;\\ \\ \\vdots\\\\ r_{j-2}&amp;=r_{j-1}q_{j-1}+r_j\\qquad 0\\leqslant r_j&lt;r_{j-1},\\\\ \\qquad&amp;\\ \\ \\vdots\\\\ r_{n-4}&amp;=r_{n-3}q_{n-3}+r_{n-2}\\qquad 0\\leqslant r_{n-2}&lt;r_{n-3},\\\\ r_{n-3}&amp;=r_{n-2}q_{n-2}+r_{n-1}\\qquad 0\\leqslant r_{n-1}&lt;r_{n-2},\\\\ r_{n-2}&amp;=r_{n-1}q_{n-1}+r_{n}\\qquad\\ \\ \\ \\ 0\\leqslant r_n&lt;r_{n-1},\\\\ r_{n-1}&amp;=r_nq_n \\end{align*} r0​r1​rj−2​rn−4​rn−3​rn−2​rn−1​​=r1​q1​+r2​0⩽r2​&lt;r1​,=r2​q2​+r3​0⩽r3​&lt;r2​, ⋮=rj−1​qj−1​+rj​0⩽rj​&lt;rj−1​, ⋮=rn−3​qn−3​+rn−2​0⩽rn−2​&lt;rn−3​,=rn−2​qn−2​+rn−1​0⩽rn−1​&lt;rn−2​,=rn−1​qn−1​+rn​ 0⩽rn​&lt;rn−1​,=rn​qn​​ 可以确定最后一定会有一个余数为零，这是因为余数组成的序列 a=r0⩾r1&gt;r2&gt;r3&gt;⋯⩾0a=r_0\\geqslant r_1&gt;r_2&gt;r_3&gt;\\cdots\\geqslant 0a=r0​⩾r1​&gt;r2​&gt;r3​&gt;⋯⩾0 所包含的项的个数不会大于 aaa （因为每个余数都是整数），由引理 3.3，我们得到 (a,b)=(r0,r1)=(r1,r2)=(r2,r3)=⋯=(rn−2,rn−1)=(rn−1,rn)=(rn,0)(a,b)=(r_0,r_1)=(r_1,r_2)=(r_2,r_3)=\\cdots=(r_{n-2},r_{n-1})=(r_{n-1},r_{n})=(r_n,0)(a,b)=(r0​,r1​)=(r1​,r2​)=(r2​,r3​)=⋯=(rn−2​,rn−1​)=(rn−1​,rn​)=(rn​,0) ，因此 (a,b)=rn(a,b)=r_n(a,b)=rn​ ，这是最后一个非零余数。 int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 欧几里得算法是一种快速地求最大公因子的方法。接下来，当我们用欧几里得算法求两个正整数的最大公因子来估算 除法的最大步数 时会看到这一点。 定理 3.12 斐波那契与欧几里得 用欧几里得算法来求斐波那契序列中连续项的最大公因子的速度很慢，因为除了最后一步，其余的每一步的商都是1 。 下面的定理将告诉我们用欧几里得算法求斐波那契序列中连续两项的最大公因子需要多少步除法。 定理3.12：令 fn+1f_{n+1}fn+1​ 和 fn+2 (n&gt;1)f_{n+2}\\ \\ (n&gt;1)fn+2​ (n&gt;1) 是斐波那契数列中连续的两项，那么用欧几里得算法证明 (fn+1,fn+2)=1(f_{n+1},f_{n+2})=1(fn+1​,fn+2​)=1 一共需要 nnn 步除法。证明： 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 欧几里得算法的计算复杂度 定理 3.13 欧几里得算法的高效性 定理3.13（拉梅定理）：用欧几里得算法计算两个正整数的最大公因子时，所需的除法次数不会超过两个整数中较小的那个十进制的位数的 5 倍。 证明： 拉梅定理的推论，它告诉我们 欧几里得算法是非常高效的 。 推论3.13.1：求两个正整数 a,ba,ba,b，a&gt;ba&gt;ba&gt;b 的最大公因子需要 O((log⁡2a)3)O((\\log_2a)^3)O((log2​a)3) 次的位运算。 证明： 定理 3.14（扩欧） 用线性组合的方式来表示最大公因子 如果已经求得 ，那么因为 ， 我们有 从 到 ，最终 这显示了如何沿着欧几里得算法产生的等式递进最终使得 a,ba,ba,b 的最大公因子 (a,b)(a,b)(a,b) 可以表示为 a,ba,ba,b 的线性组合。 自底向上计算 扩展欧几里得算法 只需用一次欧几里得算法就能计算出 (a,b)(a,b)(a,b) 。 然而写算法时，由于使用递归，倒推回去也可。 若使用以下方法。若输入数据不满足被除数大于除数，答案错误。 扩展欧几里得算法（自顶向下计算） 定理 3.14：令 (a,b)(a,b)(a,b) 是正整数，那么 rn=(a,b)=sna+tnbr_n=(a,b)=s_na+t_nbrn​=(a,b)=sn​a+tn​b ，其中 sn,tns_n,t_nsn​,tn​ 是下面定义的递归序列的第 nnn 项： 且 ， 其中 j=2,3,⋯ ,nj=2,3,\\cdots,nj=2,3,⋯,n ，而 qjq_jqj​ 是欧几里得算法求 (a.b)(a.b)(a.b) 时每一步的商。 证明：我们将证明 ， (3.2) 因为 ，一旦等式(3.2)成立，我们就有 。 我们用第二数学归纳原理来证明。 对于 ，有 。因此对 成立。类似地， ，所以对于 成立。 现在假设 ，对于 成立。那么由欧几里得算法的第 步，我们有 由归纳假设，得到 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 3.5 算术基本定理 为了证明算术基本定理中分解的唯一性，我们需要先介绍两个引理。 引理 3.4 引理3.4：如果 a,b,ca,b,ca,b,c 是正整数，满足 (a,b)=1(a,b)=1(a,b)=1 且 a∣bca\\mid bca∣bc ，则 a∣ca\\mid ca∣c 。 证明：由于 (a,b)=1(a,b)=1(a,b)=1 ，存在整数 xxx 使得 ax+by=1ax+by=1ax+by=1 。等式两边同时乘以 ccc ，得 acx+bcy=cacx+bcy=cacx+bcy=c 。根据定理 1.9 得 a∣(acx+bcy)a\\mid (acx+bcy)a∣(acx+bcy)，这是因为这是 a,bca,bca,bc 的线性组合，而它们都可以被 aaa 整除。因此 a∣ca\\mid ca∣c 。 引理 3.5 引理3.5：如果 p∣a1a2⋯anp\\mid a_1a_2\\cdots a_np∣a1​a2​⋯an​ ，其中 ppp 为素数，且 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 是正整数，则存在整数 i, 1⩽i⩽ni,\\ 1\\leqslant i\\leqslant ni, 1⩽i⩽n ，使得 p∣aip\\mid a_ip∣ai​ 。 证明：我们通过数学归纳法证明。对任意素数 ppp \\qquad①当 n=1n=1n=1 时，显然成立。 \\qquad②假定结果对 nnn 成立。考虑 n+1n+1n+1 个整数的乘积 a1a2⋯an+1a_1a_2\\cdots a_{n+1}a1​a2​⋯an+1​ ，它是能够被素数 ppp 整除的。我们知道或者有 (p, a1a2⋯an)=1(p,\\ a_1a_2\\cdots a_n)=1(p, a1​a2​⋯an​)=1 ，或者有 (p, a1a2⋯an)=p(p,\\ a_1a_2\\cdots a_n)=p(p, a1​a2​⋯an​)=p 。如果 (p, a1a2⋯an)=1(p,\\ a_1a_2\\cdots a_n)=1(p, a1​a2​⋯an​)=1 ，则由引理 3.4 ，p∣an+1p\\mid a_{n+1}p∣an+1​ 。另一方面，如果 p∣a1a2⋯anp\\mid a_1a_2\\cdots a_np∣a1​a2​⋯an​ ，由归纳假设，存在整数 i, 1⩽i⩽ni,\\ 1\\leqslant i\\leqslant ni, 1⩽i⩽n ，使得 p∣aip\\mid a_ip∣ai​ 。因此，对某个满足 1⩽i⩽n+11\\leqslant i\\leqslant n+11⩽i⩽n+1 的 iii ，p∣aip\\mid a_ip∣ai​ 。 证毕。 定理 3.15 算术基本定理 定理3.15（算术基本定理）：每个大于 111 的正整数都可以被唯一地写成素数的乘积，在乘积中的素因子按照非降序排列。 证明： ①我们采用反证法：证明：每个大于 111 的数必能写成素数的乘积。 假定某正整数不能被写成素数的乘积。设 是这样的整数中最小的(良序性)。如果 是素数，那么它显然是素数的乘积，即一个素数 。所以 一定是合数。设 ，其中 。但是由于 都比 小，因54此它们一定可以写成素数的乘积(良序性)。又由于 ，我们得到 也是素数的乘积。这个矛盾说明每个正整数都可以写成素数的乘积。 ②我们现在通过证明这个 分解的唯一性 来完成算术基本定理的证明。 假定整数 有两种不同的素数分解形式： ，其中 和 为素数，且 。 在这两个分解式中约去相同的素数，得到 *。*其中等式左边的素数与右边的不同， 。 然而，这导致了与引理3.5的矛盾。由该引理，一定存在某一个 使得 整除 ，这是不可能的，因为每个 都是与 不同的素数。 因此，正整数 nnn 的素因子分解是唯一的。■\\qquad\\qquad\\qquad\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 整数分解中把素因子组合成幂的形式被称为 素幂因子分解（prime-power factorization）。 唯一因子分解在哪里不成立：略。 素因子分解的应用 素数 ppp 整除 nnn 当且仅当它出现在 nnn 的素幂因子分解中。 一个素数 ppp 能整除 nnn 的最高次幂是 ppp 在 nnn 的素幂因子分解中的幂次。 一个整数 ddd 整除 nnn 当且仅当 ddd 的素幂因子分解中出现的所有素数都在 nnn 的素幂因子分解中出现，且其出现的幂次大于等于在 ddd 的素幂因子分解中的幂次。 \\qquad用素因子分解来求最大公因子，设 min⁡(a, b)\\min(a,\\ b)min(a, b) 为 a, ba,\\ ba, b 中较小的一个。现在设 a, ba,\\ ba, b 的素因子分解为 \\qquad\\qquad\\qquada=p1a1p2a2⋯pnana=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}a=p1a1​​p2a2​​⋯pnan​​，b=p1b1p2b2⋯pnbnb=p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}b=p1b1​​p2b2​​⋯pnbn​​ 其中 p1, p2,⋯ ,pnp_1,\\ p_2,\\cdots,p_np1​, p2​,⋯,pn​ 是出现在 a, ba,\\ ba, b 的素幂因子分解中的素数（对某些 iii，有可能有 ai=0a_i=0ai​=0 或 bi=0b_i=0bi​=0 ） 可得 (a, b)=p1min⁡(a1, b1)p2min⁡(a2, b2)⋯pnmin⁡(an, bn)\\qquad(a,\\ b)=p_1^{\\min(a_1,\\ b_1)}p_2^{\\min(a_2,\\ b_2)} \\cdots p_n^{\\min(a_n,\\ b_n)}(a, b)=p1min(a1​, b1​)​p2min(a2​, b2​)​⋯pnmin(an​, bn​)​ ，这是因为对每个素数 pip_ipi​ ， a, ba,\\ ba, b 恰好共同拥有 min⁡(ai, bi)\\min(a_i,\\ b_i)min(ai​, bi​) 个因子 pip_ipi​ 。 定义：两个非 0 整数 a, ba,\\ ba, b 的 最小公倍数（the least common multiple）是能够被 a, ba,\\ ba, b 整除的最小正整数。 a, ba,\\ ba, b 的最小公倍数记为 [a, b][a,\\ b][a, b] ，也可写成 lcm⁡(a, b)\\operatorname{lcm}(a,\\ b)lcm(a, b) 。 \\qquad用素因子分解求最小公倍数：如果 a=p1a1p2a2⋯pnana=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}a=p1a1​​p2a2​​⋯pnan​​ ，b=p1b1p2b2⋯pnbnb=p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}b=p1b1​​p2b2​​⋯pnbn​​ ，则对一个能够被 a, ba,\\ ba, b 同时整除的整数，其素幂因子分解中必须出现 pjp_jpj​ 且其幂次至少与 aj, bja_j,\\ b_jaj​, bj​ 一样大。因此，能够被 a, ba,\\ ba, b 同时整除的最小正整数 [a, b][a,\\ b][a, b] 为 [a, b]=p1max⁡(a1, b1)p2max⁡(a2, b2)⋯pnmax⁡(an, bn)\\qquad\\qquad\\qquad\\qquad [a,\\ b]=p_1^{\\max(a_1,\\ b_1)}p_2^{\\max(a_2,\\ b_2)} \\cdots p_n^{\\max(a_n,\\ b_n)}[a, b]=p1max(a1​, b1​)​p2max(a2​, b2​)​⋯pnmax(an​, bn​)​ 其中 max⁡(x, y)\\max(x,\\ y)max(x, y) 表示 x, yx,\\ yx, y 中较大的。 求大整数的素因子分解比较耗费时间。因此我们想要一种求两个整数的最小公倍数但不使用素因子分解的方法。可以由两个正整数的最大公因子求它们的最小公倍数。为此，我们需要证明下面的引理。 引理 3.6 引理 3.6：如果 x,yx,yx,y 是实数，则 max⁡(x, y)+min⁡(x,y)=x+y\\max(x,\\ y)+\\min(x, y)=x+ymax(x, y)+min(x,y)=x+y 。 证明：如果 x&gt;yx&gt;yx&gt;y ，则 如果 x&lt;yx &lt;yx&lt;y ， 如果 x=yx=yx=y ， 定理 3.16 定理3.16：如果 a, ba,\\ ba, b 是正整数，则 [a, b]=ab/(a, b)[a,\\ b]=ab/(a,\\ b)[a, b]=ab/(a, b) ，其中 [a, b][a,\\ b][a, b] 和 (a, b)(a,\\ b)(a, b) 分别是 a, ba,\\ ba, b 的最小公倍数和最大公因子。 证明：设 a, ba,\\ ba, b 的素幂因子分解为 a=p1a1p2a2⋯pnana=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}a=p1a1​​p2a2​​⋯pnan​​ ，b=p1b1p2b2⋯pnbnb=p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}b=p1b1​​p2b2​​⋯pnbn​​ 。现在设 Mj=max⁡(aj, bj)M_j=\\max(a_j,\\ b_j)Mj​=max(aj​, bj​) ，mj=min⁡(aj, bj)m_j=\\min(a_j,\\ b_j)mj​=min(aj​, bj​) 则有 [a, b](a, b)=p1M1p2M2⋯pnMnp1m1p2m2⋯pnmn=p1M1+m1p2M2+m2⋯pnMn+mn=p1a1+b1p2a2+b2⋯pnan+bn=p1a1p2a2⋯pnanp1b1p2b2⋯pnbn=ab\\begin{align*} [a,\\ b](a,\\ b)&amp;=p_1^{M_1}p_2^{M_2}\\cdots p_n^{M_n}p_1^{m_1}p_2^{m_2}\\cdots p_n^{m_n}\\\\ &amp;=p_1^{M_1+m_1}p_2^{M_2+m_2}\\cdots p_n^{M_n+m_n}\\\\ &amp;=p_1^{a_1+b_1}p_2^{a_2+b_2}\\cdots p_n^{a_n+b_n}\\\\ &amp;=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}\\\\ &amp;=ab \\end{align*} [a, b](a, b)​=p1M1​​p2M2​​⋯pnMn​​p1m1​​p2m2​​⋯pnmn​​=p1M1​+m1​​p2M2​+m2​​⋯pnMn​+mn​​=p1a1​+b1​​p2a2​+b2​​⋯pnan​+bn​​=p1a1​​p2a2​​⋯pnan​​p1b1​​p2b2​​⋯pnbn​​=ab​ 这是因为根据引理 3.6 ， Mj+mj=max⁡(aj, bj)+min⁡(aj, bj)=aj+bjM_j+m_j=\\max(a_j,\\ b_j)+\\min(a_j,\\ b_j)=a_j+b_jMj​+mj​=max(aj​, bj​)+min(aj​, bj​)=aj​+bj​ 。■\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 引理 3.7 算术基本定理的推论 引理 3.7：设 m, nm,\\ nm, n 是互素的正整数，那么如果 ddd 是 mnmnmn 的一个正因子，则存在唯一的一对 mmm 的正因子 d1d_1d1​ 和 nnn 的正因子 d2d_2d2​ 使得 d=d1d2d=d_1d_2d=d1​d2​ 。反之，如果 d1d_1d1​ 和 d2d_2d2​ 分别是 mmm 和 nnn 的正因子，则 d=d1d2d=d_1d_2d=d1​d2​ 是 mnmnmn 的正因子。 证明： 狄利克雷定理中一种特殊情形的证明（略 引理 3.8 定理 3.17 定理 3.17：存在无穷多个形如 4n+34n+34n+3 的素数，其中 nnn 为正整数。 关于无理数的结果 定理 3.18 定理 3.19 算术基本定理可以用来证明下面的结果，它将著名的黎曼 zeta 函数和素数联系起来。 定理 3.19： 证明： 3.6 因子分解法和费马数 因子分解 试除法 vector&lt;PII&gt; primes;void div(int x)&#123; for(int i = 2; i * i &lt;= x; i++) &#123; if(x % i == 0)&#123; int cnt = 0; while(x % i == 0) x /= i, cnt ++; primes.push_back(&#123;i, cnt&#125;); &#125; if(i * i &gt; x) break;// 任意合数必有一个小于等于sqrt(x)d &#125; if(x &gt; 1) priems.push_back(&#123;x, 1&#125;);&#125; 17世纪初，费马给出了一种因子分解的方法，这个方法是基于将一个合数表示成两个平方数的差的形式。这个方法在理论和某些实际应用中是相当重要的，但是它本身并不是一个十分有效的方法。它基于下面的引理。 引理 3.9 引理 3.9：如果 nnn 是一个正的奇数，那么 nnn 分解为两个正整数的积和表示成两个平方数的差是一一对应的。 证明： 费马因子分解在用来分解一个具有两个相似大小的因子的整数时最有效。尽管费马因子分解很少被用来分解大整数，但是它 的基本思想是计算机计算中广泛使用的很多更有效因子分解算法的基础。 费马数 定理 3.20 利用费马数证明素数无穷性：利用费马数证明存在无穷多的素数是有可能的。我们从证明两个不同的费马数是互素的开始。这将会用到下面的引理。 引理 3.10 定理 3.21 费马素数与几何：费马素数在几何学中很重要 定理 3.22 3.7 线性丢番图方程 \\qquad考虑下面的问题：一个人想购买 510 美元的旅游支票。支票只有 20 美元和 50 美元两种。那么每一种应该买多少？如果令 x 表示他应该买的 20 美元支票的数量，y 表示 50 美元支票的数量，那么就应满足方程 20x+50y=51020x+50y=51020x+50y=510 。为了解决这一问题，应该求出这个方程的所有解，其中 x, yx,\\ yx, y 为非负整数。 \\qquad类似的问题出现在当一个妇女想邮寄一个包裹时。邮局的职员测定邮寄这个包裹的费用是 83 美分，但是只有 6 美分和 15 美分的邮票。那么是否有这两种邮票的组合后的面值恰好可以来邮寄这个包裹呢？为了回答这个问题，我们先令 xxx 表示 6 美分邮票的数量，令 yyy 表示 15 美分邮票的数量。那么有 6x+15y=836x+15y=836x+15y=83 ，其中 x, yx,\\ yx, y 是非负整数。 \\qquad当我们需要求解特定方程的整数解的时候，就得到了一个 丢番图方程。这些方程是根据古希腊数学家丢番图而命名的，他写下了一些方程并将解限定在有理数域上。方程 ax+by=cax+by=cax+by=c （其中 a, b, ca,\\ b,\\ ca, b, c 是整数）被称为 关于两个变量的线性丢番图方程。 定理 3.23 下面的定理说明什么时候这类方程有解，当有解的时候又如何明确地描述它们。 定理 3.23：设 a, ba,\\ ba, b 是整数且 d=(a, b)d=(a,\\ b)d=(a, b) 。如果 d∤cd\\nmid cd∤c ，那么方程 ax+by=cax+by=cax+by=c 没有整数解。如果 d∣cd\\mid cd∣c ，那么存在无穷多个整数解。另外，如果 x=x0x=x_0x=x0​ ，y=y0y=y_0y=y0​ 是方程的一个特解，那么所有的解可以表示为 x=x0+(b/d)ny=y0−(a/d)n\\qquad\\qquad\\qquad\\qquad\\qquad x=x_0+(b/d)n \\qquad y=y_0-(a/d)nx=x0​+(b/d)ny=y0​−(a/d)n 其中 nnn 是整数。 证明：假设 x, yx,\\ yx, y 是整数满足 ax+by=cax+by=cax+by=c 。那么因为 d∣ad\\mid ad∣a ，d∣bd\\mid bd∣b ，由定理 1.9 同样有 d∣cd\\mid cd∣c 。因此如果 d∤cd\\nmid cd∤c ，那么这个方程就不存在整数解。 \\qquad现在假设 d∣cd\\mid cd∣c ，由定理 3.8 ，存在整数 s, ts,\\ ts, t 使得 d=as+bt(1)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad d=as+bt \\qquad\\qquad\\qquad\\qquad (1)d=as+bt(1) 因为 d∣cd\\mid cd∣c ，有整数 eee 使得 de=cde=cde=c 。在（1）两边同时乘以 eee ，我们有 c=de=(as+bt)e=a(se)+b(te)c=de=(as+bt)e=a(se)+b(te)c=de=(as+bt)e=a(se)+b(te) 。 因此，x=x0x=x_0x=x0​ ，y=y0y=y_0y=y0​ ，就是方程的一个解，其中 x0=sex_0=sex0​=se ，y0=tey_0=tey0​=te 。 \\qquad为了证明方程存在无穷多个解，令 x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n ，y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n ，其中 nnn 是整数。首先为了证明任何一对整数 (x, y)(x,\\ y)(x, y) ，x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n ，y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n ，nnn 是整数，它是方程的解。然后再证明方程的任何一个解都具有这种形式。 \\qquad易知 (x, y)(x,\\ y)(x, y) 是解，这是因为 ax+by=ax0+a(b/d)n+by0−b(a/d)n=ax0+by0=cax+by=ax_0+a(b/d)n+by_0-b(a/d)n=ax_0+by_0=cax+by=ax0​+a(b/d)n+by0​−b(a/d)n=ax0​+by0​=c 。 \\qquad我们现在证明方程 ax+by=cax+by=cax+by=c 的解都具有定理中所描述的那种形式。假设整数 x, yx,\\ yx, y 满足 ax+by=cax+by=cax+by=c 。因为 ax0+by0=cax_0+by_0=cax0​+by0​=c ，做减法得到 (ax+by)−(ax0+by0)=0(ax+by)-(ax_0+by_0)=0(ax+by)−(ax0​+by0​)=0 ，这就说明 a(x−x0)+b(y−y0)=0a(x-x_0)+b(y-y_0)=0a(x−x0​)+b(y−y0​)=0 。因此 a(x−x0)=b(y0−y)a(x-x_0)=b(y_0-y)a(x−x0​)=b(y0​−y) 。两边同时除以 ddd ，得 (a/d)(x−x0)=(b/d)(y0−y)(a/d)(x-x_0)=(b/d)(y_0-y)(a/d)(x−x0​)=(b/d)(y0​−y) 。由定理 3.6 ， (a/d, b/d)=1(a/d,\\ b/d)=1(a/d, b/d)=1 。用引理 3.4 ，有 (a/d)∣(y0−y)(a/d)\\mid (y_0-y)(a/d)∣(y0​−y) 。因此，存在整数 nnn 使得 (a/d)n=(y0−y)(a/d)n=(y_0-y)(a/d)n=(y0​−y) 。这就意味着 y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n 。现在将这个 yyy 值代入方程 a(x−x0)=b(y0−y)a(x-x_0)=b(y_0-y)a(x−x0​)=b(y0​−y) ，我们得到 a(x−x0)=b(a/d)na(x-x_0)=b(a/d)na(x−x0​)=b(a/d)n 。这就得到了 x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n 。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理 3.24 可以将定理 3.23 推广为多个变量的线性丢番图方程。下面的定理给出了这个推广。 定理 3.24：如果 a1, a2,⋯ , ana_1,\\ a_2,\\cdots,\\ a_na1​, a2​,⋯, an​ 是非零整数，那么方程 a1x1+a2x2+⋯+anxn=ca_1x_1+a_2x_2+\\cdots+a_nx_n=ca1​x1​+a2​x2​+⋯+an​xn​=c 有整数解当且仅当 d=(a1,a2,⋯ ,an)d=(a_1,a_2,\\cdots,a_n)d=(a1​,a2​,⋯,an​) 整除 ccc 。另外当存在一个解的时候，方程有无穷多个解。 证明：如果存在整数 x1,x2,⋯ ,xnx_1,x_2,\\cdots,x_nx1​,x2​,⋯,xn​ 满足 a1x1+a2x2+⋯+anxn=ca_1x_1+a_2x_2+\\cdots+a_nx_n=ca1​x1​+a2​x2​+⋯+an​xn​=c ，则由于 ddd 整除 ai, i=1,2,⋯ ,na_i,\\ i=1,2,\\cdots,nai​, i=1,2,⋯,n ，故由定理 1.9 ，ddd 整除 ccc 。因此，如果 d∤cd\\nmid cd∤c ，则方程不存在解。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"第一章 整数","slug":"读书笔记/初等数论及其应用/第一章 整数","date":"2021-08-22T16:00:00.000Z","updated":"2021-11-25T10:39:14.910Z","comments":true,"path":"posts/f640105/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f640105/","excerpt":"","text":"大纲 在最一般的意义下，数论研究各种数集合的性质。 在本章中我们讨论某些特别重要的 数的集合 ，包括整数、有理数和代数数集合。 我们将简单介绍 用有理数逼近实数 的概念，也介绍 序列 (特别是整数序列)的概念，包括古希腊人所研究的一些 垛积数序列 。 一个常见问题是如何由一些初始项来判定一个特别的整数序列。我们将简单讨论一下如何解决这种问题。 利用序列概念，我们定义 可数集合 并且证明 有理数集合是可数的 。我们还引进了求和符号 和 求积符号 ，并建立一些有用的求和公式。 数学归纳法 是数论(和许多数学分支)中最重要的证明方法之一。我们讨论数学归纳法的两种形式，说明如何用它们来证明各种结果，并且解释数学归纳法为什么是一种有效的证明手段。 然后我们介绍著名的 斐波那契 (Fibonacci)数序列，讲述引出这种数的原始问题。 我们将建立与斐波那契数有关的一些恒等式和不等式，其中有些证明就使用了数学归纳法。 本章最后一节讲述数论的一个基本概念：整除性 。 我们将建立整数除法的基本性质，包括带余除法，还将解释如何用 最大整数函数 来表示一个整数去除另一个整数的商和余数。（也讲述了最大整数函数许多有用的性质） 1.1 数和序列 本节将介绍一些基础知识，它们在本书中通篇使用。 特别地，我们将涉及数论中所研究的重要的数集合、整数序列的概念、求和与求积符号。 良序性质 良序性质：每个非空的正整数集合都有一个最小元。 良序性质可以作为定义正整数集合的 公理 ，或者由一组公理推导出来。 正整数集合 定理1.1-2\\sqrt{2}2​ 是无理数 定理1.1： 2\\sqrt{2}2​ 是无理数。 证明1：设 2=pq\\sqrt{2}=\\dfrac{p}{q}2​=qp​ 互质，证明 p,qp,qp,q 为偶数。 证明2：使用良序性。 定义：如果存在整数 p,q≠0p,q\\ne 0p,q=0 ，使得 r=p/qr=p/qr=p/q ，则称实数 rrr 是 有理数 。否则 rrr 为 无理数 。 整数集合、正整数集合、有理数集合和实数集合通常分别记为 \\Z,\\Z+,\\Q,\\R 。我们也用 x∈Sx\\in Sx∈S 来表示 xxx 属于集合 SSS 。 「最大整数函数」： xxx 中的最大整数记为 [x][x][x] ，是小于或等于 xxx 的最大整数，即 [x][x][x] 是满足 [x]≤x&lt;[x]+1[x]\\le x&lt;[x]+1[x]≤x&lt;[x]+1 的整数。最大整数函数也被称为取整函数（floor function）。在计算机科学中通常用记号 ⌊x⌋\\lfloor x \\rfloor⌊x⌋ 代替 [x][x][x] 。 「上整数函数」：记为 ⌈x⌉\\lceil x \\rceil⌈x⌉ ，是大于或等于 xxx 的最小整数。 例1.4：证明如果 nnn 是整数，则对于任意实数 xxx ，都有 [x+n]=[x]+n[x+n]=[x]+n[x+n]=[x]+n 。 定义：实数 zzz 的分数部分（fractional part）记为 {x}\\{x\\}{x} ，是 xxx 与 [x][x][x] 的差，即 {x}=x−[x]\\{x\\}=x-[x]{x}=x−[x] 。 丢番图逼近 我们知道一个实数和与之最接近的整数的距离不超过 12\\dfrac{1}{2}21​ 。但我们可否证明一个实数的前 kkk 个倍数中的某一个一定更接近某个整数？ 数论中一个很重要的部分称为丢番图逼近，它正是研究这类问题的。特别地，丢番图逼近着重研究用有理数逼近实数的问题。 我们将要证明在实数 $\\alpha $ 的前 nnn 个倍数中至少有一个实数与最接近它的整数的距离小于 1n\\dfrac{1}{n}n1​ 。 这个证明是基于德国数学家狄利克雷(Dirichlet)提出的鸽笼原理。 定理1.2-鸽笼原理 定理1.2 鸽笼原理：如果把 k+1k+1k+1 个或者更多的物体放入 kkk 个盒子中，那么至少有一个盒子中有两个或更多的物体。 证明： 如果 kkk 个盒子中的任何一个中都没有多于一个的物体，那么所有物体的总数至多为 kkk 。这个矛盾说明有一个盒子中至少有两个或者更多的物体。 定理1.3-狄利克雷逼近原理 现在我们来叙述并证明狄利克雷逼近定理，它能够保证一个实数的前 nnn 个倍数之一必定在某个整数的 1/n1/n1/n 邻域内。 定理1.3（狄利克雷逼近定理）：如果 α\\alphaα 是一个实数，nnn 是一个正整数，则存在整数 a,b,1≤a≤na,b,1\\le a\\le na,b,1≤a≤n，使得 ∣a×a−b∣&lt;1/n|a\\times a-b|&lt;1/n∣a×a−b∣&lt;1/n 。 考虑 n+1n+1n+1 个数 。这 n+1n+1n+1 个数是数 的分数部分，所以 。这 个数中的每一个都位于 个互不相交的区间中的一个。 对于定理 1.3 我们采取的是狄利克雷1834年的原始证明。把定理1.3中的 替换为 ,可以得到一个更强的结论。它的证明并不困难(见习题32)。进一步，在习题34中我们展示如何用狄利克雷逼近定理来证明对于一个无理数 ，存在无数多个不同的有理数 使得 。这是丢番图逼近定理中的一个重要结果。我们将在第12章再回到这个话题 序列：序列 {an}\\{ a_n\\}{an​} 是一列数 a1,a2,a3,⋯a_1,a_2,a_3,\\cdotsa1​,a2​,a3​,⋯ 。 数论中的一个常见问题是如何寻找构造序列的通项公式或者规则。 我们现在定义什么是可数集，并且证明：当且仅当一个集合的元素可以被列为一个序列时，它是可数的。 定义一个集合可数（countable），如果它是有限的或者是无穷的但与正整数集合之间存在一个一一映射。如果一个集合不是可数的，则称为不可数（uncountable）。 一个无穷集合是可数的当且仅当其中的元素可以被列为一个由正整数标记的序列。为了看到这一点，只需注意从正整数集合到一个集合 sss 的一一映射 fff 其实就是把集合中的元素列成序列 a1,a2,⋯ ,an,⋯a_1,a_2,\\cdots,a_n,\\cdotsa1​,a2​,⋯,an​,⋯ ，其中 ai=f(i)a_i=f(i)ai​=f(i) 。 定理1.4-有理数集合是可数的 定理1.4：有理数集合是可数的。 习题45将会证明实数集合不可数。 1.2 和与积 和的记号： ∑k=1nak=a1+a2+⋯+an\\displaystyle \\sum_{k=1}^{n}a_k=a_1+a_2+\\cdots+a_nk=1∑n​ak​=a1​+a2​+⋯+an​ 。字母 kkk 称为 求和下标（index of summation）。 三个和式 ∑j=mn(c×aj)=c∑j=mnaj\\displaystyle \\sum_{j=m}^{n}(c\\times a_j)=c\\sum_{j=m}^{n}a_jj=m∑n​(c×aj​)=cj=m∑n​aj​ ； ∑j=mn(aj+bj)=∑j=mnaj+∑j=mnbj\\displaystyle \\sum_{j=m}^{n}(a_j+b_j)=\\sum_{j=m}^{n}a_j+\\sum_{j=m}^{n}b_jj=m∑n​(aj​+bj​)=j=m∑n​aj​+j=m∑n​bj​ ； ∑i=mn∑j=pqaibj=(∑i=mnai)(∑j=pqbj)=∑j=pq∑i=mnaibj\\displaystyle \\sum_{i=m}^{n}\\sum_{j=p}^{q}a_ib_j= \\left(\\sum_{i=m}^{n}a_i \\right )\\left(\\sum_{j=p}^{q}b_j \\right)=\\sum_{j=p}^{q}\\sum_{i=m}^{n}a_ib_ji=m∑n​j=p∑q​ai​bj​=(i=m∑n​ai​)(j=p∑q​bj​)=j=p∑q​i=m∑n​ai​bj​ ； 例1.15 求等比数列 的前 n+1n+1n+1 项的和。 推导出 当 。 例1.17 证明：2 的前 nnn 个连续方幂之和比 2 的下一个方幂小 1。即 ∑i=0n2i=2n+1−1\\displaystyle \\sum_{i=0}^{n}2^i=2^{n+1}-1i=0∑n​2i=2n+1−1 。 证明： 形如 ∑i=1n(ai−ai−1)\\displaystyle \\sum_{i=1}^{n}(a_i-a_{i-1)}i=1∑n​(ai​−ai−1)​ 的和被称为是 叠进的 。其中 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 是一数列。 \\qquad\\qquad\\qquad ∑i=1n(ai−ai−1)=(an−an−1)+⋯+(a2−1)+(a1−a0)=an−a0\\displaystyle \\sum_{i=1}^{n}(a_i-a_{i-1})=(a_n-a_{n-1})+\\cdots +(a_2-_1)+(a_1-a_0)=a_n-a_0i=1∑n​(ai​−ai−1​)=(an​−an−1​)+⋯+(a2​−1​)+(a1​−a0​)=an​−a0​ 。 例1.18 三角数 t1,t2,t3,⋯ ,tk,⋯t_1,t_2,t_3,\\cdots,t_k,\\cdotst1​,t2​,t3​,⋯,tk​,⋯ 是一个数列，其中 tkt_ktk​ 为第 jjj 行有 jjj 个点的 kkk 行三角阵列中点的个数。 推导 tnt_ntn​ 的另一种求法见习题7。 与求和类似，我们也给乘积定义一个记号。数 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 的积记为 ∏k=1nak=a1×a2×⋯an\\displaystyle \\prod_{k=1}^{n}a_k=a_1\\times a_2\\times\\cdots a_nk=1∏n​ak​=a1​×a2​×⋯an​ 。 字母 jjj 为虚变量，可以用任意字母代替。 阶乘函数在数论中通篇出现。 定义：设 nnn 为正整数，则 n!n!n!（读作“ nnn 的阶乘”）是整数 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 的积。0!=10!=10!=1。采用乘积符号，我们有 n!=∏j=1njn!=\\displaystyle \\prod_{j=1}^{n}jn!=j=1∏n​j。 1.3 数学归纳法 定理1.5-数学归纳原理 使用数学归纳法证明一个特定命题对所有正整数都成立必须实现「两步」。 第一，设 SSS 为我们认为命题成立的那个正整数集合，必须说明 1 属于 SSS ；即命题对整数 1 为真。这叫做基础步骤。 第二，必须证明对每个正整数 nnn，如果 nnn 属于 SSS 则 n+1n+1n+1 也属于 SSS ；即如果这个命题对 nnn 为真，则对 n+1n+1n+1 也为真。这被称为归纳步骤。 一旦这两步都完成了，我们就可以由数学归纳原理得到结论：命题对所有正整数为真。 定理1.5（数学归纳原理）：一个包含整数 1 的正整数集合如果具有如下性质，即若其包含整数 kkk ，则其也包含整数 k+1k+1k+1 ，那么这个集合一定是所有正整数的集合。 证明 ：设 是包含整数 的正整数集合，并且如果它包含整数 ，则一定包含 。假定(为了推出矛盾) 不是所有正整数的集合。因此有某个正整数不包含在集合 中。由「良序性质」，由于不包含在 中的正整数集合是非空的，所以不包含于 中的所有正整数中存在一个最小的正整数，记为 。注意由于 在中，故 。 现在，由于 （因为不存在正整数 满足 ），故 是小于 的正整数，并且 一定在集合 中。但是因为包含 ，从而一定包含 。这与假定为不包含于 中的最小整数矛盾。这说明 一定是所有正整数的集合。 例：证明 : 对于正整数，有 基础步骤 :，所以这一步成立。 归纳步骤 :我们的归纳假设为公式对于 成立，即假定 .使用归纳假设，我们有 由于基础步骤和归纳步骤都完成了，我们知道结果成立。 例：证明 :，对任意正整数 成立。 基础步骤 归纳步骤 定理1.6-第二数学归纳原理 定理1.6（第二数学归纳原理）：对于包含 的正整数集合，如果它具有下述性质：对每一个正整数 。如果它包含全体正整数 ，则它也包含整数 ，那么这个集合一定是由所有正整数构成的集合。 证明：设是一个包含的整数集合，并且对任意正整数 ，如果它包含，则它也包含 。设 是所有正整数 的集合， 满足：小于等于 的正整数都在 中。则 在 中，并且，根据假设，我们看到如果 在 中，则 在 中。因此，由数学归纳法原理，必为所有正整数的集合，故显然 也是所有正整数的集合，因为 是 的一个子集。 1能使命题成立。 若 均使命题成立，则可推出 也使命题成立。 为了区别于数学归纳原理，第二数学归纳原理有时也称为强归纳，而数学归纳原理也 称为弱归纳。 递归定义 数学归纳原理提供了一种方法来定义函数在正整数处的值。我们不用明确给出函数在 nnn 处的值，而是给出其在 1 处的值，并且给出对于任意正整数 nnn ，从函数在 nnn 处的值来寻找在 n+1n+1n+1 处的值的规则。 定义：我们说函数 fff 是 递归定义 的，如果指定了 fff 在 1 处的值，而且对于任意正整数 nnn ，都提供了一个规则来根据 f(n)f(n)f(n) 确定 f(n+1)f(n+1)f(n+1) 。 数学归纳原理可以用来证明 递归定义的函数在每个正整数上都是唯一定义的（参看本节末尾的习题25）。 第二数学归纳原理也可以作为递归定义的基础。我们可以如下定义一个定义域为正整数集合的函数：首先指定它在 1 处的值，并且对每个正整数 nnn，给定一个根据 f(j),1≤j≤n−1f(j),1\\le j\\le n-1f(j),1≤j≤n−1 的值求 f(n)f(n)f(n) 的规则。这将是在1.4节中讨论的斐波那契数序列的定义的基础。 1.4 斐波那契数 定义：斐波那契序列有如下递归定义：f1=1,f2=1f_1=1,f_2=1f1​=1,f2​=1，且对 n≥3n\\ge 3n≥3，fn=fn−1+fn−2f_n=f_{n-1}+f_{n-2}fn​=fn−1​+fn−2​，这个序列中的项被称为斐波那契数。 斐波那契数满足相当多的恒等式 。 例1.27 如证明： ∑i=1nfk=fn+2−1\\displaystyle \\sum_{i=1}^{n}f_k=f_{n+2}-1i=1∑n​fk​=fn+2​−1 ，fnf_nfn​：第 n 个斐波那契数。 叠进和 数学归纳原理 本节末的习题要求你去证明许多关于斐波那契数的其他恒等式。 斐波那契数列增长有多快 ？下面的不等式说明斐波那契数比公比为 α=(1+5)/2\\alpha=(1+\\sqrt{5})/2α=(1+5​)/2 的等比数列增长的快，这一结论将在第 3 章中应用。 例1.28 用第二数学归纳原理证明对 n≥3n\\ge 3n≥3，有 fn&gt;αn−2f_n&gt;\\alpha^{n-2}fn​&gt;αn−2 。 定理1.7 我们用第 nnn 个斐波那契数的一个显式计算公式来结束本节。我们在正文中不给出证明，但是在本节末的习题41和习题42中概述了如何分别利用线性齐次递归关系和母函数来求这个公式。进一步，习题40要求通过说明这些项满足与斐波那契数相同的递归定义来证明这个恒等式，习题45要求用数学归纳法来证明。 前两个方法的优点是它们可以用来发现公式，而后两个方法却不能。 定理1.7 设 nnn 是正整数， α=1+52\\alpha=\\dfrac{1+\\sqrt{5}}{2}α=21+5​​， β=1−52\\beta=\\dfrac{1-\\sqrt{5}}{2}β=21−5​​ 则第 nnn 个斐波那契数 fnf_nfn​ 由该式给出： fn=15(αn−βn)f_n=\\dfrac{1}{\\sqrt{5}}(\\alpha^n-\\beta^n)fn​=5​1​(αn−βn) 。 1.5 整除性 一个整数可以被另一个整数整除的概念在数论中处于中心地位。 整除定义：如果 a,ba,ba,b 为整数且 a≠0a\\ne 0a=0 ，我们说 aaa 整除 bbb 是指存在整数 ccc 使得 b=a×cb=a\\times cb=a×c 。如果 aaa 整除 bbb，我们还称 aaa 是 bbb 的因子，且称 bbb 是 aaa 的倍数。 定理1.8 定理1.8：如果 a,b,ca,b,ca,b,c 是整数，且 a∣ba\\mid ba∣b，b∣cb\\mid cb∣c ，则 a∣ca\\mid ca∣c 。（ 若 bbb 是 ccc 的因子，则 bbb 的因子也是 ccc 的因子 证明： 定理1.9 定理1.9：如果 a,b,m,na,b,m,na,b,m,n 是整数，且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b，则 c∣(ma+nb)c\\mid (ma+nb)c∣(ma+nb) ，ma+nbma+nbma+nb 是 a,ba,ba,b 的线性组合。 证明： 定理1.10 定理1.10（带余除法）：如果 a,ba,ba,b 是整数且 b&gt;0b&gt;0b&gt;0 ，则存在唯一的整数 qqq 和 rrr ，使得 a=bq+ra=b q+ra=bq+r ，0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。（ aaa 为被除数，bbb 为除数，qqq 为商Quotient，rrr 为余数Remainder） 用良序性证明带余除法。先证存在性（ TTT 中最小元 rrr 和 rrr 对应的 qqq 满足该要求），再证唯一性。 证明：如考虑形如 a−bka-bka−bk 的所有整数集合 SSS ，其中 kkk 为整数，即 S={a−bk∣k∈Z}S=\\{a-bk\\mid k\\in \\Z\\}S={a−bk∣k∈Z} 。设 TTT 是 SSS 中的所有非负整数构成的集合。TTT 是非空的，因为当 kkk 是满足 k&lt;a/bk&lt;a/bk&lt;a/b 的整数时，a−bka-bka−bk 是正的。 \\qquad由良序性质，TTT 中有最小元 r=a−bqr=a-bqr=a−bq 。根据 rrr 的构造可知 r≥0r\\ge 0r≥0 ，且容易证明 r&lt;br&lt;br&lt;b 。如果 r≥br\\ge br≥b ，则 r&gt;r−b=a−bq−b=a−b(q+1)r&gt;r-b=a-bq-b=a-b(q+1)r&gt;r−b=a−bq−b=a−b(q+1) ，这与我们选择 r=a−bqr=a-bqr=a−bq 为形如 a−bka-bka−bk 的整数中的最小元矛盾。因此 0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。 \\qquad为了证明 qqq 和 rrr 的值是唯一的，我们假定有两个方程 a=bq1+r1a=bq_1+r_1a=bq1​+r1​ 和 a=bq2+r2a=bq_2+r_2a=bq2​+r2​ ，满足 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b 和 0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b。把第二个方程从第一个方程中减去，可得 0=b(q1−q2)+(r1−r2)\\qquad\\qquad\\qquad\\qquad\\qquad0=b(q_1-q_2)+(r_1-r_2)0=b(q1​−q2​)+(r1​−r2​) 因此，\\qquad\\qquad\\qquad\\qquadr2−r1=b(q1−q2)r_2-r_1=b(q_1-q_2)r2​−r1​=b(q1​−q2​) 由此可知 bbb 整除 r2−r1r_2-r_1r2​−r1​ 。因为 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b，0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b ，故 −b&lt;r2−r1&lt;b-b&lt;r_2-r_1&lt;b−b&lt;r2​−r1​&lt;b 。因此 bbb 可以整除 r2−r1r_2-r_1r2​−r1​ 只有当 r2−r1=0r_2-r_1=0r2​−r1​=0 。我们还得到 q1=q2q_1=q_2q1​=q2​ 。这说明商 qqq 与余数 rrr 唯一的。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 因而 q=[a/b]q=[a/b]q=[a/b]，r=a−b×[a/b]r=a-b\\times [a/b]r=a−b×[a/b] 。 例1.36 证明：如果 是正整数，则当 为实数时 [x/n]=[[x]/n][x/n]=[[x]/n][x/n]=[[x]/n] 。 证明： 给定一个正整数 ddd ，可以根据整数被 ddd 除的余数把它们分类。 定义：如果 nnn 被 2 除的余数为 0 ，则对某个整数 kkk ，有 n=2kn=2kn=2k ，我们称 nnn 为偶数；而如果 nnn 被 2 除的余数为 1，则对某个整数 kkk ，有 n=2k+1n=2k+1n=2k+1 ，我们称 nnn 为奇数。 类似地，当 d=4d=4d=4 时，我们从带余除法中看到当整数被 4 除时，余数为 0，1，2，3。因此每个整数都形如 4k, 4k+1, 4k+2, 4k+34k,\\ 4k+1,\\ 4k+2,\\ 4k+34k, 4k+1, 4k+2, 4k+3 ，其中为正整数。 我们将在第4章继续讨论这个问题。 最大公因子 定义：不全为零的整数 a,ba,ba,b 的最大公因子是指能同时整除 a,ba,ba,b 的最大整数。 a,ba,ba,b 的最大公因子记为 (a,b)(a,b)(a,b) ，有时也记为 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 。 注意当 nnn 为正整数时， (0,n)=(n,0)=n(0,n)=(n,0)=n(0,n)=(n,0)=n 。 利用整数的有序性定义了整数的最大公因子。 虽然所有的正整数都能整除 0 ，我们是还定义 (0,0)=0(0,0)=0(0,0)=0 ，这样可以确保关于最大公因子的相关结论在所有的情况下均成立。 定义：设 a,ba,ba,b 均为非零整数，如果 a,ba,ba,b 的最大公因子 (a,b)=1(a,b)=1(a,b)=1 ，则称 a,ba,ba,b 互素 。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"贪心算法的证明","slug":"DS_Algorithm证明与讲解/贪心/贪心算法的证明","date":"2021-08-21T16:00:00.000Z","updated":"2021-11-25T10:39:14.853Z","comments":true,"path":"posts/540c51f7/","link":"","permalink":"http://xiaoke-jin.github.io/posts/540c51f7/","excerpt":"","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"离散化","slug":"DS_Algorithm证明与讲解/杂项算法/离散化","date":"2021-08-15T16:00:00.000Z","updated":"2021-12-04T02:35:04.071Z","comments":true,"path":"posts/515818b4/","link":"","permalink":"http://xiaoke-jin.github.io/posts/515818b4/","excerpt":"","text":"思路 保序 将所有值排序 去重 二分查找 无序 const int N = 1e5 + 10;unordered_map&lt;int, int&gt; hash;int p[N];int get(int x) // 无序离散化&#123; if(h.count(x) == 0) hash[x] = ++ n; return hash[x];&#125;int main()&#123; int cnt = 0; hash.clear(); for(int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; p[i] = get(l); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://xiaoke-jin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford","date":"2021-08-15T03:19:20.673Z","updated":"2021-11-25T10:39:14.781Z","comments":true,"path":"posts/0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BFS","slug":"DS_Algorithm证明与讲解/搜索/BFS题目","date":"2021-08-14T16:00:00.000Z","updated":"2022-02-02T03:55:48.032Z","comments":true,"path":"posts/d81e6871/","link":"","permalink":"http://xiaoke-jin.github.io/posts/d81e6871/","excerpt":"","text":"经典题 八数码（及其有解判断） 多源BFS AcWing 173. 矩阵距离 最小步数模型 AcWing 1107. 魔板 双端队列广搜 AcWing 175. 电路维修 洛谷 P1948 [USACO08JAN]Telephone Lines S 洛谷 CF1063B Labyrinth 洛谷 CF1031D Minimum path 双向广搜 AcWing 190. 字串变换 A* AcWing 178. 第K短路：估价函数 AcWing 179. 八数码：估价函数","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Dijkstra 详解及其证明","slug":"DS_Algorithm证明与讲解/图论/最短路/Dijkstra","date":"2021-08-14T16:00:00.000Z","updated":"2021-12-04T02:33:56.544Z","comments":true,"path":"posts/9c98f56c/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9c98f56c/","excerpt":"","text":"Dijkstra证明 朴素版Dijkstra 堆优化版 Dijkstra","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://xiaoke-jin.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"BFS求单源最短路证明","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS求单源最短路证明","date":"2021-08-13T16:00:00.000Z","updated":"2021-11-25T10:39:14.882Z","comments":true,"path":"posts/a1d0d7ff/","link":"","permalink":"http://xiaoke-jin.github.io/posts/a1d0d7ff/","excerpt":"","text":"BFS求单源最短路证明 2021-08-15 算法导论 P364 挖个坑，日后补充。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"搜索讲解","slug":"DS_Algorithm证明与讲解/搜索/BFS&DFS","date":"2021-08-12T16:00:00.000Z","updated":"2021-11-25T10:39:14.830Z","comments":true,"path":"posts/89316801/","link":"","permalink":"http://xiaoke-jin.github.io/posts/89316801/","excerpt":"","text":"四联通与八联通 「四联通」 int dx[5] = &#123;-1, 0, 1, 0&#125;, dy[5] = &#123;0, 1, 0, -1&#125;;for(int i = 0; i &lt; 4; i++) for(int j = 0; j &lt; 4; j++)&#123; int nx = x + dx[i], ny = y + dy[j]; &#125; 「八连通」 // 1int dx[10] = &#123;-1, -1, 0, 1, 1, 1, 0, -1&#125;, dy[10] = &#123;0, 1, 1, 1, 0, -1, -1, -1&#125;;// 2for(int i = x - 1; i &lt;= x + 1; i++) for(int j = y - 1; j &lt;= y + 1; j++)&#123; if(i == x &amp;&amp; j == y)continue; // 遍历到自己，跳过&#125; 康托展开 P5367 【模板】康托展开","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS求最短路","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS大纲","date":"2021-08-12T16:00:00.000Z","updated":"2021-11-25T10:39:14.882Z","comments":true,"path":"posts/77d71e94/","link":"","permalink":"http://xiaoke-jin.github.io/posts/77d71e94/","excerpt":"","text":"本质：转换为Dijkstra 扩展 多源BFS 最小步数模型 双端队列广搜 双向广搜 A*","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"高精度板子","slug":"DS_Algorithm证明与讲解/杂项算法/高精度板子","date":"2021-08-11T16:00:00.000Z","updated":"2022-01-13T14:31:42.675Z","comments":true,"path":"posts/b27525ce/","link":"","permalink":"http://xiaoke-jin.github.io/posts/b27525ce/","excerpt":"","text":"C/C++ __int128的使用： https://blog.csdn.net/WHY995987477/article/details/100325984 加 ​ 减 ​ 乘 ​ 除 ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://xiaoke-jin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"常用Cpp语法(STL + 一些 trick)","slug":"DS_Algorithm证明与讲解/STL","date":"2021-08-10T16:00:00.000Z","updated":"2022-03-31T05:26:36.294Z","comments":true,"path":"posts/f7523d04/","link":"","permalink":"http://xiaoke-jin.github.io/posts/f7523d04/","excerpt":"","text":"【C++】标准模板库（STL）：超快入门！算法竞赛必看！ 算法竞赛中常用的STL及其常见操作 算法竞赛中常用的语法操作 ——by 派大星 常用语法 cout &lt;&lt; &quot; \\n&quot;[1 == 1]; // 方括号内为 true输出换行符, 否则输出空格int a, b;(a - 1) / b + 1; // 向上取整// STL的size() 返回值为无符号类型 快读快写 // int isdigit(int _C): 传入 &#x27;0&#x27;-&#x27;9&#x27; 返回 1// &#x27;0&#x27; == 48template&lt;typename T&gt;inline void read(T &amp;t)&#123; t = 0; T dp = 1; char c = getchar(); while (!isdigit(c)) &#123; if (c == &#x27;-&#x27;) dp = -1; c = getchar(); &#125; while (isdigit(c)) t = (t &lt;&lt; 1) + (t &lt;&lt; 3) + (c ^ 48), c = getchar(); t *= dp;&#125;// ---------------------------------------------------inline void write(int x)&#123; if (x &lt; 0)&#123; putchar(&#x27;-&#x27;); x = -x; &#125; if (x &gt;= 10) write(x / 10); putchar(x % 10 + 48); &#125;inline void writeln(int x)&#123; write(x); puts(&quot;&quot;); &#125;inline void write_p(int x)&#123; write(x); putchar(&#x27; &#x27;); &#125;inline void write_b(int x)&#123; putchar(&#x27; &#x27;); write(x); &#125; 关闭流同步 C++ 中 printf 和 cout 什么区别？ // 关闭流同步, 关闭之后不要混合使用 scanf、printf、puts等输入输出函数。ios::sync_with_stdio(false);cin.tie(nullptr); 常用函数 reverse() sort 传入的区间左闭右开。 默认从小到大排序。cmp(a,b)返回ture时则 a 的优先级高。 lower_bound/upper_bound 左闭右开 lower_bound：大于等于 x upper_bound：小于等于 x int i = lower_bound(a, a + 10 + 1, x) - a; 在 a[0]~a[10] 之间找第一个大于等于x 的数的下标。 int i = *--upper_bound(a.begin(), a.end(), x); 在 vector a 中查找小于等于 x 的最大整数。 STL 共有的函数 size(); // 返回容器的大小 O(1)enpty(); // 返回容器是否为空 O(1) 所有的容器都可以看作是一个「前开后闭」的结构。 vector C++ vector的初始化 vector&lt;int&gt; a; // 定义一个空vectorvector&lt;int&gt; a(n); // 定义一个长度为 n的vectorvector&lt;int&gt; a(10, 3); // 定义一个长度为 10,且每个元素值为 3的vectorvector&lt;int&gt; a[10]; // 定义 10个vector[]; // 支持数组操作; 下标从0开始 clear(); // 清空vectorpush_back()/pop_back(); // 在末尾插入/删除一个元素front()/back(); // 返回第一个/最后一个元素begin()/end(); // 返回向量头指针,指向第一个元素; 返回向量尾指针,指向向量最后一个元素的「下一个位置」a.front() == *a.begin() == a[0]a.back() == *--a.end() == a[a.size() - 1] for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;--------------------------------------------------------------------------// vector&lt;int&gt;::iterator可用 auto代替for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) // unsigned cout &lt;&lt; *i &lt;&lt; &quot; &quot;;--------------------------------------------------------------------------for(auto x : a) cout &lt;&lt; x &lt;&lt; &quot; &quot;;cout &lt;&lt; endl; vector&lt;int&gt; a(4, 3), b(3, 4);// 按字典序比较if(a &lt; b) puts(&quot;a &lt; b&quot;); string string a = &quot;yxc&quot;;a += &quot;nb&quot;; // 支持 +=操作a += &#x27;1&#x27;string b = &quot;1111&quot;;b[1] = &#x27;\\0&#x27;;b[2] = &#x27; &#x27;;cout &lt;&lt; b &lt;&lt; endl; // 输出 “1 1”，空格被输出;空字符跳过,不输出;printf(&quot;%s\\n&quot;, a.c_str()); // 使用 %s输出字符串 length() // 字母个数clear() // 清空substr(n) // 返回从下标 n开始的子串substr(n, m) // 返回从下标 n开始, 长度为 m的子串; 若越界的话, 会输出到最后一个字符为止。 关于'\\0' std::string：标准中未规定需要'\\0'作为字符串结尾。编译器在实现时既可以在结尾加'\\0'，也可以不加。（因编译器不同） 但是，当通过c_str()或data()（二者在 C++11 及以后是等价的）来把std::string转换为const char *时，会发现最后一个字符是'\\0'。但是C++11，string字符串都是以'\\0'结尾。 Q：为什么 C 语言风格的字符串要以'\\0'结尾，C++可以不要？ A：C语言用 char* 指针作为字符串时，在读取字符串时需要一个特殊字符0来标记指针的结束位置，也就是通常认为的字符串结束标记。而C++语言则是面向对象的，长度信息直接被存储在了对象的成员中，读取字符串可以直接根据这个长度来读取，所以就没必要需要结束标记了。而且结束标记也不利于读取字符串中夹杂0字符的字符串。 set 不能有重复元素。默认从小到大排序。 set&lt;int&gt; a;a.insert(10); map 红黑树实现。 map&lt;int, int&gt; a;// 插入值1. a.insert(make_pair(1, 1)); // 使用 insert 时，若键已存在，则不插入2. a.insert(pair&lt;int, int&gt;(1, 1));3. a[10] = 100; // 之前不存在10则插入,存在则覆盖// 查询键的个数a.count(10); // 若存在 10,则返回1;不存在则返回 0// 查询键对应的值a[1]; // 若存在键为1的键值对，则返回对应的值；不存在则返回 0// 删除键a.erase(1); // 删除成功则返回 1，失败返回 0 priority_queue // 默认定义大根堆priority_queue&lt;int&gt; heap;// 定义小根堆// 1.插入负数// 2.priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;默认为大根堆，operator&lt;(stuct A, struct B) 返回 false 时，A的优先级高 push()top()pop()// 无 clear() pair pair&lt;int, int&gt; p;p.first; // 第一个元素p.second; // 第二个元素// 赋值1. pair&lt;int, int&gt; p = (1, 1);2. p = make_pair(10, &quot;yxc&quot;);3. p = (20, &quot;abc&quot;);4. q.push_back(&#123;1, 1&#125;); // 使用 &#123;&#125;快速构造一个pair 支持比较运算 以first为第一关键字，以second为第二关键字（字典序）。 ——— queue size()empty()push()pop()front()back()q = queue&lt;int&gt;();// 重新构造一次即可清空队列; 没有 clear函数 stack size()empty()push()pop()top() deque size()empty()clear()front()back()push_back()/pop_back()push_front()/pop_front()begin()/end()[] bitset 干货｜bitset用法 bitset&lt;n&gt; s; // 定义长度为 n的bool数组/* 支持位运算：~ &amp; | ^ &lt;&lt; &gt;&gt; * ==, != * [] */count() // 返回有多少个 1any() // 判断是否至少有一个 1none() // 判断是否全为 0set() // 把所有位置为 1set(k, v) // 将第k位变为 vreset() // 把所有位变成 0 flip() // 所有位取反flip(k) // 把第k位取反 multiset 可以有重复元素 multimap unordered_set unordered_map 使用 hash 表实现，模数固定。 在 CodeForces 上会被 hack 烂。 unordered_map&lt;key, T&gt; a; // key:键的类型, T:值的类型 unordered_multiset unordered_multimap sort 与 priority_queue 重载比较 sort 默认从小到大排序。当 bool operator&lt;(a, b) 返回true时，a 的优先级高于 b 。即 a 排在 b 前面。 priority_queue 默认为大根堆。当 bool operator&lt;(a, b) 返回false时，a 的优先级高于 b 。即 a 排在 b 上面。 #include&lt;bits/stdc++.h&gt;using namespace std;struct cmp &#123; int a; // cmp()&#123;&#125; cmp(int x) &#123; a = x; &#125; friend bool operator&lt;(const cmp &amp;b, const cmp&amp; a) &#123; return a.a &lt; b.a; &#125;&#125;;int main()&#123; // vector&lt;int&gt; a(10); // for (int i = 0; i &lt; 10; i++) // a[i] = 10 - i; // for(auto i : a) // cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; // cout &lt;&lt; endl; // sort(a.begin(), a.end(), cmp); // for(auto i : a) // cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; priority_queue&lt;cmp&gt; a; a.push(cmp(10)); a.push(cmp(1)); cout &lt;&lt; a.top().a;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"位运算详解","slug":"DS_Algorithm证明与讲解/杂项算法/位运算","date":"2021-08-10T16:00:00.000Z","updated":"2021-12-25T05:06:44.279Z","comments":true,"path":"posts/c8b9e539/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c8b9e539/","excerpt":"","text":"与 &amp; 1 &amp; 1 = 1 0 &amp; 1 = 0 1 &amp; 0 = 0 0 &amp; 0 = 0 判断一个数是否为偶数/奇数 若一个数 nnn 为偶数，则二进制表示下末位为0，所以 n &amp; 1 = 0 。 lowbit 根据计算机负数表示的特点，如一个数字原码是 10001000，他的负数表示形势是补码，就是反码+1，反码是01110111，加一则是01111000，二者按位与得到了1000，就是我们想要的 lowbit 操作 int lowbit(n)&#123; return n &amp; (n - 1);&#125; 二进制枚举","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://xiaoke-jin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"LaTeX","slug":"编程语言/LaTeX","date":"2021-08-09T16:00:00.000Z","updated":"2022-03-31T05:17:49.457Z","comments":true,"path":"posts/ce34127b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/ce34127b/","excerpt":"","text":"LaTeX入门 LaTeX入门 KaTeX KaTeX源码 其他网站 在线LaTeX编辑器","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"Markdown","slug":"编程语言/Markdown","date":"2021-08-09T16:00:00.000Z","updated":"2022-03-31T05:17:52.530Z","comments":true,"path":"posts/6fc8eab5/","link":"","permalink":"http://xiaoke-jin.github.io/posts/6fc8eab5/","excerpt":"","text":"Markdown编辑器 Markdown语法 如何在Markdown中输入数学公式 Markdown KaTeX多个公式对齐 格式手册 行间公式 如果这些多行对齐的公式需要 编号，请用 align 或 equation 环境； 请使用 \\begin&#123;aligned&#125; ... \\end&#123;aligned&#125; 表示多行对齐的公式； 每行式子分别编号：使用 align d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{align} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{align} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​​ 一坨式子一个编号：使用 aligned d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{aligned} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{aligned} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​ 不编号：align* a=b+c=e+f\\begin{align*} a&amp;=b+c\\\\ &amp;=e+f \\end{align*} a​=b+c=e+f​ 公式左对齐 \\begin{align*}\\label{2} & X(0) = x(0)W_{N}^{0\\cdot0} + x(1)W_{N}^{0\\cdot1} + \\cdots + x(N-1)W_{N}^{0\\cdot(N-1)}\\\\ & X(1) = x(0)W_{N}^{1\\cdot0} + x(1)W_{N}^{1\\cdot1} + \\cdots + x(N-1)W_{N}^{1\\cdot(N-1)} \\\\ & \\cdots \\\\ & X(N-1) = x(0)W_{N}^{(N-1)\\cdot0} + x(1)W_{N}^{(N-1)\\cdot1} + \\cdots + x(N-1)W_{N}^{(N-1)\\cdot(N-1)} \\\\ \\end{align*} 数学公式 数学公式中的中文文字 必须置于 \\text&#123;&#125; 命令之中，而变量、数字、运算符、函数名称则必须置于 \\text&#123;&#125; 命令之外。请不要在 \\text&#123;&#125; 命令中嵌套数学公式； 使用 array 环境时请注意 实际列数与对齐符号的数量保持一致。例如下面的公式中，数据实际有 3 列（&amp; 是列分隔符），因此需要 3 个对齐符号（l/r/c 分别表示左、右、居中对齐）。 F1={01,11}F2={01,12,11}\\begin{array}{lll} F_1=\\{\\frac{0}{1},&amp;&amp;\\frac{1}{1}\\}\\\\ F_2=\\{\\frac{0}{1},&amp;\\frac{1}{2},&amp;\\frac{1}{1}\\}\\\\ \\end{array} F1​={10​,F2​={10​,​21​,​11​}11​}​ 使用巨型运算符：加上 \\displaystyle $\\displaystyle \\sum_&#123;j=m&#125;^&#123;n&#125;ca_j=c\\sum_&#123;j=m&#125;^&#123;n&#125;a_j$ LaTeX公式的要求 使用 Roman 体表示常量和函数。使用 Italic 体表示变量。 如果遇到没有预先定义好的需要使用 Roman 体的 函数名，我们可以使用 $\\operatorname&#123;something&#125;$ 来产生，如我们可以使用 $\\operatorname&#123;lcm&#125;$ 产生正体的最小公倍数（函数）符号。 同理，产生 Roman 体的 常量 应用 $\\mathrm&#123;&#125;$；产生 Roman 体粗体符号应用 $\\mathbf&#123;&#125;$； 产生 Italic 体粗体符号应用 $\\boldsymbol&#123;&#125;$（如向量 ）。 对于多字母的变量，应当使用 $\\textit&#123;&#125;$。 其他非数学内容，包括英文、特殊符号等，一律使用 $\\text&#123;&#125;$。中文我们则建议不放在 LaTeX 公式中。 在行内使用分数的时候，请使用 $\\dfrac&#123;&#125;&#123;&#125;$。比如 $\\dfrac&#123;1&#125;&#123;2&#125;$，效果 12\\dfrac{1}{2}21​ ，而不是 $\\frac&#123;1&#125;&#123;2&#125;$，效果 12\\frac{1}{2}21​。 组合数请使用 \\dbinom&#123;n&#125;&#123;m&#125;，效果 (nm)\\dbinom{n}{m}(mn​)，而不是 &#123;n \\choose m&#125;（在 LaTeX 中这种写法已不推荐）；与上一条关于分数的约定相似，请不要使用 \\binom&#123;n&#125;&#123;m&#125;，效果 (nm)\\binom{n}{m}(mn​)。 在不会引起歧义的情况下，请用 $\\times$ 代替星号。叉乘请使用 $\\times$，点乘请使用 $\\cdot$。如 a×ba\\times ba×b，a⋅ba\\cdot ba⋅b ，而不是 a∗ba*ba∗b。 请注意，不要在非代码区域使用任何程序设计语言的表示方式，而是使用 LaTeX 公式。例如，使用 $=$ 而不是 $==$（如 a=ba=ba=b ，而不是 a==ba==ba==b ）、使用 a&lt;&lt;1 或者 $a\\times 2$ 而不是 $a&lt;&lt;1$、使用 $a\\bmod b$ 代替 $a\\%b$（如 a mod ba\\bmod bamodb，而不是 a%ba\\%ba%b ）等。 公式中不要使用中括号连缀（即 C++ 高维数组的表示方式）而多使用下标。 为了统一且书写方便，复杂度分析时大 OOO 记号请直接使用 $O()$ 而不是 $\\mathcal O()$。","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"RMQ","slug":"DS_Algorithm证明与讲解/杂项算法/RMQ","date":"2021-08-09T16:00:00.000Z","updated":"2021-12-04T02:35:18.874Z","comments":true,"path":"posts/c9c273e6/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c9c273e6/","excerpt":"","text":"RMQ RMQ ( Range Minimum/Maximum Query )，即区间最值查询。 RMQRMQRMQ 算法一般用较长时间做预处理，时间复杂度为 O(nlog⁡n)O(n\\log{n})O(nlogn)，然后可以在 O(1)O(1)O(1) 的时间内处理每次查询。 ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://xiaoke-jin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"二分","slug":"DS_Algorithm证明与讲解/杂项算法/二分","date":"2021-08-09T16:00:00.000Z","updated":"2022-02-02T03:41:57.819Z","comments":true,"path":"posts/9947c71c/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9947c71c/","excerpt":"","text":"二分本质 「二段性」 只要能确定目标一定在mid左边或右边。 注意事项 「边界问题」 小于所有元素，大于所有元素。即不属于查找范围内。 ​ 整数二分 while(l &lt; r) ​ 实数二分 「精度问题」：如果要求保留到n位，则while(r - l &gt; 1e-(n + 2))即可。 ​ ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://xiaoke-jin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"洛谷名字颜色","slug":"else/杂文/洛谷名字颜色","date":"2021-08-09T16:00:00.000Z","updated":"2022-03-31T05:31:35.369Z","comments":true,"path":"posts/d4fc2fcb/","link":"","permalink":"http://xiaoke-jin.github.io/posts/d4fc2fcb/","excerpt":"","text":"名字颜色规则 动态等级是根据用户在一段时间内的刷题、社区活跃、打卡、题解、违规情况，按照一定算法得出的结果，该算法不公开。动态等级比较准确的表现了用户一段时间内在洛谷的综合行为。 动态等级由 -1 到 4， 管理员的用户名颜色为 紫色\\color{purple}{紫色}紫色，不受动态等级影响。 用户名的颜色为分别对应为棕色、灰色、蓝色、绿色、橙色、红色。 -1 棕色\\color{brown}{棕色}棕色 作弊者 0 灰色\\color{Grey}{灰色}灰色 见习用户 即咕值&lt;100&lt;100&lt;100的用户 1 蓝色\\color{blue}{蓝色}蓝色 普通用户 即咕值在[100,119][100,119][100,119]的用户 2 绿色\\color{green}{绿色}绿色 算法爱好者 即咕值在[120,169][120,169][120,169]的用户 3 橙色\\color{orange}{橙色}橙色 刷题健将 即咕值在[170,229][170,229][170,229]的用户 4 红色\\color{RED}{红色}红色 虐题狂魔 即咕值&gt;229&gt;229&gt;229的用户 新用户的初始动态等级为 0，也就是 灰色\\color{Grey}{灰色}灰色 用户名。用户在洛谷中按照洛谷社区规则使用各项功能，会增加动态等级。如果长时间不使用洛谷或者有违规行为，可能会降级。除非用户有严重违规行为或者在长时间不使用洛谷且未进行实名认证的情况下，一旦用户达到蓝名，则不会掉到 灰色\\color{Grey}{灰色}灰色 。你可以在打卡之后在打卡结果中看到自己用户名的颜色。在犇犇或者讨论中询问颜色名字和咕值相关的一些问题将被和谐。 如果用户抄袭题解或非恶意比赛作弊，将降级至棕名及名字旁带有 Cheater\\color{brown}{Cheater}Cheater 标签，每次查到持续 15 日，并且在 90 日内不得在任何比赛获得排名。15 日后，变成 灰色\\color{Grey}{灰色}灰色 并清空所有 ACACAC 记录。（即，变为 Unaccepted 100Unaccepted\\ \\ \\ 100Unaccepted 100 分状态）。（注：棕名\\color{brown}{棕名}棕名用户是仅次于封号的最严厉警告，如果发生任何违反洛谷社区规则的事情，直接立刻封禁一年。） 动态等级影响洛谷内很多权限，例如创建比赛、团队、提交冷却时间、图床、下载数据等。灰名\\color{Grey}{灰名}灰名 会有较多的限制。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"}],"tags":[]},{"title":"感想","slug":"题目/感想","date":"2021-08-08T16:00:00.000Z","updated":"2022-02-14T17:44:49.085Z","comments":true,"path":"posts/3f333b30/","link":"","permalink":"http://xiaoke-jin.github.io/posts/3f333b30/","excerpt":"","text":"2021/08/10 拜服于大佬的精妙思想 2021/08/12 最难的不是数据结构与算法的学习，而是对题目进行深入分析，发掘其本质，将其转换为「易于求解的等价问题」。 2021/10/24 图论、数论、搜索、DP、数据结构、各类简单基础算法、字符串相关，嗯。基本入门了。 网络流、高难度DP，基本是放弃了。 2021/11/21 数论学得差不多了，还要加紧练习。组合数学等其他数学专题还有待探索。 图论，DP，贪心，搜索，数据结构，，，， 2021/12/08 我是傻逼 2021/01/01 这个寒假，能搞多少？ 数论、DP、DS、图论、字符串 2022/01/26 傻逼牛客训练营，出的尼玛什么狗屁题 2022/02/15 凌晨 1:45。我宣布：我是个大傻逼。傻逼","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"刷题注意事项","slug":"题目/注意事项","date":"2021-08-08T16:00:00.000Z","updated":"2022-01-08T08:43:21.354Z","comments":true,"path":"posts/2838fd2e/","link":"","permalink":"http://xiaoke-jin.github.io/posts/2838fd2e/","excerpt":"","text":"需要特判的情况 搜索：起点和终点相同。 区间内第一个整除某素数的数不一定是合数，可能是其本身。 注意高精度、LL的坑 开了 long long记得用 %lld int 十进制：−231=−2147483648-2^{31}=-21 4748 3648−231=−2147483648 到 231−1=21474836472^{31}-1=21 4748 3647231−1=2147483647 。共10位，21亿。 求方案数； 逆序对数量； 浮点数 输出 -0.00 数组下标需要从 1 开始 数组堆； 背包DP； 前缀和与差分； 输入字符 注意空字符； %c会读入换行符、空格； %s输入输出会略过空格、换行符； 输入「带空格」的字符矩阵 char g[N][N];for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 2 * m; j++)&#123;//读入末尾换行符 char ch; scanf(&quot;%c&quot;, &amp;ch); if(ch == &#x27; &#x27; || ch == &#x27;\\n&#x27;) ; // 不进行任何操作 else g[i][j/2] = ch; // j/2 &#125; 输入「不带空格」的字符矩阵 输入为数字但「数字之间没有空格」，将其视为字符串。 char g[100][100];for(int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]); 输入单个字符 char op[2];scanf(&quot;%s&quot;, op); ​ 二分 (l + r) / 2 与 (l + r + 1) / 2； 考虑目标元素小于或大于区间内所有元素； ​ 双指针 防止指针越界 注意指针位置 ​","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}],"tags":[]},{"title":"错误统计","slug":"题目/错误统计","date":"2021-08-08T16:00:00.000Z","updated":"2022-02-13T13:07:54.760Z","comments":true,"path":"posts/628cb7b/","link":"","permalink":"http://xiaoke-jin.github.io/posts/628cb7b/","excerpt":"","text":"每个 1 都代表着一次痛苦的经历。 没用注意到爆 int：3 前缀和，爆！ 方案数，爆！ 没有调用预处理函数：2 运算符写错：1 返回值写错：1 多测变量、数组未重置：1 题目给的数据未必一定有解，要考虑无解情况：1 没有输入数据（cin/scanf）：2 数组下标填错：2 由于智力低下犯的错误：9999999999999999999999999999999999999 爆 int 未调用预处理函数 运算符写错 == 写成 = 返回值写错 多测未重置 未考虑无解情况 输入数据错误 输入的顺序与题目不一致 干脆没写 cin/scanf 数组下标写错 以某个数组的元素作为另一个数组的下标：比如欧拉筛求欧拉函数，写成 phi[i * p[j]] = phi[i] * phi[j] 。phi[j] 应为 phi[p[j]] 。 我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼我是傻逼","categories":[],"tags":[]},{"title":"01背包","slug":"DS_Algorithm证明与讲解/动态规划/背包问题/01背包","date":"2021-08-05T16:00:00.000Z","updated":"2022-02-08T15:57:17.080Z","comments":true,"path":"posts/27eff61/","link":"","permalink":"http://xiaoke-jin.github.io/posts/27eff61/","excerpt":"","text":"基础01背包 AcWing 423. 采药【01背包DP模型+朴素优化】 01背包的各种变形 P1064 [NOIP2006 提高组] 金明的预算方案 背包恰好装满 I 爆炸的符卡洋洋洒洒 简单的烦恼","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"完全背包","slug":"DS_Algorithm证明与讲解/动态规划/背包问题/完全背包","date":"2021-08-05T16:00:00.000Z","updated":"2022-01-23T05:38:59.772Z","comments":true,"path":"posts/e5fcf0c8/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e5fcf0c8/","excerpt":"","text":"AcWing Charles__——完全背包问题","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"多重背包及其优化","slug":"DS_Algorithm证明与讲解/动态规划/背包问题/多重背包","date":"2021-08-05T16:00:00.000Z","updated":"2022-01-22T15:19:28.935Z","comments":true,"path":"posts/e13f38e1/","link":"","permalink":"http://xiaoke-jin.github.io/posts/e13f38e1/","excerpt":"","text":"多重背包 二进制优化 二进制优化，它为什么正确，为什么合理，凭什么可以这样分？？ AcWing Charles__——多重背包问题 II","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"背包题目","slug":"DS_Algorithm证明与讲解/动态规划/背包问题/背包题目","date":"2021-08-04T16:00:00.000Z","updated":"2022-02-18T14:02:11.159Z","comments":true,"path":"posts/c543cce0/","link":"","permalink":"http://xiaoke-jin.github.io/posts/c543cce0/","excerpt":"","text":"算法｜背包问题的倒序枚举与正序枚举 求方案数 物品选择顺序不影响方案数 求方案数 AcWing 278. 数字组合 AcWing 1023. 买书 AcWing 1021. 货币系统 求最小方案数 洛谷 P1679. 神奇的四次方数 求最优方案数 AcWing 11. 背包问题求方案数 物品选择顺序影响方案数 AcWing 3643. 上楼梯 求具体方案 要求字典序最小 AcWing 12. 背包问题求具体方案 求任意一个方案 1. 至多、恰好、至少 问题 至多 AcWing 423. 采药 AcWing 1019. 庆功会 洛谷 P1802 5倍经验日 至少 AcWing 1020. 潜水员 恰好 多维费用背包问题 AcWing 8. 二维费用的背包问题 AcWing 1022. 宠物小精灵之收服 墨染空的优化 链接 洛谷 P1509 找啊找啊找GF 分组背包 AcWing 1013. 机器分配 AcWing 487. 金明的预算方案 背包 + AcWing 734. 能量石","categories":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/categories/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"Github访问优化","slug":"else/Github/Github访问加速","date":"2021-07-31T16:00:00.000Z","updated":"2022-03-31T05:19:11.276Z","comments":true,"path":"posts/9f26326d/","link":"","permalink":"http://xiaoke-jin.github.io/posts/9f26326d/","excerpt":"","text":"Sky03’ Blog: Github访问优化","categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"}],"tags":[]},{"title":"一个开源博客项目","slug":"else/Hexo/一个开源项目","date":"2021-07-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.794Z","comments":true,"path":"posts/7350e1a/","link":"","permalink":"http://xiaoke-jin.github.io/posts/7350e1a/","excerpt":"","text":"Hexo+Github博客搭建完全教程","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"静态博客访问优化","slug":"else/Hexo/静态博客访问优化","date":"2021-07-31T16:00:00.000Z","updated":"2021-11-25T10:39:14.795Z","comments":true,"path":"posts/884bb30d/","link":"","permalink":"http://xiaoke-jin.github.io/posts/884bb30d/","excerpt":"","text":"Sky03’ Blog: 静态博客访问优化","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"Strange Function","slug":"题解/数论/整除/欧几里得算法/Strange Function","date":"2021-07-02T16:00:00.000Z","updated":"2021-12-04T02:29:04.084Z","comments":true,"path":"posts/2272607/","link":"","permalink":"http://xiaoke-jin.github.io/posts/2272607/","excerpt":"","text":"题目 Codeforces Round #729 (Div. 2) Strange Function 。 思路 若 f(i)=xf(i) = xf(i)=x ，则说明 i&gt;=lcm⁡(1,2,⋯ ,x−1)i&gt;=\\operatorname{lcm}(1,2,\\cdots,x-1)i&gt;=lcm(1,2,⋯,x−1) 。这样的 iii 有 ⌊n/lcm⁡(1,2,⋯ ,x−1)⌋−⌊lcm⁡(1,2,⋯ ,x)⌋\\lfloor n/\\operatorname{lcm}(1,2,\\cdots,x-1)\\rfloor-\\lfloor \\operatorname{lcm}(1,2,\\cdots,x)\\rfloor⌊n/lcm(1,2,⋯,x−1)⌋−⌊lcm(1,2,⋯,x)⌋ 个， 容易发现， lcm⁡(1,2,⋯ ,x)\\operatorname{lcm}(1,2,\\cdots,x)lcm(1,2,⋯,x) 增长速度很快，因为对于 1~x 中的质数， lcm⁡(1,2,⋯ ,x)\\operatorname{lcm}(1,2,\\cdots,x)lcm(1,2,⋯,x) 包含这些质数的乘积，而连续的质数的乘积增长得很快。所以 xxx 的取值范围很小， 2≤x≤422\\le x\\le 422≤x≤42 ，42 内最大质数为 41。 评测记录：https://codeforces.com/problemset/submission/1542/137677652 end 如果要求 1~n 的函数值，而函数值又很不规律，则应考虑根据函数值对 1~n 分组。","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"快速幂","slug":"DS_Algorithm证明与讲解/数学/数论/同余/快速幂","date":"2021-05-01T16:00:00.000Z","updated":"2022-02-11T12:48:22.717Z","comments":true,"path":"posts/20c47d09/","link":"","permalink":"http://xiaoke-jin.github.io/posts/20c47d09/","excerpt":"","text":"a^b % p是什么 设 ab mod pa^b\\bmod pabmodp 的值为 ansansans ，则有 ab≡ans( mod p)a^b\\equiv ans(\\bmod\\ p)ab≡ans(mod p) ，0⩽ans&lt;p0\\leqslant ans&lt;p0⩽ans&lt;p 。 求 ans 下面的看不懂了回来看这两行式子。 若 a≡b( mod p)a\\equiv b(\\bmod\\ p)a≡b(mod p)，则 a2≡b2( mod p)a^2\\equiv b^2(\\bmod\\ p)a2≡b2(mod p) ， a≡(b mod p)( mod p)a\\equiv (b\\bmod\\ p)(\\bmod\\ p)a≡(bmod p)(mod p) 。 若 c≡d( mod p)c\\equiv d(\\bmod\\ p)c≡d(mod p)， a×c≡b×d( mod p)a\\times c\\equiv b\\times d(\\bmod\\ p)a×c≡b×d(mod p) 。 bbb 可表示为 b=(bn−1⋯b1b0)2=bn−1×2n−1+⋯+b1×21+b0×20b=(b_{n-1}\\cdots b_1b_0)_2=b_{n-1}\\times2^{n-1}+\\cdots +b_{1}\\times2^{1}+b_{0}\\times2^{0}b=(bn−1​⋯b1​b0​)2​=bn−1​×2n−1+⋯+b1​×21+b0​×20 ， 因此 ab mod p=abn−1×2n−1+⋯+b1×21+b0×20 mod p=abn−1×2n−1⋯ab1×21ab0×20 mod p\\begin{align*} a^b\\bmod p&amp;=a^{b_{n-1}\\times2^{n-1}+\\cdots +b_{1}\\times2^{1}+b_{0}\\times2^{0}}\\bmod p\\\\ &amp;=a^{b_{n-1}\\times2^{n-1}}\\cdots a^{b_{1}\\times2^{1}}a^{b_0\\times 2^0}\\bmod p \\end{align*} abmodp​=abn−1​×2n−1+⋯+b1​×21+b0​×20modp=abn−1​×2n−1⋯ab1​×21ab0​×20modp​ 设 a0=aa_0=aa0​=a ，对于 a2n−1,⋯ ,a21,a20a^{2^{n-1}},\\cdots,a^{2^{1}},a^{2^{0}}a2n−1,⋯,a21,a20 有 a20≡a0 ( mod p)a21≡a1=(a0×a0)%p ( mod p)a22≡a2=(a1×a1)%p ( mod p)⋮a2n−1≡an−1=(an−2×an−2%p ( mod p))\\begin{align*} a^{2^0}&amp;\\equiv a_0\\ (\\bmod\\ p)\\\\ a^{2^1}&amp;\\equiv a_1=(a_0\\times a_0)\\%p\\ (\\bmod\\ p)\\\\ a^{2^2}&amp;\\equiv a_2=(a_1\\times a_1)\\%p\\ (\\bmod\\ p)\\\\ &amp;\\vdots\\\\ a^{2^{n-1}}&amp;\\equiv a_{n-1}=(a_{n-2}\\times a_{n-2}\\%p\\ (\\bmod\\ p)) \\end{align*} a20a21a22a2n−1​≡a0​ (mod p)≡a1​=(a0​×a0​)%p (mod p)≡a2​=(a1​×a1​)%p (mod p)⋮≡an−1​=(an−2​×an−2​%p (mod p))​ 显然，aia_iai​ 始终小于等于 ppp 。当 bi=0b_i=0bi​=0 ， 0⩽i⩽n−10\\leqslant i\\leqslant n-10⩽i⩽n−1 时，a2i∗bi≡1 ( mod p)a^{2^i*b_i}\\equiv 1\\ (\\bmod\\ p)a2i∗bi​≡1 (mod p) ，所以 ans 只需要和 bi≠0b_i\\ne 0bi​=0 的项相乘。 设 ans=1ans=1ans=1 ，（当 bi=0b_i=0bi​=0 ， 0⩽i⩽n−10\\leqslant i\\leqslant n-10⩽i⩽n−1 时，不用相乘）（下面的 = 为赋值操作） 1≡ans ( mod p)1×a20≡ans=ans×a0%p ( mod p)1×a21×a20≡ans=ans×a1%p ( mod p)⋮1×a2n−2×⋯×a21×a20≡ans=ans×an−2%p ( mod p)1×a2n−1×⋯×a21×a20≡ans=ans×an−1%p ( mod p)\\begin{align*} 1&amp;\\equiv ans\\ (\\bmod\\ p)\\\\ 1\\times a^{2^0}&amp;\\equiv ans=ans\\times a_0\\%p\\ (\\bmod\\ p)\\\\ 1\\times a^{2^1}\\times a^{2^0}&amp;\\equiv ans=ans\\times a_1\\%p\\ (\\bmod\\ p)\\\\ &amp;\\vdots\\\\ 1\\times a^{2^{n-2}}\\times\\cdots\\times a^{2^1}\\times a^{2^0}&amp;\\equiv ans=ans\\times a_{n-2}\\%p\\ (\\bmod\\ p)\\\\ 1\\times a^{2^{n-1}}\\times\\cdots\\times a^{2^1}\\times a^{2^0}&amp;\\equiv ans=ans\\times a_{n-1}\\%p\\ (\\bmod\\ p)\\\\ \\end{align*} 11×a201×a21×a201×a2n−2×⋯×a21×a201×a2n−1×⋯×a21×a20​≡ans (mod p)≡ans=ans×a0​%p (mod p)≡ans=ans×a1​%p (mod p)⋮≡ans=ans×an−2​%p (mod p)≡ans=ans×an−1​%p (mod p)​ 显然， ansansans 始终小于等于 ppp 。 代码实现 int quick_power(int a, int b, int p)&#123; int ans = 1; a = a % p; // 若 a 大于int范围，需要加这一步 while(b) &#123; if(b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125; O(1) 做法 【小技巧】O(1)快速乘 O(1)O(1)O(1) 计算 a×b mod pa\\times b \\bmod pa×bmodp 光速幂 O(1)O(1)O(1) 计算 ab mod pa^b \\bmod pabmodp ，要求 a, p 固定","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"区间DP","slug":"DS_Algorithm证明与讲解/动态规划/区间DP","date":"2021-01-18T16:00:00.000Z","updated":"2022-01-23T05:39:09.221Z","comments":true,"path":"posts/628fb573/","link":"","permalink":"http://xiaoke-jin.github.io/posts/628fb573/","excerpt":"","text":"tips 尝试以下转移： fi,j=max⁡{fi+1,j,fi,j−1}f_{i,j}=\\max\\{f_{i+1,j},f_{i,j-1} \\}fi,j​=max{fi+1,j​,fi,j−1​} ：由去掉左侧或右侧的子区间转移而来 fi,j=fi+1,j−1f_{i,j}=f_{i+1,j-1}fi,j​=fi+1,j−1​ ：由去掉两侧的子区间转移而来 fi,j=max⁡{fi,k,fk,j}f_{i,j}=\\max\\{f_{i,k},f_{k,j} \\}fi,j​=max{fi,k​,fk,j​} ：由左端点到分界线、分界线到右端点两个子区间转移来 fi,j=max⁡{fi,k,fk+1,j}f_{i,j}=\\max\\{f_{i,k},f_{k+1,j} \\}fi,j​=max{fi,k​,fk+1,j​} ：由左端点到分界线、（分界线 + 1）到右端点两个子区间转移来 记忆化搜索 考虑最后合并的两堆石子，存在一个分界线 x ，其中一堆是第 1 堆石子到第 x 堆石子合并得到的结果，另一堆是第 x+1 堆石子到第 n 堆石子合并的结果； 当 x 确定时，总代价 = 合并第 1 堆石子到第 x 堆石子的代价 + 合并第 x+1 堆石子到第 n 堆石子的代价 + 总石子数。 枚举 x 的位置 区间有 O(n2)O(n^2)O(n2) 个，分界线有 O(n)O(n)O(n) 个，所以时间复杂度为 O(n3)O(n^3)O(n3) 。 动态规划 状态表示： 状态转移： 如何保证在算一个问题的解之前，事先计算了这个问题的所有子问题的解？ 题目 [NOI1995] 石子合并 （基础题 [USACO16OPEN]248 G P4170 [CQOI2007]涂色 P2890 [USACO07OPEN]Cheapest Palindrome G P1220 关路灯","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"动态规划入门","slug":"DS_Algorithm证明与讲解/动态规划/入门","date":"2021-01-18T16:00:00.000Z","updated":"2022-01-29T14:55:42.559Z","comments":true,"path":"posts/5ee12162/","link":"","permalink":"http://xiaoke-jin.github.io/posts/5ee12162/","excerpt":"","text":"1我觉得学DP前应该先学下乘法原理。 两个要求 最优子结构 无后效性 两个元素 状态 转移","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"}]},{"title":"卢卡斯定理及其扩展","slug":"DS_Algorithm证明与讲解/数学/数论/同余/卢卡斯定理","date":"2021-01-04T16:00:00.000Z","updated":"2022-01-08T14:09:57.961Z","comments":true,"path":"posts/8fbe0138/","link":"","permalink":"http://xiaoke-jin.github.io/posts/8fbe0138/","excerpt":"","text":"Lucas定理 ExLucas 前置芝士：中国剩余定理","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]}],"categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"计算机科学导论","slug":"计算机科学导论","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"},{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/categories/%E6%AF%94%E8%B5%9B/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构与算法/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"},{"name":"多项式","slug":"数据结构与算法/多项式","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"组合数学","slug":"数据结构与算法/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"计算几何","slug":"数据结构与算法/计算几何","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"杂谈","slug":"数据结构与算法/杂谈","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%82%E8%B0%88/"},{"name":"线性代数","slug":"数据结构与算法/线性代数","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数论","slug":"题解/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/"},{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"DP","slug":"题解/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/DP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"组合数学","slug":"读书笔记/组合数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"name":"优秀博客","slug":"优秀博客","permalink":"http://xiaoke-jin.github.io/categories/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2/"},{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"CP editor","slug":"工具/CP-editor","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/CP-editor/"},{"name":"浏览器","slug":"工具/浏览器","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"sublime","slug":"工具/sublime","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/sublime/"},{"name":"VSCode","slug":"工具/VSCode","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/VSCode/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/categories/DP/"},{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[{"name":"计组","slug":"计组","permalink":"http://xiaoke-jin.github.io/tags/%E8%AE%A1%E7%BB%84/"},{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"},{"name":"比赛","slug":"比赛","permalink":"http://xiaoke-jin.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"DP","permalink":"http://xiaoke-jin.github.io/tags/DP/"},{"name":"多项式","slug":"多项式","permalink":"http://xiaoke-jin.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"组合数学","slug":"组合数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"计算几何","slug":"计算几何","permalink":"http://xiaoke-jin.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"线代","slug":"线代","permalink":"http://xiaoke-jin.github.io/tags/%E7%BA%BF%E4%BB%A3/"},{"name":"杂谈","slug":"杂谈","permalink":"http://xiaoke-jin.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"},{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"基础算法","slug":"基础算法","permalink":"http://xiaoke-jin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://xiaoke-jin.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]}