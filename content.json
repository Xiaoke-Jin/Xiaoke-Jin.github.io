{"meta":{"title":"Cloud","subtitle":"Just for fun!","description":"Welcome To The World Of Algorithm","author":"A Cloud","url":"http://Xiaoke-Jin.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-07-30T09:43:50.000Z","updated":"2021-08-01T04:28:40.966Z","comments":true,"path":"about/index.html","permalink":"http://xiaoke-jin.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-01T07:35:22.898Z","updated":"2021-08-01T07:35:22.898Z","comments":true,"path":"manifest.json","permalink":"http://xiaoke-jin.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"文章分类","date":"2021-07-29T14:53:49.000Z","updated":"2021-08-01T04:28:40.971Z","comments":true,"path":"categories/index.html","permalink":"http://xiaoke-jin.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T04:53:46.000Z","updated":"2021-08-01T04:28:40.981Z","comments":true,"path":"tags/index.html","permalink":"http://xiaoke-jin.github.io/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T09:05:40.000Z","updated":"2021-08-01T04:28:40.976Z","comments":true,"path":"link/index.html","permalink":"http://xiaoke-jin.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"Github访问优化","slug":"Github/Github访问加速","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-10T08:35:56.086Z","comments":true,"path":"20201/08/01/Github/Github访问加速/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Github/Github%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/","excerpt":"","text":"Sky03’ Blog: Github访问优化","categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/tags/Github/"}]},{"title":"一个开源博客项目","slug":"Hexo/一个开源项目","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-08T14:33:30.122Z","comments":true,"path":"20201/08/01/Hexo/一个开源项目/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Hexo/%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"Hexo+Github博客搭建完全教程","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"静态博客访问优化","slug":"Hexo/静态博客访问优化","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-10T08:36:58.317Z","comments":true,"path":"20201/08/01/Hexo/静态博客访问优化/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Hexo/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96/","excerpt":"","text":"Sky03’ Blog: 静态博客访问优化","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"Butterfly主题及其美化","slug":"Hexo/Butterfly主题及其美化","date":"+020201-07-29T16:00:00.000Z","updated":"2021-08-10T08:37:25.035Z","comments":true,"path":"20201/07/30/Hexo/Butterfly主题及其美化/","link":"","permalink":"http://xiaoke-jin.github.io/20201/07/30/Hexo/Butterfly%E4%B8%BB%E9%A2%98%E5%8F%8A%E5%85%B6%E7%BE%8E%E5%8C%96/","excerpt":"","text":"官方文档 Butterfly官方文档 卷二兔 图片自适应 webp 及全站 CDN 加速 更换博客背景图片及图片压缩","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第七章 乘性函数","date":"2021-09-27T09:38:22.996Z","updated":"2021-09-27T09:38:42.999Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第七章 乘性函数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E4%B9%98%E6%80%A7%E5%87%BD%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第九章 原根","date":"2021-09-27T09:38:22.996Z","updated":"2021-09-27T09:38:56.858Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第九章 原根/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%8E%9F%E6%A0%B9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第六章 特殊的同余式","date":"2021-09-27T09:38:22.996Z","updated":"2021-09-27T09:38:31.934Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第六章 特殊的同余式/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%89%B9%E6%AE%8A%E7%9A%84%E5%90%8C%E4%BD%99%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第十章 原根与整数的阶的应用","date":"2021-09-27T09:38:22.996Z","updated":"2021-09-27T09:39:11.837Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第十章 原根与整数的阶的应用/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9A%84%E9%98%B6%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第五章 同余的应用","date":"2021-09-27T09:38:22.996Z","updated":"2021-09-27T10:14:25.951Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第五章 同余的应用/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%90%8C%E4%BD%99%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"证明：如考虑形如 a−bka-bka−bk 的所有整数集合 SSS ，其中 kkk 为整数，即 S={a−bk∣k∈Z}S=\\{a-bk\\mid k\\in \\Z\\}S={a−bk∣k∈Z} 。设 TTT 是 SSS 中的所有非负整数构成的集合。TTT 是非空的，因为当 kkk 是满足 k&lt;a/bk&lt;a/bk&lt;a/b 的整数时，a−bka-bka−bk 是正的。 \\qquad由良序性质，TTT 中有最小元 r=a−bqr=a-bqr=a−bq 。根据 rrr 的构造可知 r≥0r\\ge 0r≥0 ，且容易证明 r&lt;br&lt;br&lt;b 。如果 r≥br\\ge br≥b ，则 r&gt;r−b=a−bq−b=a−b(q+1)r&gt;r-b=a-bq-b=a-b(q+1)r&gt;r−b=a−bq−b=a−b(q+1) ，这与我们选择 r=a−bqr=a-bqr=a−bq 为形如 a−bka-bka−bk 的整数中的最小元矛盾。因此 0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。 \\qquad为了证明 ggg 和 rrr 的值是唯一的，我们假定有两个方程 a=bq1+r1a=bq_1+r_1a=bq1​+r1​ 和 a=bq2+r2a=bq_2+r_2a=bq2​+r2​ ，满足 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b 和 0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b。把第二个方程从第一个方程中减去，可得 0=b(q1−q2)+(r1−r2)\\qquad\\qquad\\qquad\\qquad\\qquad0=b(q_1-q_2)+(r_1-r_2)0=b(q1​−q2​)+(r1​−r2​) 因此，\\qquad\\qquad\\qquad\\qquadr2−r1=b(q1−q2)r_2-r_1=b(q_1-q_2)r2​−r1​=b(q1​−q2​) 由此可知 bbb 整除 r2−r1r_2-r_1r2​−r1​ 。因为 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b，0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b ，故 −b&lt;r2−r1&lt;b-b&lt;r_2-r_1&lt;b−b&lt;r2​−r1​&lt;b 。因此 bbb 可以整除 r2−r1r_2-r_1r2​−r1​ 只有当 r2−r1=0r_2-r_1=0r2​−r1​=0 。我们还得到 q1=q2q_1=q_2q1​=q2​ 。这说明商 qqq 与余数 rrr 唯一的。","categories":[],"tags":[]},{"title":"同余","slug":"读书笔记/数学/初等数论及其应用/第四章 同余","date":"2021-09-25T16:00:00.000Z","updated":"2021-09-27T02:45:11.631Z","comments":true,"path":"2021/09/26/读书笔记/数学/初等数论及其应用/第四章 同余/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%90%8C%E4%BD%99/","excerpt":"","text":"同余概述 定义：设 mmm 是正整数，若 a,ba,ba,b 是正整数，且 m∣(a−b)m|(a-b)m∣(a−b) ，则称 aaa 和 bbb 模 mmm 同余 ，记为 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm)。 定理 4.1 定理 4 .1：若 aaa 和 bbb 是整数，则 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，当且仅当存在整数 kkk ，使得 a=b+kma=b+kma=b+km 。 证明：若 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，则 m∣(a−b)m|(a-b)m∣(a−b) 。这说明存在整数 kkk ，使得 km=a−bkm=a-bkm=a−b ，所以 a=b+kma=b+kma=b+km 。 反过来，若存在整数 kkk 使得 a=b+kma=b+kma=b+km ，则 km=a−bkm=a-bkm=a−b 。于是 m∣(a−b)m|(a-b)m∣(a−b) ，因而 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 。 定理 4.2 同余的性质 定理 4 .2：设 mmm 是正整数。模 mmm 的同余满足下面的性质 （i）自反性：若 aaa 是整数，则 a≡a( mod m)a\\equiv a(\\bmod m)a≡a(modm) 。 （ii）对称性：若 a,ba,ba,b 是整数，且 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，则 b≡a( mod m)b\\equiv a(\\bmod m)b≡a(modm) 。 （iii）传递性：若 a,b,ca,b,ca,b,c 是整数，且 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 和 b≡c( mod m)b\\equiv c(\\bmod m)b≡c(modm) ，则 a≡c( mod m)a\\equiv c(\\bmod m)a≡c(modm) 。 证明： （i） （ii） （iii） 由定理4.2可见，整数的集合被分成 mmm 个不同的集合，这些集合被称为 模 mmm 剩余类（同余类），每个同余类中的任意两个整数都是模 mmm 同余的。注意，当 m=2m=2m=2 时，整数被分成奇、偶两类。 设 mmm 是正整数，给定整数 aaa ，由带余除法有 a=bm+ra=bm+ra=bm+r ，其中 0≤r≤m−10\\le r\\le m-10≤r≤m−1 ，称 rrr 为 aaa 的模 mmm 最小非负剩余。类似的，当 mmm 不整除 aaa 时，称 rrr 为 aaa 的模 mmm 最小正剩余。 定理 4.3 定理 4.4 定理 4.5 定理 4.6 引理 4.1 定理 4.7 定理 4.8 定理 4.9 推论 4.9.1 快速模指数运算（快速幂） 定理 4.10 线性同余方程 中国剩余定理 求解多项式同余方程 线性同余方程组 定理 4.20 利用波拉德方法分解整数","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"题目/图论/最小生成树","date":"2021-09-22T12:23:02.102Z","updated":"2021-09-22T12:23:02.102Z","comments":true,"path":"2021/09/22/题目/图论/最小生成树/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/22/%E9%A2%98%E7%9B%AE/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"题目/图论/最短路","date":"2021-09-22T12:23:02.102Z","updated":"2021-09-22T12:23:11.451Z","comments":true,"path":"2021/09/22/题目/图论/最短路/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/22/%E9%A2%98%E7%9B%AE/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"题单","slug":"题目/题单","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T03:20:37.471Z","comments":true,"path":"2021/09/21/题目/题单/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/%E9%A2%98%E7%9B%AE/%E9%A2%98%E5%8D%95/","excerpt":"","text":"2021-09-21 ​ 题单，日后整理","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"}]},{"title":"KMP","slug":"DS_Algorithm证明与讲解/字符串/KMP","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T02:06:41.144Z","comments":true,"path":"2021/09/21/DS_Algorithm证明与讲解/字符串/KMP/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP/","excerpt":"","text":"链接：KMP算法及其优化（超详解）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"离散化题目","slug":"题目/基础算法/离散化","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T02:36:01.214Z","comments":true,"path":"2021/09/21/题目/基础算法/离散化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/","excerpt":"","text":"保序离散化 AcWing 802. 区间和 洛谷 P6602 「EZEC-2」数轴 无序离散化","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"离散数学 第二版 屈婉玲","slug":"读书笔记/数学/离散数学及其应用/离散 屈婉玲","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T02:09:12.043Z","comments":true,"path":"2021/09/21/读书笔记/数学/离散数学及其应用/离散 屈婉玲/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%A6%BB%E6%95%A3%20%E5%B1%88%E5%A9%89%E7%8E%B2/","excerpt":"","text":"\\qquad取值1或0的变元称作命题变项，可以用命题变项表示真值可以变化的陈述句。用p、q、r等表示命题变项。 \\qquad定义：命题变项及其否定统称为文字。仅由有限个文字构成的析取式称作简单析取式，仅由有限个文字构成的合取式称作简单合取式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/并查集","date":"2021-09-20T01:48:31.200Z","updated":"2021-09-21T13:25:14.034Z","comments":true,"path":"2021/09/20/DS_Algorithm证明与讲解/数据结构/并查集/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/20/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"基本并查集 int p[N];// p[x] == x的父结点void init()&#123; for(int i = 0; i &lt; n; i++) p[i] = i;&#125;int find(int x)&#123; return x == p[x] ? p[x] : p[x] = find(p[x]); // 路径压缩&#125;void merge(int a, int b)&#123; p[find(a)] = p[find(b)];&#125; 扩展并查集 维护 size int sz[N]; // 集合的大小 == size[根结点]，size[子结点]无意义void init()&#123; for(int i = 0; i &lt; n; i++) p[i] = i, size[i] = 1;&#125;void merge(int a, int b)&#123; int x = find(a), y = find(b); if(x == y) return ; p[x] = p[y]; sz[b] += sz[a];&#125; 维护到根节点距离 int p[N], d[N];int find(int x)&#123; if(x != p[x]) &#123; int u = find(p[x]); d[x] += d[u]; p[x] = u; &#125; return p[x];&#125; 扩展域","categories":[],"tags":[]},{"title":"","slug":"题目/搜索/DFS","date":"2021-09-19T09:52:14.926Z","updated":"2021-09-19T09:58:42.447Z","comments":true,"path":"2021/09/19/题目/搜索/DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/DFS/","excerpt":"","text":"剪枝与优化 洛谷 P1120 小木棍 洛谷 P1731 [NOI1999] 生日蛋糕","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-剪枝与优化","date":"2021-09-19T08:44:47.214Z","updated":"2021-09-19T08:55:44.232Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-剪枝与优化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-%E5%89%AA%E6%9E%9D%E4%B8%8E%E4%BC%98%E5%8C%96/","excerpt":"","text":"常用优化方法 优化搜索顺序：大部分情况下，我们应该优先搜索分支较少的结点。 排除等效冗余： 比如按照组合数枚举而不是排列数。 可行性剪枝 最优性剪枝","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-IDAstar","date":"2021-09-19T08:44:30.425Z","updated":"2021-09-19T08:45:49.868Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-IDAstar/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-IDAstar/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-双向DFS","date":"2021-09-19T08:44:30.425Z","updated":"2021-09-19T08:45:33.289Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-双向DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-%E5%8F%8C%E5%90%91DFS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-迭代加深","date":"2021-09-19T08:44:30.425Z","updated":"2021-09-19T08:44:30.425Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-迭代加深/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/基础算法/位运算","date":"2021-09-19T07:00:37.335Z","updated":"2021-09-19T08:19:51.009Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/基础算法/位运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"lowbit 根据计算机负数表示的特点，如一个数字原码是 10001000，他的负数表示形势是补码，就是反码+1，反码是01110111，加一则是01111000，二者按位与得到了1000，就是我们想要的 lowbit 操作 int lowbit(n)&#123; return n &amp; (n - 1);&#125; 二进制枚举","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/Splay","date":"2021-09-18T08:12:28.459Z","updated":"2021-09-18T08:12:28.459Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/数据结构/Splay/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Splay/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/线段树","date":"2021-09-18T08:12:28.459Z","updated":"2021-09-18T08:12:45.853Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/数据结构/线段树/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/树状数组","date":"2021-09-18T08:12:28.459Z","updated":"2021-09-18T08:12:51.078Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/数据结构/树状数组/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/组合数学/斯特林数","date":"2021-09-18T08:12:18.046Z","updated":"2021-09-18T08:12:18.046Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/组合数学/斯特林数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"逻辑基础","slug":"读书笔记/数学/离散数学及其应用/逻辑","date":"2021-09-11T16:00:00.000Z","updated":"2021-09-21T02:07:45.723Z","comments":true,"path":"2021/09/12/读书笔记/数学/离散数学及其应用/逻辑/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E9%80%BB%E8%BE%91/","excerpt":"","text":"必要条件：如果没有A，则必然没有B；如果有A而未必有B，则A就是B的必要条件，记作B→\\to→A，读作“B含于A”。数学上简单来说就是如果由结果B能推导出条件A，我们就说A是B的必要条件。 充分条件：如果A能推出B，那么A就是B的充分条件。其中A为B的子集，即属于A的一定属于B，而属于B的不一定属于A。 链接：“当且仅当”是充要条件吗？ 当且仅当 当且仅当 与 充要条件 这两个概念并没有天然的等价，否则也不会有那么多人提问类似的问题了。 当且仅当（ If and only if ），表示“在，并且仅在这些条件成立的时候”的缩写，缩写为 iff 用 P当且仅当Q 来举例。 当： 当Q成立时，P成立。 所以P的充分条件是Q 仅当： 仅当Q成立时，P才成立。也就是说，当Q不成立时，P也不成立。故其等价的 逆否命题 是，当P成立时，Q才成立。所以P的必要条件是Q 综合“当”和“仅当”，可得P的充要条件是Q。 结论: 当且仅当 等价于 充要条件 。 对 p→qp\\to qp→q 的理解 原文链接：[对 p→qp\\to qp→q 的理解]((3 封私信 / 18 条消息) “p仅当q”和“p蕴含q”有什么区别? - 知乎 (zhihu.com)) 在经典主义逻辑框架下， p→qp\\to qp→q 被称为「实质蕴含」，就是说，这句话 不应该 被解释成自然语言中的”如果 ppp，则 qqq “，而是应该解释成”如果 ppp 为真，那么 qqq 也为真“。因为 ppp 和 qqq 可以完全不相干。实质蕴含最让初学者糊涂的地方是，如果 ppp 为假时， p→qp\\to qp→q 居然必然为真。不要小看这点区别，这会引起很多的「反直觉」结论： 反直觉命题一： p→q∨q→pp\\to q\\lor q\\to pp→q∨q→p 这个在经典主义框架下是永真的，这个可以被误读成：世界上的所有东西都是相互关联的。 反直觉命题二： Pierce’s Law ((p→q)→p)→p((p\\to q)\\to p)\\to p((p→q)→p)→p 这个在经典主义框架下也是永真的，解释下试试看，如果一个蕴含式能蕴含它的前件，那么它的前件 p 就为真。请用「如果……，那么……」解释下试试看？ 反直觉命题三：著名的 Drinker’s Paradox，饮酒者悖论 ∃x∈P.D(x)→∀y∈P.D(x)\\exists x\\in P.D(x)\\to \\forall y\\in P.D(x)∃x∈P.D(x)→∀y∈P.D(x) 「如果一个酒吧里面存在一个饮酒者，”那么“ 酒吧里面所有的人都在饮酒。」这句话是不是很荒唐？我们之所以认为荒唐，正是因为我们把蕴含符号「错误解读」成为了”如果……，那么……“。 在经典主义逻辑框架下，「 p→qp\\to qp→q 等价于 ¬p∨q\\neg p\\lor q¬p∨q 」，可以解读为「要么条件 p 为假，要么结论 q 为真」，实际上也还是在解释「实质蕴含」。 当 ppp 为假时，蕴含关系始终是成立的。这是为了保证反证法（或者说逆否命题与原命题的等价性，即 p→qp\\to qp→q 与 ¬q→¬p\\neg q\\to \\neg p¬q→¬p 等价）成立而特别规定的。这常常被称为「假前件可以得出任意结论」。 逻辑学上，若p则q型的命题，等价于“非p或q”，其否定形式是“p且非q”。这在中学数学里虽然避而不讲，但是却经常被不加证明地使用，都用在哪了呢？用在反证法解题中了 。大家回忆一下，反证法为什么第一步要假设与结论相反的的结果，然后与条件结合起来导出矛盾?这其实就是在证明最初命题的否定“p且非q”是假命题，然后依据排中律，说明要证的命题为真。 这是一个老话题，却似乎常聊常新。原因还在于黑格尔那句老话，人是天生的形而上学家，他们直觉地太看重把事情“说通”，而其实把事情“做通”才是更重要的。说通，是语言逻辑的重任，但数理逻辑关心的却是做通。p-&gt;q，语言中是要用p得到q，数学中则不然，可能p根本不存在，根本不存在由p得到q的问题，但却要求p-&gt;q形式地存在。这时你不能从语言角度去纠结 p→qp\\to qp→q 究竟是什么意思，它没有什么意思，它就是数学上一种形式性的或构造性的要求，有了它推导或运算的过程才能进行，事情才能做通。实际上罗素在使用 实质蕴涵 一词来指这个数理逻辑中的所谓蕴涵时就已经制止了把它与自然语言中的蕴涵一词视作同义的想当然，罗素清楚指出这个所谓的蕴涵，其含义不是来自自然语言，而是由其规定的运算或赋值规则本身来定义，这些规则规定才是这个所谓蕴涵的实质，因此它叫做实质蕴涵。 这么定义只是为了 保证前者的「内涵」比后者小 ，集合包含关系的定义就是用蕴含定义的。蕴含关系表示的就是这么一种强弱关系，真真假假的根本不重要，他本身就和若则的语义不相同，其他的解释多少都是别扭的。 对于集合A，B，A ⊆ B 当且仅当∀x ∈ A，x ∈ B(或者说命题P(x):「若x属于A，则x属于B」对于任意x为真)。 那么问题来了，我们应该都承认对于任意集合S，∅ ⊆ S。这意味着命题「若x属于∅，则x属于S」对于任意x为真。然而没有任何x是属于空集的，所以前提(x属于∅)就一定是假的，而原命题(等价于∅ ⊆ S)却总是真的。也就是题主问的蕴含关系 本质上题主说的这种蕴含关系就是一种数学上的约定，方便我们处理类似∅ ⊆ S的问题。就像0这个数字一样，最开始是不显然的，我们完全可以不要它就可以数数(用自然数)，我们引入0只是为了方便数学的发展。这个问题也是一样，只能努力试着去接受大家约定俗成的东西，至少经验上证明它是很好用的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"Java基础","slug":"语言/Java/Java基础","date":"2021-09-09T16:00:00.000Z","updated":"2021-09-14T02:28:39.682Z","comments":true,"path":"2021/09/10/语言/Java/Java基础/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/10/%E8%AF%AD%E8%A8%80/Java/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java平台主要由两部分组成：Java虚拟机、Java应用程序接口 Java虚拟机 是 Java的核心和基础，是Java编译器和操作平台之间的虚拟处理机，利用软件方法实现的抽象的计算机，它有自己完善的架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机执行的是Java的字节码程序，这个字节码可能来自本地计算机，也可能来自网络。Java虚拟机通过类装载，字节码验证，最后执行。Java的跨平台性都是由 Java虚拟机来实现的。 Java API 是Java的应用程序编程基础，是Java标准类的集合，程序员在开发程序的时候，可以直接调用这些现成的类，Java程序若想运行，必须提供Java的运行环境 JRE，JRE提供了运行Java程序所必需的类库、Java API、Java虚拟机及其一些必要的组件。 如果进行Java程序开发，我们要有 Java开发程序包 JDK，这个程序包，包含了JRE 、API 和进行Java程序开发的编译和调试工具。最新版的 JDK11将 JRE和 JDK整合在一起，在安装目录下只有 JDK。 不同的 Java应用程序，需要不同的 Java平台，Java平台版本主要有三种：Java SE、EE、ME。 Java SE提供了标准的JDK开发平台，主要开发 Java桌面应用程序，是我们这门课使用的开发平台； Java EE是构建企业级的服务应用，包含了 Java SE平台，并增加了附加类库，以支持目录管理、交易管理和企业级消息处理等功能； Java ME用于嵌入式的消费产品开发。要想进行 Java的开发，需要先安装Java开发程序包 JDK； Java程序的开发流程 编辑源文件：文本编辑器 字节码文件 .class 编译源文件，生成字节码：javac.exe 运行字节代码：java.exe","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/素数","date":"2021-09-03T06:09:33.911Z","updated":"2021-09-03T14:34:12.529Z","comments":true,"path":"2021/09/03/DS_Algorithm证明与讲解/数论/素数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/03/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E7%B4%A0%E6%95%B0/","excerpt":"","text":"素数判断 试除法 任意合数 xxx 都至少有一个小于等于 x\\sqrt{x}x​ 的质因子。 bool is_prime(int x)&#123; for(int i = 2; i &lt;= x / i; i++) if(x % i == 0) return false; return true;&#125; Miller-Rabin ​ 分解质因数 试除法 任意合数 xxx 最多有一个大于 x\\sqrt{x}x​ 的质因子。 void div(int x)&#123; for(int i = 2; i &lt;= x / i; i++)&#123; if(x % i == 0)&#123; int cnt = 0; while(x % i == 0) x /= i, cnt++; printf(&quot;%d %d\\n&quot;, i, cnt); &#125; &#125; if(x != 1) printf(&quot;%d 1&quot;, x);&#125; ​ 素数筛 暴力筛 bool is_prime(int x)&#123; for(int i = 2; i &lt;= x / i; i++)&#123; if(x % i == 0) return false; &#125; return true;&#125;for(int i = 2; i &lt;= n; i++)&#123; if(is_prime(i)) primes[++cnt] = i;&#125; 埃氏筛 for(int i = 2; i &lt;= n; i++)&#123; if(is_prime[i]) continue; primes[++cnt] = i; for(int j = i * i; j &lt;= n; j += i)&#123; is_prime[j] = true; &#125;&#125; 欧拉筛 也称线性筛，O(n)O(n)O(n) 的复杂度筛出 1~n 的所有素数。1e8内共 576_1455个素数。 在1e6时与埃氏筛差不多，在1e7时快一倍。 基本思想：每个合数被其最小质因子筛掉。 线性复杂度证明： 每个合数都会在被遍历到之前筛掉； 设合数 xxx 的最小质因子为 ppp ，当 iii 遍历到 x/px/px/p 时， xxx 被筛掉。 每个合数只会被筛掉一次； 任意合数 xxx 可被唯一地表示为 x=p×ix=p\\times ix=p×i ，ppp 是 xxx 的最小质因子，iii 是循环变量，2≤i≤x/i2\\le i\\le x/i2≤i≤x/i 。 如何确保当前质数是被筛掉数的最小质因子： for j=1 to cnt ififif i mod p[j]=0i\\bmod p[j] = 0imodp[j]=0 （则 p[j]p[j]p[j] 是 p[j]∗ip[j] * ip[j]∗i 的最小质因子） break（若循环继续，p[j]p[j]p[j] 不再是最小质因子。） 代码实现： int primes[N], cnt;bool st[N];for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[++cnt] = i; for(int j = 1; primes[j] &lt;= n / i; j++)&#123; // 为了防止溢出,写成这种形式: primes[j] &lt;= n/i /*不需要添加条件 j &lt;= cnt; primes[j] &lt;= i 1.若 i为合数,则 primes[]中，一定包含了其最小质因数,会在 if处结束。 2.若 i为质数，则 i已经加入primes[]中,会在 if处结束。 */ st[primes[j] * i] = true; if(i % primes[j] == 0) break; &#125;&#125;","categories":[],"tags":[]},{"title":"欧拉筛、欧拉函数","slug":"DS_Algorithm证明与讲解/数论/欧拉函数","date":"2021-09-02T16:00:00.000Z","updated":"2021-09-05T02:12:56.829Z","comments":true,"path":"2021/09/03/DS_Algorithm证明与讲解/数论/欧拉函数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/03/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"欧拉筛 也称线性筛，O(n)O(n)O(n) 的复杂度筛出 1~n 的所有素数。1e8内共 576_1455个素数。 在1e6时与埃氏筛差不多，在1e7时快一倍。 基本思想 每个合数被其最小质因子筛掉。 线性复杂度证明 每个合数都会被筛掉； 设合数 xxx 的最小质因子为 ppp ，当 iii 遍历到 x/px/px/p 时， xxx 被筛掉。 每个合数只会被筛掉一次； 任意合数 xxx 可被唯一地表示为 x=p×ix=p\\times ix=p×i ，ppp 是 xxx 的最小质因子，iii 是循环变量。 如何判断当前质数是被筛掉数的最小质因子 for j=1 to n 当 i mod p[j]=0i\\bmod p[j] = 0imodp[j]=0 ，p[j]p[j]p[j] 是 p[j]∗ip[j] * ip[j]∗i 的最小质因子。 代码实现 int primes[N], cnt;bool st[N];for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[++cnt] = i; for(int j = 1; primes[j] &lt;= n / i; j++)&#123; // 为了防止溢出,写成这种形式: primes[j] &lt;= n/i /*不需要添加条件 j &lt;= cnt; primes[j] &lt;= i 1.若 i为合数,则 primes[]中，一定包含了其最小质因数,会在 if处结束。 2.若 i为质数，则 i已经加入primes[]中,会在 if处结束。 */ st[primes[j] * i] = true; if(i % primes[j] == 0) break; &#125;&#125; 欧拉函数","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"欧拉函数","slug":"题目/数论/欧拉函数","date":"2021-09-02T16:00:00.000Z","updated":"2021-09-03T05:30:56.905Z","comments":true,"path":"2021/09/03/题目/数论/欧拉函数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/03/%E9%A2%98%E7%9B%AE/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"AcWing 201. 可见的点 三维版本：SP7001 VLATTICE - Visible Lattice Points","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"数论","slug":"题目/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"素数相关题目","slug":"题目/数论/素数","date":"2021-09-02T16:00:00.000Z","updated":"2021-09-03T14:21:14.949Z","comments":true,"path":"2021/09/03/题目/数论/素数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/03/%E9%A2%98%E7%9B%AE/%E6%95%B0%E8%AE%BA/%E7%B4%A0%E6%95%B0/","excerpt":"","text":"素数筛 AcWing 868. 筛质数：欧拉筛板题。 洛谷 P1835 素数密度：大于等于 LLL 的第一个能被 ppp 整除的数。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"数论","slug":"题目/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"BFS-A*算法证明与详解","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS A-star","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-07T15:31:21.663Z","comments":true,"path":"2021/09/02/DS_Algorithm证明与讲解/搜索/BFS/BFS A-star/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%20A-star/","excerpt":"","text":"写的好垃圾，，，什么时候觉得满意了就删掉，，， ​ 符号说明 g(state)g(state)g(state) ：从初态 st 到当前状态 state 的当前距离；（不一定最短） g∗(state)g^*(state)g∗(state)：从初态 st 到当前状态的实际最小距离； h(state)h(state)h(state) ：从当前状态 state 到终点的估价距离； h∗(state)h^*(state)h∗(state) ：从当前状态 state 到终点的真实距离； f(state)=g(state)+h(state)f(state)=g(state)+h(state)f(state)=g(state)+h(state) ，从初始状态出发经过状态 state 再到达终点的最小代价预估； open list：存储可到达的状态，close list：存储已到达的状态； 估价距离与真实距离： h(state)≤h∗(state)h(state)\\le h^*(state)h(state)≤h∗(state) ； 一旦估价函数确定，则对任意状态 state 的 h(state)h(state)h(state) 就确定了，随着搜索过程变化的是 g(state)g(state)g(state) ，显然，当 g∗(state)=g(state)g^*(state)=g(state)g∗(state)=g(state) 时，g(state)g(state)g(state) 不会再被更新； A* 应用场景 状态空间非常大，普通BFS无脑暴搜则时间复杂度无法接受。若空间比较小不适用，因为使用了优先队列，加入和取出状态的时间复杂度是 O(log⁡n)O(\\log{n})O(logn) 。 有解（无解时，仍然会把所有空间搜索，会比一般的BFS慢，因为优先队列的操作是 log⁡n\\log nlogn 的） 边权非负，如果是负数，那么终点的估值有可能是负无穷，终点可能会直接出堆。 A* 算法流程 while(q.size()) 小根堆 // 谁的d[u]+f[u]更小 谁先出队列 t ← 优先队列的队头 当终点第一次出队时 break ; // 终点第一次出队，到终点距离最小 从该状态向周围状态扩展： if state 未遍历过 || g(state) 可松弛 （松弛时使用 g() 而不是 f() 入队 A*只能保证终点出队时到终点距离最小，不能保证其他点，因为估价距离是相对于终点而言的。 A* 不对状态判重 结点可能会被重复遍历。 当某状态 state 的 d+fd+fd+f 较短时，从该状态出发未必能找到最短路，但是从 state 出发遍历到的点可能是最短路上的点，在未来会再次被访问。 只要搜到的状态 state 未访问过 或 g(state)g(state)g(state) 可松弛 ，就要加入优先队列。 A* 算法证明 设最短路径 Pst−end=start(v0)→v1→v2→⋯→end(vm)P_{st-end}=start(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=start(v0​)→v1​→v2​→⋯→end(vm​) 。 ​ 对于路径上的任意一点 vkv_kvk​，1≤k≤m1\\le k\\le m1≤k≤m ，当其前驱点出堆后，使用前驱点更新 g(k)g(k)g(k)，才能得到 g(k)=g∗(k)g(k)=g^*(k)g(k)=g∗(k) 且 vkv_kvk​ 一定在堆中（被更新或刚加入）且 g∗(k)+h(k)≤g∗(k)+h∗(k)=g∗(end)g^*(k)+h(k)\\le g^*(k)+h^*(k)=g^*(end)g∗(k)+h(k)≤g∗(k)+h∗(k)=g∗(end) 。 ​ 显然，在未取到 g∗(end)g^*(end)g∗(end) 时，end(vm)end(v_m)end(vm​) 一定不是按照最短路一步步更新得到的，即从 start(v0)start(v_0)start(v0​) 开始的最短路尚未走完，则「堆中一定存在最短路径上的某点」。 f()≤g∗(end)f()\\le g^*(end)f()≤g∗(end) 的点未必在最短路上，最短路上的点一定满足 f()≤g∗(end)f()\\le g^*(end)f()≤g∗(end) 。 每次出堆的状态有两种： 若是非最短路上的点，一定会在搜索到 end(vm)end(v_m)end(vm​) 或搜到 end(vm)end(v_m)end(vm​) 之前，得到某个状态 y （包括终点）的 f(y)&gt;g∗(end)f(y)&gt;g^*(end)f(y)&gt;g∗(end)，此时堆中一定存在最短路径上的点。然后会从另一个 f()f()f() 最小的点出发。 若选取到最短路上的点，则离终点更近一步。最终搜到终点使得 g(end)=g∗(end)g(end)=g^*(end)g(end)=g∗(end) 。搜到终点后，堆中可能还会有 f()f()f() 更小的点存在，但这些点向外扩展时都不再改变到 g(end)g(end)g(end) 。 最终 end(vm)end(v_m)end(vm​) 第一次出堆时，即得到最短路。 若最短路径有多条，同理，结论不变。 反证法证明：终点第一次出队列即最优解 1 假设终点第一次出队时不是最优 说明按当前路径得到的 g(终点) 一定严格大于从起点到终点的最小距离 g*(终点) 则说明当前队列中存在点 u 属于最短路径 g(终点) &gt; g*(终点) = g(u) + h*(u) &gt;= g(u) + h(u) 即队列中存在比 g(终点 ) 小的值 2 但我们维护的是一个小根堆，没有比g(队头终点)小的g(u)+h(u)，产生矛盾 证毕 如果当前状态 x 不是最短路上的节点，那么即使 f(x)f(x)f(x) 当前最小，从 x 向外搜索一定会在搜索到 end(vm)end(v_m)end(vm​) 或搜到 end(vm)end(v_m)end(vm​) 之前，得到某个状态 y 的 f(y)&gt;g∗(end)f(y)&gt;g^*(end)f(y)&gt;g∗(end)。 A* 优势 摘抄自《算法竞赛进阶指南》 普通优先队列BFS算法维护了一个优先队列（二叉堆），不断从堆中取出“当前代价最小”的状态（堆顶）进行扩展。每个状态第一次从堆中取出来时，就得到了从初态到该状态的最小代价。 如果给定一个”目标状态”，需要求出从初态到目标状态的最小代价，那么优先队列BFS的这个“优先策略”显然是 不完善 的。一个状态的当前代价最小，只能说明从初态到该状态的代价很小，而在未来的搜索中，从该状态到目标状态的可能会花费很大的代价。另外一些状态虽然当前代价略大，但是未来到目标状态的代价可能会很小，于是从起始状态到目标状态的总代价反而更优。 从 g+hg+hg+h 最短的状态出发未必能搜到最短距离，但概率一定会更大，这样就减少了对 g+hg+hg+h 较大的点的搜索，使得只搜索一部分点就可以保证搜到最短路，使运行效率大大提升。 像这样由估价函数引导的、能优先选择一些点的搜索方式称为启发式搜索。 A* 常见估价函数 在可上下左右四个方向扩展的平面图，使用曼哈顿距离作为估价函数。 欧拉距离 严谨证明 链接：A*算法证明与详解 算法本身性质一：每次队头的状态是 f(n)=g(n)+h(n)f(n)=g(n)+h(n)f(n)=g(n)+h(n) 最小的状态。而且 open list上任一具有 f(n)&lt;f∗(end)f(n)&lt;f^*(end)f(n)&lt;f∗(end) 的状态 n ，一定会在 end 出队前出队并进行扩展 。（最短路径上的点一定会在终点出队前出队） 算法本身性质二：h(n)≤h∗(n)h(n)\\le h^*(n)h(n)≤h∗(n)，预估代价小于等于实际最小代价。 首先证明：如果有解，那么算法一定可以找到终点。 有限图：边、点有限的图，无限图：边、点无限的图。 定理一：对有限图，如果从初始节点 st 到目标节点 end 有路径存在，则A*算法一定成功结束。 首先证明算法必定结束。由于搜索图为有限图，如果算法能找到解，则会成功结束；如果算法找不到解，那么必然会因为 open list 为空而结束。因此A*算法必然会结束。 然后证明算法一定会成功结束。由于至少存在一条由初始点到目标点的路径，设此路径为 Pst−end=st(v0)→v1→v2→⋯→end(vm)P_{st-end}=st(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=st(v0​)→v1​→v2​→⋯→end(vm​) 。 对于无限图，略。（算法题中都是有限图） 再证明：如果有解，算法找的解一定是最优解 。 我们利用反证法进行证明： 假设A*算法求出的不是最优解，那么我们通过A*算法寻到了一条从 st 到 end 的路径 PA∗P_{A*}PA∗​ ，而这条路径并不是最短路径。 那么存在最短路径 Pst−endP_{st-end}Pst−end​ ，有 ∣Pst−end∣&lt;∣PA∗∣|P_{st-end}|&lt;|P_{A*}|∣Pst−end​∣&lt;∣PA∗​∣。 设最短路径 Pst−end=st(v0)→v1→v2→⋯→end(vm)P_{st-end}=st(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=st(v0​)→v1​→v2​→⋯→end(vm​) 。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS-最小步数模型","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS-最小步数模型","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-05T02:08:43.506Z","comments":true,"path":"2021/09/02/DS_Algorithm证明与讲解/搜索/BFS/BFS-最小步数模型/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"八数码 判断是否有解 链接：八数码问题有解的条件及其推广 将矩阵从上到下从左到右的顺序分布成一个数列，并去掉空格，例如： 2 8 3 (0为空格) 分布成数列后： 1 0 4 2 8 3 1 4 7 6 5 7 6 5 如果此 初始状态的数列(矩阵) 与 目标状态的数列(矩阵) 的 逆序对数 的 奇偶性相同 ，则此问题有解。 必要性证明：若有解，逆序对数奇偶性一定相同；反之一定不同。 充分性证明：若逆序对数奇偶性相同，一定有解；反之一定无解。 状态存储 判重 康托展开 unordered_map","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS双向广搜","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS双向广搜","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-05T02:10:02.357Z","comments":true,"path":"2021/09/02/DS_Algorithm证明与讲解/搜索/BFS/BFS双向广搜/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C/","excerpt":"","text":"应用场景 最小步数模型","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"VSCode输出中文乱码如何解决","slug":"工具/VSCode/VSCode输出中文乱码","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-22T12:22:40.785Z","comments":true,"path":"2021/09/01/工具/VSCode/VSCode输出中文乱码/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E5%B7%A5%E5%85%B7/VSCode/VSCode%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"在code runner的settings中， &quot;code-runner.executorMap&quot;: &#123; // chcp 65001的作用是让终端（CMD、PowerShell）的编码格式变为UTF-8 &quot;cpp&quot;: &quot;chcp 65001 &amp;&amp; cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt.exe &amp;&amp; $dir$fileNameWithoutExt.exe&quot;,&#125;","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"工具/VSCode","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/VSCode/"}],"tags":[]},{"title":"第一章 基础：逻辑和证明","slug":"读书笔记/数学/离散数学及其应用/第一章 基础：逻辑和证明","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-18T10:11:45.821Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第一章 基础：逻辑和证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%BB%E8%BE%91%E5%92%8C%E8%AF%81%E6%98%8E/","excerpt":"","text":"本章将解释一个正确的数论证是如何组成的，并介绍构造这样的论证的工具。 我们将开发一系列不同的证明方法以「证明许多不同类型的结论」。 在介绍了多种不同证明方法后，我们将介绍一些「构造证明的策略」。 我们还将介绍猜想的概念，并通过研究来解释数学发展的过程。 命题逻辑 逻辑规则给出数学语句的准确含义，这些规则可以用来区分数学论证的有效或无效。 逻辑的基本构件——命题。命题是一个陈述语句，它的真值或真或假，但不能既真又假。（真值：真实值） 有些命题的真假目前不知道，但可以确定其真值是唯一的。（例：2050年元旦是晴天） 我们用字母来表示 命题变量（或称为语句变量），即表示命题的变量。如果一个命题是真命题，则它的真值为真，用 TTT 表示；如果它是假命题，则其真值为假，用 FFF 表示。不能用简单的命题来表示的命题称为 原子命题 。 涉及命题的逻辑领域称为 命题演算 或 命题逻辑。它最初是 2300 多年前由古希腊哲学家亚里士多德系统地创建的。 从已有命题产生新命题的方法：许多数学陈述都是由一个或多个命题组成的。由已知命题用 逻辑运算符 组合而来的新命题也被称为 复合命题 。二元逻辑运算符也称为 联结词 。 逻辑运算符 令 p、qp、qp、q 为命题， ppp 的否定记作 ¬p\\neg p¬p ，指“ 不是 ppp 所指的情形 ”。命题 ¬p\\neg p¬p 读作“ 非 ppp ”。 ¬p\\neg p¬p 的真值与 ppp 的真值相反。 p、qp、qp、q 的合取即命题“ ppp 并且 qqq ”，记作 p∧qp\\land qp∧q 。当 p、qp、qp、q 都是真命题时，p∧qp\\land qp∧q 命题为真，否则为假。 p、qp、qp、q 的析取即命题“ ppp 或 qqq ” ，记作 p∨qp\\lor qp∨q 。当 p、qp、qp、q 均为假命题时，p∨qp\\lor qp∨q 命题为假，否则为真。 p、qp、qp、q 的异或记作 p⊕qp\\oplus qp⊕q 。当 p、qp、qp、q 中只有一个为真时命题为真，否则为假。 条件语句 p→qp\\to qp→q 是命题”若 ppp ，则 qqq &quot;。当 ppp 为真而 qqq 为假时，条件语句 p→qp\\to qp→q 为假，否则为真。在条件语句 p→qp\\to qp→q 中，ppp 称为假设（前提），qqq 称为结论。等价于「 ¬p∨q\\neg p\\lor q¬p∨q 」。 双条件语句 p↔qp\\leftrightarrow qp↔q 是命题“ ppp 但且仅当 qqq ”。当 p、qp、qp、q 有同样的真值时，双条件语句为真，否则为假。双条件语句也称为 双向蕴含 。等价于：(p→q)∧(q→p)(p\\to q)\\land (q\\to p)(p→q)∧(q→p) 。 用或表示异或： p⊕q=(¬p∧q)∨(p∧¬q)p\\oplus q=(\\neg p\\land q)\\lor (p\\land\\neg q)p⊕q=(¬p∧q)∨(p∧¬q) 。 语句 p→qp\\to qp→q 称为条件语句，因为 p→qp\\to qp→q 可以判定在条件 ppp 成立时 qqq 为真。条件语句也称为 蕴含。 表达 p→qp\\to qp→q 的术语也很多：ppp 蕴含 qqq ，ppp 是 qqq 的充分条件，ppp 的必要条件是 qqq ，ppp 仅当 qqq ，qqq 除非 ¬p\\neg p¬p 对条件语句的表达方式的理解：「 ppp 仅当 qqq 」说的是当 qqq 不为真时 ppp 不能为真。也就是说，如果 ppp 为真但 qqq 为假，则这个语句为假。当 ppp 为假时，qqq 可以为真也可以为假，因为语句没有谈及 qqq 的真值。「 qqq 除非 ¬p\\neg p¬p 」：如果 ¬p\\neg p¬p 是假的，则 qqq 必是真的。也就是说，当 ppp 为真，而 qqq 为假时，语句“ qqq 除非 ¬p\\neg p¬p ”是假的，否则是真的。 表达 p↔qp\\leftrightarrow qp↔q 的术语：“ ppp 是 qqq 的充要条件”、“如果 ppp 那么 qqq ，反之亦然”、“ ppp 当且仅当 qqq ”、“ ppp 恰好当 qqq ”。当且仅当（if and only if）可以用 iff 代替。 在数学推理中我们考虑的条件语句比语言中使用的要广泛一些。条件语句作为一个数学概念不依赖于假设和结论之间的因果关系。 逆命题： 逆否命题： 反命题： 逆否命题与原命题真值相同。 逻辑运算符的优先级： 运算符 优先级 ¬\\neg¬ 1 ∧\\land∧ 2 ∨\\lor∨ 3 →\\to→ 4 ↔\\leftrightarrow↔ 5 逻辑运算和比特运算：比特是一个具有两个可能值的符号，即 0 和 1 。如果一个变量的值或真或假，则此变量称为 布尔变量 。 模糊逻辑： 命题逻辑的应用 语句翻译 系统规范说明 布尔搜索 逻辑谜题 逻辑电路 命题等价式 \\qquad数学证明中的一个重要步骤就是用真值相同的一个语句替换另一条语句。因此，从给定复合命题生成具有相同真值命题的方法广泛用于数学证明的构造。 定义：一个真值永远是真的复合命题（无论其中出现的命题变量的真值是什么），称为 永真式（ tautology ），也称为重言式。一个真值永远为假的复合命题称为 矛盾式（ contradiction ）。既不是永真式也不是矛盾式的复合命题称为 可能式（ contingency ）。 定义：如果 p↔qp\\leftrightarrow qp↔q 是永真式，则命题 p,qp,qp,q 称为是逻辑等价的。用记号 p≡qp\\equiv qp≡q 表示 p,qp,qp,q 是 逻辑等价 的。 常见等价式： 名称 等价式 双重否定律 p≡¬¬pp\\equiv \\neg\\neg pp≡¬¬p 幂等律 p≡p∨pp\\equiv p\\lor pp≡p∨p，p≡p∧pp\\equiv p\\land pp≡p∧p 交换律 p∨q≡q∨pp\\lor q\\equiv q\\lor pp∨q≡q∨p，p∧q≡q∧pp\\land q\\equiv q\\land pp∧q≡q∧p 结合律 (p∧q)∧r≡p∧(q∧r)(p\\land q)\\land r\\equiv p\\land (q\\land r)(p∧q)∧r≡p∧(q∧r) (p∨q)∨r≡p∨(q∨r)(p\\lor q)\\lor r\\equiv p\\lor (q\\lor r)(p∨q)∨r≡p∨(q∨r) 分配律 p∧(q∨r)≡(p∧q)∨(p∧r)p\\land (q\\lor r)\\equiv (p\\land q)\\lor (p\\land r)p∧(q∨r)≡(p∧q)∨(p∧r)，∧\\land∧ 对 ∨\\lor∨ 的分配律 p∨(q∧r)≡(p∨q)∧(p∨r)p\\lor (q\\land r)\\equiv (p\\lor q)\\land (p\\lor r)p∨(q∧r)≡(p∨q)∧(p∨r)，∨\\lor∨ 对 ∧\\land∧ 的分配律 德 · 摩根律 ¬(p∨q)≡¬p∧¬q\\neg(p\\lor q)\\equiv \\neg p\\land \\neg q¬(p∨q)≡¬p∧¬q，¬(p∧q)≡¬p∨¬q\\neg(p\\land q)\\equiv \\neg p\\lor \\neg q¬(p∧q)≡¬p∨¬q 吸收律 p∨(p∧q)≡pp\\lor (p\\land q)\\equiv pp∨(p∧q)≡p，p∧(p∨q)≡pp\\land(p\\lor q)\\equiv pp∧(p∨q)≡p 排中律 p∨¬q≡1p\\lor \\neg q\\equiv 1p∨¬q≡1 矛盾律 p∧¬p≡0p\\land \\neg p\\equiv 0p∧¬p≡0 归谬论 (p→q)∧(p→¬q)≡¬p(p\\to q)\\land (p\\to \\neg q)\\equiv \\neg p(p→q)∧(p→¬q)≡¬p 蕴涵等值式 p→q≡¬p∨qp\\to q\\equiv \\neg p\\lor qp→q≡¬p∨q 德 · 摩根律可以扩展为 ¬(p1∨p2∨⋯∨pn)≡(¬p1∧¬p2∧⋯∧¬pn)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\neg(p_1\\lor p_2 \\lor \\cdots\\lor p_n)\\equiv (\\neg p_1\\land\\neg p_2\\land\\cdots\\land\\neg p_n)¬(p1​∨p2​∨⋯∨pn​)≡(¬p1​∧¬p2​∧⋯∧¬pn​) ¬(p1∧p2∧⋯∧pn)≡(¬p1∨¬p2∨⋯∨¬pn)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\neg(p_1\\land p_2\\land\\cdots\\land p_n)\\equiv (\\neg p_1\\lor\\neg p_2\\lor\\cdots\\lor\\neg p_n)¬(p1​∧p2​∧⋯∧pn​)≡(¬p1​∨¬p2​∨⋯∨¬pn​) 我们有时用符号 ⋁j=1npj\\displaystyle \\bigvee_{j=1}^{n} p_jj=1⋁n​pj​ 来表示 p1∨p2∨⋯∨pnp_1\\lor p_2 \\lor \\cdots\\lor p_np1​∨p2​∨⋯∨pn​ ，用 ⋀j=1npj\\displaystyle \\bigwedge_{j=1}^{n} p_jj=1⋀n​pj​ 来表示 p1∧p2∧⋯∧pnp_1\\land p_2\\land\\cdots\\land p_np1​∧p2​∧⋯∧pn​ 。采用这种记法扩展的德 · 摩根律就可以简洁地写成 ¬(⋁j=1npj)≡⋀j=1n¬pj\\neg(\\displaystyle \\bigvee_{j=1}^{n} p_j)\\equiv \\bigwedge_{j=1}^{n}\\neg p_j¬(j=1⋁n​pj​)≡j=1⋀n​¬pj​ 和 ¬(⋀j=1npj)≡⋁j=1n¬pj\\neg(\\displaystyle \\bigwedge_{j=1}^{n} p_j)\\equiv \\bigvee_{j=1}^{n}\\neg p_j¬(j=1⋀n​pj​)≡j=1⋁n​¬pj​ 。 \\qquad有 n 个命题变量的复合命题的真值表有 2n2^n2n 行，由于随着 n 的增加，行数增加异常迅速，所以随着变量数的增加，利用真值表来建立等价式就变得不切实际。其他方法就会更快捷一些，比如利用我们已知的逻辑等价式。 可满足性 \\qquad一个复合命题称为是 可满足的，如果这个命题不是永假式。不可满足式是永假式，也就是说：一个命题是不可满足的当且仅当它的否定是永真式。 \\qquad当我们找到一个特定的使得复合命题为真的真值赋值时，就证明了它是可满足的。这样的一个赋值称为这个特定的可满足性问题的一个 解。可是，要证明一个复合命题是不可满足的，我们需要证明每一组变量的真值赋值都使其为假。 可满足性的应用 \\qquad在机器人学、软件测试、人工智能规划、计算机辅助设计、机器视觉、集成电路分析、计算机网络以及遗传学等不同的领域中许多问题都可以用命题的可满足性来建立模型。 n 皇后问题 \\qquadnnn 皇后问题要求在一个 n×nn\\times nn×n 的棋盘上放置 nnn 个皇后，目的是使皇后之间可以共存，即任意两个皇后不能在同一列、同一行或同一对角线上。（八皇后问题于 1848 年由 Max Bezzel 提出，由 Franz Nauck 在 1850 年彻底解决。 数独 可满足性问题求解 \\qquad当许多应用建模涉及成千上万个变量的复合命题的可满足性时，问题就来了。当变量数为 1000 时，要检查 210002^{1000}21000 种（这是一个超过 300 位的十进制数）可能的真值组合中的每一种，一台计算机在几万亿年之内都不可能完成。 \\qquad迄今尚没有其他已知的计算过程能使计算机在合理的时间之内判定变量数这么大的复合命题是否为可满足式。 \\qquad可是，在实际应用中某些特定类型的复合命题的可满足性问题求解方法还是有一些进展，比如数独迷题的求解。已经开发出许多计算机程序可以用来求解有实际应用的可满足性问题。 \\qquad在第 3 章讨论算法主题时，我们将进一步讨论这个问题。特别是，我们将解释命题的可满足性问题在算法复杂度学习中扮演的重要角色。 谓词和量词 \\qquad在 1.1~1.3 节中所学习的命题逻辑不能表达数学语言和自然语言中所有语句的确切意思。本节我们将介绍一种表达能力更强的逻辑，即 谓词逻辑。为了理解谓词逻辑，我们首先需要介绍谓词的概念，之后我们将介绍量词的概念。它可以让我们对这样的语句进行推理：某一性质对于某一类型的所有对象均成立，存在一个对象使得某一特性成立。 \\qquad语句“ x 大于 3”有两个部分。第一部分即变量 x 是语句的主语。第二部分（ 谓词 “大于 3”）表明语句的主语具有的一个性质。我们可以用 P(x)P(x)P(x) 表示语句“ x &gt; 3”，其中 PPP 表示谓词“大于 3”，而 x 是变量。语句 P(x)P(x)P(x) 也可以说成是命题函数 PPP 在 x 的值。一旦给变量 x 赋一个值，语句 P(x)P(x)P(x) 就成为命题且具有真值。 \\qquad有些语句还可以含有不止一个变量。例如，考虑语句“x = y + 3”。我们可以用 Q(x,y)Q(x,y)Q(x,y) 表示这个语句，其中 x , y 为变量，QQQ 为谓词。当 x , y 被赋值时，语句 Q(x,y)Q(x,y)Q(x,y) 就有真值了。 \\qquad一般地，涉及 n 个变量 x1,x2,⋯ ,xnx_1,x_2,\\cdots,x_nx1​,x2​,⋯,xn​ 的语句可以表示成 P(x1,x2,⋯ ,xn)P(x_1,x_2,\\cdots,x_n)P(x1​,x2​,⋯,xn​) 。形式为 P(x1,x2,⋯ ,xn)P(x_1,x_2,\\cdots,x_n)P(x1​,x2​,⋯,xn​) 的语句是 命题函数 PPP 在 n 元组 (x1,x2,⋯ ,xn)(x_1,x_2,\\cdots,x_n)(x1​,x2​,⋯,xn​) 的值，PPP 也称为 n位谓词 或 n元谓词。 \\qquad量化 也可以从命题函数生成一个命题。量化表示在何种程度上谓词对于一定范围的个体成立。在自然语言中，“所有、某些、没有、少量“这些词都可以用在量化上。这里我们集中讨论两类量化：全称量化，它告诉我们一个谓词对所考虑范围内的每一个体都为真；存在量化，它告诉我们一个谓词对所考虑范围内的一个或多个个体为真。处理谓词和量词的逻辑领域称为 谓词演算。 命题 什么时候为真 什么时候为假 ∀x P(x)\\forall x\\ P(x)∀x P(x) 对每个 x，P(x)P(x)P(x) 都为真 存在 x，使 P(x)P(x)P(x) 为假 ∃x P(x)\\exists x\\ P(x)∃x P(x) 存在 x，使 P(x)P(x)P(x) 为真 对每个 x，P(x)P(x)P(x) 都为假 全称量词：许多数学命题断言某一性质对于变量在某一特定域内的所有值都为真，这一特定域称为变量的 论域（domain of discourse）（或 全体域（universe of discourse）），时常简称为 域（domain）。这类语句可以用全称量化表示。对特定论域而言 P(x)P(x)P(x) 的全称量化是这样一个命题：它断言 P(x)P(x)P(x) 对 x 在其论域中的所有值均为真。注意，论域规定了变量 x 所有可能取的值。当论域改变时， P(x)P(x)P(x) 的全称量化的意义也随之改变。在使用全称量词时必须指定论域，否则语句的全称量化就是无定义的。 定义：P(x)P(x)P(x) 的全称量化是语句” P(x)P(x)P(x) 对 x 在其论域的所有值为真“ ，用符号 ∀x P(x)\\forall x\\ P(x)∀x P(x) 来表示，其中 $\\forall $ 称为全称量词。命题 ∀x P(x)\\forall x\\ P(x)∀x P(x) 读作 ”对所有 x ，P(x)P(x)P(x) “。一个使 P(x)P(x)P(x) 为假的个体称为 ∀x P(x)\\forall x\\ P(x)∀x P(x) 的反例。 存在量词： 嵌套量词 推理规则 证明导论 证明的方法和策略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第三章 算法","slug":"读书笔记/数学/离散数学及其应用/第三章 算法","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:45:51.656Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第三章 算法/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法 函数的增长 算法的复杂度","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第二章 基本结构：集合、函数、序列、求和与矩阵","slug":"读书笔记/数学/离散数学及其应用/第二章 基本结构：集合、函数、序列、求和与矩阵","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:43:51.617Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第二章 基本结构：集合、函数、序列、求和与矩阵/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%9A%E9%9B%86%E5%90%88%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%BA%8F%E5%88%97%E3%80%81%E6%B1%82%E5%92%8C%E4%B8%8E%E7%9F%A9%E9%98%B5/","excerpt":"","text":"集合 集合运算 函数 序列与求和 集合的基数 矩阵","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第八章 高级计数技术","slug":"读书笔记/数学/离散数学及其应用/第八章 高级计数技术","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:29:59.764Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第八章 高级计数技术/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E8%AE%A1%E6%95%B0%E6%8A%80%E6%9C%AF/","excerpt":"","text":"递推关系的应用 求解线性递推关系 分治算法和递推关系 生成函数 容斥 容斥原理的应用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第九章 关系","slug":"读书笔记/数学/离散数学及其应用/第九章 关系","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:47:50.667Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第九章 关系/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%85%B3%E7%B3%BB/","excerpt":"","text":"关系及其性质 nnn原关系及其应用 关系的表示 关系的闭包 等价关系 偏序","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第五章 归纳与递归","slug":"读书笔记/数学/离散数学及其应用/第五章 归纳与递归","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:45:14.475Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第五章 归纳与递归/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"数学归纳法 强归纳法与良序性 递归定义与结构归纳法 递归算法 程序正确性","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十一章 树","slug":"读书笔记/数学/离散数学及其应用/第十一章 树","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:14.118Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第十一章 树/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%A0%91/","excerpt":"","text":"树的概述 树的应用 树的遍历 生成树 最小生成树","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第六章 计数","slug":"读书笔记/数学/离散数学及其应用/第六章 计数","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:07.723Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第六章 计数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%AE%A1%E6%95%B0/","excerpt":"","text":"计数的基础 鸽巢原理 排列与组合 二项式系数和恒等式 排列与组合的推广 生成排列和组合","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十二章 布尔代数","slug":"读书笔记/数学/离散数学及其应用/第十二章 布尔代数","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:42.190Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第十二章 布尔代数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0/","excerpt":"","text":"布尔函数 布尔函数的表示 逻辑门电路 电路的极小化","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十章 图","slug":"读书笔记/数学/离散数学及其应用/第十章 图","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:21.328Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第十章 图/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%9B%BE/","excerpt":"","text":"图和图模型 图的术语和几种特殊的图 图的表示和图的同构 连通性 欧拉通路与哈密顿通路 最短通路问题 平面图 图着色","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"Windows/鼠标右键菜单设置","date":"2021-08-31T13:01:39.022Z","updated":"2021-08-31T13:02:32.204Z","comments":true,"path":"2021/08/31/Windows/鼠标右键菜单设置/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/31/Windows/%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"增加和删除win右键的Open Folder as PyCharm Project，Jetbrains系列","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第二章 整数的表示法和运算","date":"2021-08-23T03:26:59.246Z","updated":"2021-09-01T06:29:40.494Z","comments":true,"path":"2021/08/23/读书笔记/数学/初等数论及其应用/第二章 整数的表示法和运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"整数","slug":"读书笔记/数学/初等数论及其应用/第一章 整数","date":"2021-08-22T16:00:00.000Z","updated":"2021-09-27T15:01:11.398Z","comments":true,"path":"2021/08/23/读书笔记/数学/初等数论及其应用/第一章 整数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B4%E6%95%B0/","excerpt":"","text":"大纲 在最一般的意义下，数论研究各种数集合的性质。 在本章中我们讨论某些特别重要的 数的集合 ，包括整数、有理数和代数数集合。 我们将简单介绍 用有理数逼近实数 的概念，也介绍 序列 (特别是整数序列)的概念，包括古希腊人所研究的一些 垛积数序列 。 一个常见问题是如何由一些初始项来判定一个特别的整数序列。我们将简单讨论一下如何解决这种问题。 利用序列概念，我们定义 可数集合 并且证明 有理数集合是可数的 。我们还引进了求和符号 和 求积符号 ，并建立一些有用的求和公式。 数学归纳法 是数论(和许多数学分支)中最重要的证明方法之一。我们讨论数学归纳法的两种形式，说明如何用它们来证明各种结果，并且解释数学归纳法为什么是一种有效的证明手段。 然后我们介绍著名的 斐波那契 (Fibonacci)数序列，讲述引出这种数的原始问题。 我们将建立与斐波那契数有关的一些恒等式和不等式，其中有些证明就使用了数学归纳法。 本章最后一节讲述数论的一个基本概念：整除性 。 我们将建立整数除法的基本性质，包括带余除法，还将解释如何用 最大整数函数 来表示一个整数去除另一个整数的商和余数。（也讲述了最大整数函数许多有用的性质） 1.1 数和序列 本节将介绍一些基础知识，它们在本书中通篇使用。 特别地，我们将涉及数论中所研究的重要的数集合、整数序列的概念、求和与求积符号。 良序性质 良序性质：每个非空的正整数集合都有一个最小元。 良序性质可以作为定义正整数集合的 公理 ，或者由一组公理推导出来。 正整数集合 定理1.1-2\\sqrt{2}2​ 是无理数 定理1.1： 2\\sqrt{2}2​ 是无理数。 证明1：设 2=pq\\sqrt{2}=\\dfrac{p}{q}2​=qp​ 互质，证明 p,qp,qp,q 为偶数。 证明2：使用良序性。 定义：如果存在整数 p,q≠0p,q\\ne 0p,q=0 ，使得 r=p/qr=p/qr=p/q ，则称实数 rrr 是 有理数 。否则 rrr 为 无理数 。 整数集合、正整数集合、有理数集合和实数集合通常分别记为 \\Z,\\Z+,\\Q,\\R 。我们也用 x∈Sx\\in Sx∈S 来表示 xxx 属于集合 SSS 。 「最大整数函数」： xxx 中的最大整数记为 [x][x][x] ，是小于或等于 xxx 的最大整数，即 [x][x][x] 是满足 [x]≤x&lt;[x]+1[x]\\le x&lt;[x]+1[x]≤x&lt;[x]+1 的整数。最大整数函数也被称为取整函数（floor function）。在计算机科学中通常用记号 ⌊x⌋\\lfloor x \\rfloor⌊x⌋ 代替 [x][x][x] 。 「上整数函数」：记为 ⌈x⌉\\lceil x \\rceil⌈x⌉ ，是大于或等于 xxx 的最小整数。 例1.4：证明如果 nnn 是整数，则对于任意实数 xxx ，都有 [x+n]=[x]+n[x+n]=[x]+n[x+n]=[x]+n 。 定义：实数 zzz 的分数部分（fractional part）记为 {x}\\{x\\}{x} ，是 xxx 与 [x][x][x] 的差，即 {x}=x−[x]\\{x\\}=x-[x]{x}=x−[x] 。 丢番图逼近 我们知道一个实数和与之最接近的整数的距离不超过 12\\dfrac{1}{2}21​ 。但我们可否证明一个实数的前 kkk 个倍数中的某一个一定更接近某个整数？ 数论中一个很重要的部分称为丢番图逼近，它正是研究这类问题的。特别地，丢番图逼近着重研究用有理数逼近实数的问题。 我们将要证明在实数 $\\alpha $ 的前 nnn 个倍数中至少有一个实数与最接近它的整数的距离小于 1n\\dfrac{1}{n}n1​ 。 这个证明是基于德国数学家狄利克雷(Dirichlet)提出的鸽笼原理。 定理1.2-鸽笼原理 定理1.2 鸽笼原理：如果把 k+1k+1k+1 个或者更多的物体放入 kkk 个盒子中，那么至少有一个盒子中有两个或更多的物体。 证明： 如果 kkk 个盒子中的任何一个中都没有多于一个的物体，那么所有物体的总数至多为 kkk 。这个矛盾说明有一个盒子中至少有两个或者更多的物体。 定理1.3-狄利克雷逼近原理 现在我们来叙述并证明狄利克雷逼近定理，它能够保证一个实数的前 nnn 个倍数之一必定在某个整数的 1/n1/n1/n 邻域内。 定理1.3（狄利克雷逼近定理）：如果 α\\alphaα 是一个实数，nnn 是一个正整数，则存在整数 a,b,1≤a≤na,b,1\\le a\\le na,b,1≤a≤n，使得 ∣a×a−b∣&lt;1/n|a\\times a-b|&lt;1/n∣a×a−b∣&lt;1/n 。 考虑 n+1n+1n+1 个数 。这 n+1n+1n+1 个数是数 的分数部分，所以 。这 个数中的每一个都位于 个互不相交的区间中的一个。 对于定理1.3我们采取的是狄利克雷1834年的原始证明。把定理1.3中的 替换为 ,可以得到一个更强的结论。它的证明并不困难(见习题32)。进一步，在习题34中我们展示如何用狄利克雷逼近定理来证明对于一个无理数 ，存在无数多个不同的有理数 使得 。这是丢番图逼近定理中的一个重要结果。我们将在第12章再回到这个话题 序列：序列 {an}\\{ a_n\\}{an​} 是一列数 a1,a2,a3,⋯a_1,a_2,a_3,\\cdotsa1​,a2​,a3​,⋯ 。 数论中的一个常见问题是如何寻找构造序列的通项公式或者规则。 我们现在定义什么是可数集，并且证明：当且仅当一个集合的元素可以被列为一个序列时，它是可数的。 定义一个集合可数（countable），如果它是有限的或者是无穷的但与正整数集合之间存在一个一一映射。如果一个集合不是可数的，则称为不可数（uncountable）。 一个无穷集合是可数的当且仅当其中的元素可以被列为一个由正整数标记的序列。为了看到这一点，只需注意从正整数集合到一个集合 sss 的一一映射 fff 其实就是把集合中的元素列成序列 a1,a2,⋯ ,an,⋯a_1,a_2,\\cdots,a_n,\\cdotsa1​,a2​,⋯,an​,⋯ ，其中 ai=f(i)a_i=f(i)ai​=f(i) 。 定理1.4-有理数集合是可数的 定理1.4：有理数集合是可数的。 习题45将会证明实数集合不可数。 1.2 和与积 和的记号： ∑k=1nak=a1+a2+⋯+an\\displaystyle \\sum_{k=1}^{n}a_k=a_1+a_2+\\cdots+a_nk=1∑n​ak​=a1​+a2​+⋯+an​ 。字母 kkk 称为 求和下标（index of summation）。 三个和式 ∑j=mn(c×aj)=c∑j=mnaj\\displaystyle \\sum_{j=m}^{n}(c\\times a_j)=c\\sum_{j=m}^{n}a_jj=m∑n​(c×aj​)=cj=m∑n​aj​ ； ∑j=mn(aj+bj)=∑j=mnaj+∑j=mnbj\\displaystyle \\sum_{j=m}^{n}(a_j+b_j)=\\sum_{j=m}^{n}a_j+\\sum_{j=m}^{n}b_jj=m∑n​(aj​+bj​)=j=m∑n​aj​+j=m∑n​bj​ ； ∑i=mn∑j=pqaibj=(∑i=mnai)(∑j=pqbj)=∑j=pq∑i=mnaibj\\displaystyle \\sum_{i=m}^{n}\\sum_{j=p}^{q}a_ib_j= \\left(\\sum_{i=m}^{n}a_i \\right )\\left(\\sum_{j=p}^{q}b_j \\right)=\\sum_{j=p}^{q}\\sum_{i=m}^{n}a_ib_ji=m∑n​j=p∑q​ai​bj​=(i=m∑n​ai​)(j=p∑q​bj​)=j=p∑q​i=m∑n​ai​bj​ ； 例1.15 求等比数列 的前 n+1n+1n+1 项的和。 推导出 当 。 例1.17 证明：2 的前 nnn 个连续方幂之和比 2 的下一个方幂小 1。即 ∑i=0n2i=2n+1−1\\displaystyle \\sum_{i=0}^{n}2^i=2^{n+1}-1i=0∑n​2i=2n+1−1 。 证明： 形如 ∑i=1n(ai−ai−1)\\displaystyle \\sum_{i=1}^{n}(a_i-a_{i-1)}i=1∑n​(ai​−ai−1)​ 的和被称为是 叠进的 。其中 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 是一数列。 \\qquad\\qquad\\qquad ∑i=1n(ai−ai−1)=(an−an−1)+⋯+(a2−1)+(a1−a0)=an−a0\\displaystyle \\sum_{i=1}^{n}(a_i-a_{i-1})=(a_n-a_{n-1})+\\cdots +(a_2-_1)+(a_1-a_0)=a_n-a_0i=1∑n​(ai​−ai−1​)=(an​−an−1​)+⋯+(a2​−1​)+(a1​−a0​)=an​−a0​ 。 例1.18 三角数 t1,t2,t3,⋯ ,tk,⋯t_1,t_2,t_3,\\cdots,t_k,\\cdotst1​,t2​,t3​,⋯,tk​,⋯ 是一个数列，其中 tkt_ktk​ 为第 jjj 行有 jjj 个点的 kkk 行三角阵列中点的个数。 推导 tnt_ntn​ 的另一种求法见习题7。 与求和类似，我们也给乘积定义一个记号。数 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 的积记为 ∏k=1nak=a1×a2×⋯an\\displaystyle \\prod_{k=1}^{n}a_k=a_1\\times a_2\\times\\cdots a_nk=1∏n​ak​=a1​×a2​×⋯an​ 。 字母 jjj 为虚变量，可以用任意字母代替。 阶乘函数在数论中通篇出现。 定义：设 nnn 为正整数，则 n!n!n!（读作“ nnn 的阶乘”）是整数 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 的积。0!=10!=10!=1。采用乘积符号，我们有 n!=∏j=1njn!=\\displaystyle \\prod_{j=1}^{n}jn!=j=1∏n​j。 1.3 数学归纳法 定理1.5-数学归纳原理 使用数学归纳法证明一个特定命题对所有正整数都成立必须实现「两步」。 第一，设 SSS 为我们认为命题成立的那个正整数集合，必须说明 1 属于 SSS ；即命题对整数 1 为真。这叫做基础步骤。 第二，必须证明对每个正整数 nnn，如果 nnn 属于 SSS 则 n+1n+1n+1 也属于 SSS ；即如果这个命题对 nnn 为真，则对 n+1n+1n+1 也为真。这被称为归纳步骤。 一旦这两步都完成了，我们就可以由数学归纳原理得到结论：命题对所有正整数为真。 定理1.5（数学归纳原理）：一个包含整数 1 的正整数集合如果具有如下性质，即若其包含整数 kkk ，则其也包含整数 k+1k+1k+1 ，那么这个集合一定是所有正整数的集合。 证明 ：设 是包含整数 的正整数集合，并且如果它包含整数 ，则一定包含 。假定(为了推出矛盾) 不是所有正整数的集合。因此有某个正整数不包含在集合 中。由「良序性质」，由于不包含在 中的正整数集合是非空的，所以不包含于 中的所有正整数中存在一个最小的正整数，记为 。注意由于 在中，故 。 现在，由于 （因为不存在正整数 满足 ），故 是小于 的正整数，并且 一定在集合 中。但是因为包含 ，从而一定包含 。这与假定为不包含于 中的最小整数矛盾。这说明 一定是所有正整数的集合。 例：证明 : 对于正整数，有 基础步骤 :，所以这一步成立。 归纳步骤 :我们的归纳假设为公式对于 成立，即假定 .使用归纳假设，我们有 由于基础步骤和归纳步骤都完成了，我们知道结果成立。 例：证明 :，对任意正整数 成立。 基础步骤 归纳步骤 定理1.6-第二数学归纳原理 定理1.6（第二数学归纳原理）：对于包含 的正整数集合，如果它具有下述性质：对每一个正整数 。如果它包含全体正整数 ，则它也包含整数 ，那么这个集合一定是由所有正整数构成的集合。 证明：设是一个包含的整数集合，并且对任意正整数 ，如果它包含，则它也包含 。设 是所有正整数 的集合， 满足：小于等于 的正整数都在 中。则 在 中，并且，根据假设，我们看到如果 在 中，则 在 中。因此，由数学归纳法原理，必为所有正整数的集合，故显然 也是所有正整数的集合，因为 是 的一个子集。 1能使命题成立。 若 均使命题成立，则可推出 也使命题成立。 为了区别于数学归纳原理，第二数学归纳原理有时也称为强归纳，而数学归纳原理也 称为弱归纳。 递归定义 数学归纳原理提供了一种方法来定义函数在正整数处的值。我们不用明确给出函数在 nnn 处的值，而是给出其在 1 处的值，并且给出对于任意正整数 nnn ，从函数在 nnn 处的值来寻找在 n+1n+1n+1 处的值的规则。 定义：我们说函数 fff 是 递归定义 的，如果指定了 fff 在 1 处的值，而且对于任意正整数 nnn ，都提供了一个规则来根据 f(n)f(n)f(n) 确定 f(n+1)f(n+1)f(n+1) 。 数学归纳原理可以用来证明 递归定义的函数在每个正整数上都是唯一定义的（参看本节末尾的习题25）。 第二数学归纳原理也可以作为递归定义的基础。我们可以如下定义一个定义域为正整数集合的函数：首先指定它在 1 处的值，并且对每个正整数 nnn，给定一个根据 f(j),1≤j≤n−1f(j),1\\le j\\le n-1f(j),1≤j≤n−1 的值求 f(n)f(n)f(n) 的规则。这将是在1.4节中讨论的斐波那契数序列的定义的基础。 1.4 斐波那契数 定义：斐波那契序列有如下递归定义：f1=1,f2=1f_1=1,f_2=1f1​=1,f2​=1，且对 n≥3n\\ge 3n≥3，fn=fn−1+fn−2f_n=f_{n-1}+f_{n-2}fn​=fn−1​+fn−2​，这个序列中的项被称为斐波那契数。 斐波那契数满足相当多的恒等式 。 例1.27 如证明： ∑i=1nfk=fn+2−1\\displaystyle \\sum_{i=1}^{n}f_k=f_{n+2}-1i=1∑n​fk​=fn+2​−1 ，fnf_nfn​：第 n 个斐波那契数。 叠进和 数学归纳原理 本节末的习题要求你去证明许多关于斐波那契数的其他恒等式。 斐波那契数列增长有多快 ？下面的不等式说明斐波那契数比公比为 α=(1+5)/2\\alpha=(1+\\sqrt{5})/2α=(1+5​)/2 的等比数列增长的快，这一结论将在第 3 章中应用。 例1.28 用第二数学归纳原理证明对 n≥3n\\ge 3n≥3，有 fn&gt;αn−2f_n&gt;\\alpha^{n-2}fn​&gt;αn−2 。 定理1.7 我们用第 nnn 个斐波那契数的一个显式计算公式来结束本节。我们在正文中不给出证明，但是在本节末的习题41和习题42中概述了如何分别利用线性齐次递归关系和母函数来求这个公式。进一步，习题40要求通过说明这些项满足与斐波那契数相同的递归定义来证明这个恒等式，习题45要求用数学归纳法来证明。 前两个方法的优点是它们可以用来发现公式，而后两个方法却不能。 定理1.7 设 nnn 是正整数， α=1+52\\alpha=\\dfrac{1+\\sqrt{5}}{2}α=21+5​​， β=1−52\\beta=\\dfrac{1-\\sqrt{5}}{2}β=21−5​​ 则第 nnn 个斐波那契数 fnf_nfn​ 由该式给出： fn=15(αn−βn)f_n=\\dfrac{1}{\\sqrt{5}}(\\alpha^n-\\beta^n)fn​=5​1​(αn−βn) 。 1.5 整除性 一个整数可以被另一个整数整除的概念在数论中处于中心地位。 整除定义：如果 a,ba,ba,b 为整数且 a≠0a\\ne 0a=0 ，我们说 aaa 整除 bbb 是指存在整数 ccc 使得 b=a×cb=a\\times cb=a×c 。如果 aaa 整除 bbb，我们还称 aaa 是 bbb 的因子，且称 bbb 是 aaa 的倍数。 定理1.8 定理1.8：如果 a,b,ca,b,ca,b,c 是整数，且 a∣ba\\mid ba∣b，b∣cb\\mid cb∣c ，则 a∣ca\\mid ca∣c 。 证明： 定理1.9 定理1.9：如果 a,b,m,na,b,m,na,b,m,n 是整数，且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b，则 c∣(ma+nb)c\\mid (ma+nb)c∣(ma+nb) 。 证明： 定理1.10 定理1.10（带余除法）：如果 a,ba,ba,b 是整数且 b&gt;0b&gt;0b&gt;0 ，则存在唯一的整数 qqq 和 rrr ，使得 a=bq+ra=b q+ra=bq+r ，0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。（ aaa 为被除数，bbb 为除数，qqq 为商Quotient，rrr 为余数Remainder） 用良序性证明带余除法。先证存在性（ TTT 中最小元 rrr 和 rrr 对应的 qqq 满足该要求），再证唯一性。 证明：如考虑形如 a−bka-bka−bk 的所有整数集合 SSS ，其中 kkk 为整数，即 S={a−bk∣k∈Z}S=\\{a-bk\\mid k\\in \\Z\\}S={a−bk∣k∈Z} 。设 TTT 是 SSS 中的所有非负整数构成的集合。TTT 是非空的，因为当 kkk 是满足 k&lt;a/bk&lt;a/bk&lt;a/b 的整数时，a−bka-bka−bk 是正的。 \\qquad由良序性质，TTT 中有最小元 r=a−bqr=a-bqr=a−bq 。根据 rrr 的构造可知 r≥0r\\ge 0r≥0 ，且容易证明 r&lt;br&lt;br&lt;b 。如果 r≥br\\ge br≥b ，则 r&gt;r−b=a−bq−b=a−b(q+1)r&gt;r-b=a-bq-b=a-b(q+1)r&gt;r−b=a−bq−b=a−b(q+1) ，这与我们选择 r=a−bqr=a-bqr=a−bq 为形如 a−bka-bka−bk 的整数中的最小元矛盾。因此 0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。 \\qquad为了证明 qqq 和 rrr 的值是唯一的，我们假定有两个方程 a=bq1+r1a=bq_1+r_1a=bq1​+r1​ 和 a=bq2+r2a=bq_2+r_2a=bq2​+r2​ ，满足 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b 和 0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b。把第二个方程从第一个方程中减去，可得 0=b(q1−q2)+(r1−r2)\\qquad\\qquad\\qquad\\qquad\\qquad0=b(q_1-q_2)+(r_1-r_2)0=b(q1​−q2​)+(r1​−r2​) 因此，\\qquad\\qquad\\qquad\\qquadr2−r1=b(q1−q2)r_2-r_1=b(q_1-q_2)r2​−r1​=b(q1​−q2​) 由此可知 bbb 整除 r2−r1r_2-r_1r2​−r1​ 。因为 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b，0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b ，故 −b&lt;r2−r1&lt;b-b&lt;r_2-r_1&lt;b−b&lt;r2​−r1​&lt;b 。因此 bbb 可以整除 r2−r1r_2-r_1r2​−r1​ 只有当 r2−r1=0r_2-r_1=0r2​−r1​=0 。我们还得到 q1=q2q_1=q_2q1​=q2​ 。这说明商 qqq 与余数 rrr 唯一的。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 因而 q=[a/b]q=[a/b]q=[a/b]，r=a−b×[a/b]r=a-b\\times [a/b]r=a−b×[a/b] 。 例1.36 证明：如果 是正整数，则当 为实数时 [x/n]=[[x]/n][x/n]=[[x]/n][x/n]=[[x]/n] 。 证明： 给定一个正整数 ddd ，可以根据整数被 ddd 除的余数把它们分类。 定义：如果 nnn 被 2 除的余数为 0 ，则对某个整数 kkk ，有 n=2kn=2kn=2k ，我们称 nnn 为偶数；而如果 nnn 被 2 除的余数为 1，则对某个整数 kkk ，有 n=2k+1n=2k+1n=2k+1 ，我们称 nnn 为奇数。 类似地，当 d=4d=4d=4 时，我们从带余除法中看到当整数被 4 除时，余数为 0，1，2，3。因此每个整数都形如 4k, 4k+1, 4k+2, 4k+34k,\\ 4k+1,\\ 4k+2,\\ 4k+34k, 4k+1, 4k+2, 4k+3 ，其中为正整数。 我们将在第4章继续讨论这个问题。 最大公因子 定义：不全为零的整数 a,ba,ba,b 的最大公因子是指能同时整除 a,ba,ba,b 的最大整数。 a,ba,ba,b 的最大公因子记为 (a,b)(a,b)(a,b) ，有时也记为 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 。 注意当 nnn 为正整数时， (0,n)=(n,0)=n(0,n)=(n,0)=n(0,n)=(n,0)=n 。 利用整数的有序性定义了整数的最大公因子。 定义：设 a,ba,ba,b 均为非零整数，如果 a,ba,ba,b 的最大公因子 (a,b)=1(a,b)=1(a,b)=1 ，则称 a,ba,ba,b 互素 。 约定 (0,0)=0(0,0)=0(0,0)=0 。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"素数和最大公因子","slug":"读书笔记/数学/初等数论及其应用/第三章 素数和最大公因子","date":"2021-08-22T16:00:00.000Z","updated":"2021-09-27T10:30:51.415Z","comments":true,"path":"2021/08/23/读书笔记/数学/初等数论及其应用/第三章 素数和最大公因子/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B4%A0%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/","excerpt":"","text":"大纲 尽管数学家做了几百年的努力，仍有关于素数的许多问题未被解决。 我们将选取讨论其中的一些，包括最著名的两个：孪生素数猜想和哥德巴赫（Goldbach）猜想。 在数论中常常研究具有特殊形式的数。本章中，我们将介绍费马数，即形如 2n+12^n+12n+1 的整数。（费马猜想它们都是素数，但是这被证明是不对的）。 最后，我们将介绍丢番图方程，它是只考虑整数解的方程。 我们将证明如何用最大公因子来帮助求解线性丢番图方程。 与其他丢番图方程不同，线性丢番图方程能够容易地系统解决。 素数 定义：素数是大于 111 的正整数，并且除了 111 和它本身外不能被其他正整数所整除。 定义：大于 111 的不是素数的正整数称为合数。 本节将讨论给定正整数集中素数的分布并证明该分布的一些基础性质。 同时还将讨论关于素数分布的一些更强的结论。 在我们将要介绍的定理中包含了数论中一些最著名的结论。 「素数的无限性」：我们从证明有无穷多个素数开始，为此需要下面的引理。 我们将在本章的后面介绍一些证明素数无穷性的其他方法。（见这一节末尾的习题8以及3.3、3.5和3.6节的习题）。 引理3.1-每个大于 1 的正整数都有一个素因子 引理3.1：每个大于 111 的正整数都有一个素因子。 证明： 定理3.1-素数无限性 定理3.1：存在无穷多个素数。 证明： 证毕。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理3.1的证明过程不是构造性的，因为我们在证明中构造的整数 QnQ_nQn​，（由前 nnn 个素数的积加得到）可以是素数也可以不是（见习题11）。因此，在证明过程中我们只是知道存在一个新的素数但是并没有求得它。 求素数：在下面的章节中，我们将把兴趣放在如何求大素数和使用大素数上。 定理3.2-合数必有一个不超过 sqrt(n) 的素因子 将素数和合数加以区分的测试是至关重要的，这种测试叫做素性检验。 最基本的素性检验是「试除法」。 bool is_prime()&#123; for(int i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false; &#125; return true;&#125; 定理3.2：如果 nnn 是一个合数，那么 nnn 一定有一个不超过 n\\sqrt{n}n​ 的素因子。 证明： 既然 nnn 是合数，那么 nnn 可以写成 n=a∗bn=a*bn=a∗b，其中 a, b 为整数且 1&lt;a≤b&lt;n1&lt;a≤b&lt;n1&lt;a≤b&lt;n 。 我们一定有 a≤na\\le \\sqrt{n}a≤n​ ，否则若 b≥a&gt;nb\\ge a&gt;\\sqrt{n}b≥a&gt;n​，那么有 a∗b&gt;n∗n=na*b&gt;\\sqrt{n}*\\sqrt{n}=na∗b&gt;n​∗n​=n 。(至此，aaa 可能是合数，也可能是质数)。 由引理3.1，aaa 至少有一个素因子，再由定理1.8，aaa 的因子一定也是 nnn 的因子，显然这个因子小于等于 n\\sqrt{n}n​ 。 证毕。 ■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 给定一个正整数 nnn ，使用定理3.2可以找到所有小于等于 nnn 的素数。这种方法就是「埃拉托色尼斯筛法」。 int primes[1000], cnt;bool is_prime[1000];for(int i = 2; i &lt;= n; i++)&#123; if(is_primes[i]) continue; primes[++cnt] = i; if(i &lt;= sqrt(n))&#123; // 使用小于等于sqrt(n)的所有质数即可 for(int j = i + i; j &lt;= n; j += i) is_primes[j] = true; &#125;&#125; 对于一个特定的整数 nnn ，我们将在后面给出一个更好的方法来判断一个整数是否是素数，即定理6.11。 定理3.3 定理3.3（狄利克雷关于「等差数列中素数的定理」）：假设 a,ba,ba,b 是互素的整数，那么等差数列 an+b(n=1,2,3,⋯ )an+b(n=1,2,3,\\cdots)an+b(n=1,2,3,⋯) 包含了无穷多的素数。 目前为止狄利克雷定理没有简单的证法。（狄利克雷的原始证明使用了复变量。后来爱尔迪希 (Erdos) 和塞尔伯格 (Selberg) 在20世纪50年代给出了一个初等但较复杂的证明）。 但是狄利克雷定理的一些特例很容易证。我们将通过在3.5节中证明有无穷多个 4n+34n+34n+3 型的素数来说明这一点。 素数公式 是否有一个公式只产生素数呢？ 关于一个变元的多项式没有这种性质，习题23证明了这一点。同样，关于 nnn 个变元的多项式不能只产生素数，其中 nnn 是一个正整数（这个结论超出了本书的范围）。 有一些可以只产生素数的公式但是不实用。例如，米尔斯（Mills）证明了存在一个常数 素性证明 在广义黎曼猜想成立的条件下，米勒（G. L. Miller）于1975年给出了一个可用 O((log⁡n)5)O((\\log{n})^5)O((logn)5) 次位运算来证明一个整数是素数的算法。但可惜的是，广义黎曼猜想到现在尚未被证明。 ★\\bigstar★ 由于广义黎曼猜想并没有被证明，其后由Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。 在1983年，Leonard Adleman、Carl Pomerance和Robert Rumely建立了一个计算复杂度为 的算法，其中 是常数。 虽然他们的算法不是多项式时间，但是它已经接近多项式时间了，因为 增长得非常慢。 使用他们的算法结合现在的计算机确定一个100位的整数是否为素数只需几毫秒，确定一个400位的整数是否为素数用时不超过 秒，而确定一个1000位的整数是否为素数用时少于一个小时。（关于他们的算法的更多内容参见 [AdPoRu83] 和 [Ru83] ） 素性验证的多项式时间算法 2002年，一位印度计算机教授 我们现在只是讨论了素性检验中的「确定性算法」（deterministic algorithms），即用来确定一个整数是否为素数的算法。 在第6章中我们将讨论概率素性检验法，即米勒-拉宾算法，定理6.11。这个测试将告诉我们一个整数有很高的可能性是素数，但并不确定其为素数。 素数的分布 定理3.4-素数定理 定义：函数 π(x)\\pi(x)π(x) 表示不超过 xxx 的素数的个数，其中 xxx 是正实数。 素数定理：不超过 n\\sqrt{n}n​ 的素数个数大约为 nlog⁡n=2nlog⁡n\\dfrac{\\sqrt{n}}{\\log{\\sqrt{n}}}=\\dfrac{2\\sqrt{n}}{\\log{n}}logn​n​​=logn2n​​ 。 定理3.4(素数定理)：随着 xxx 的无限增长，π(x)\\pi(x)π(x) 和 xlog⁡x\\dfrac{x}{\\log{x}}logxx​ 的比趋于 111。这里，log⁡x\\log{x}logx 是 xxx 的自然对数 ln⁡x\\ln{x}lnx 。 如果用极限的语言来表述，我们有 lim⁡x→∞π(x)(x/log⁡x)=1\\lim\\limits_{x \\to \\infty} \\dfrac{\\pi(x)}{(x/\\log x)}=1x→∞lim​(x/logx)π(x)​=1。 用一个简单的方法来表述素数定理是写成 π(x)∽xlog⁡x\\pi(x)\\backsim\\dfrac{x}{\\log{x}}π(x)∽logxx​。这里符号~表示渐进于。 推论3.4.1 推论3.4.1： 定理3.5 如果随机地选择一个正整数，那么它是素数的概率有多大呢？ 定理3.5：对于任意的正整数 nnn，存在至少 nnn 个连续的正合数。 证明： 关于素数的猜想 伯兰特猜想； 「孪生素数猜想」； 「哥德巴赫猜想」：每个大于 222 的正偶数可以写成两个素数的和。 素数等差数列的「厄尔多斯猜想」：对任意的正整数 n≥3n\\ge 3n≥3，有一个由素数组成的长度为 nnn 的等差数列。 2006年Ben Green和陶哲轩取得了突破性进展从而证明了该猜想。 n2+1n^2+1n2+1 猜想：存在无穷多个形如 n2+1n^2+1n2+1 的素数，其中 nnn 是正整数。 勒让德猜想 最大公因子及其性质 定理3.6 定理3.6 ：a,ba,ba,b是整数，且 (a,b)=d(a,b)=d(a,b)=d ，那么 (ad,bd)=1(\\dfrac{a}{d},\\dfrac{b}{d})=1(da​,db​)=1 。（换言之，a/da/da/d 与 b/db/db/d 互素）。 证明： 我们将证明 a/d,b/da/d,b/da/d,b/d 除了 111 之外没有其他的公因子。 如果 (p,q)=1(p,q)=1(p,q)=1 ，则分数 p/qp/qp/q 被称为既约分数。 推论3.6.1 如果 (p,q)=1(p,q)=1(p,q)=1 ，则分数 p/qp/qp/q 被称为既约分数。 下面的推论告诉我们每一个分数都与另一个既约分数相等。 推论3.6.1：如果 a,ba,ba,b 为整数，且 b≠0b\\neq 0b=0 ，则 ab=pq\\dfrac{a}{b}=\\dfrac{p}{q}ba​=qp​ ，其中 p,qp,qp,q 为整数，且 (p,q)=1,q≠0(p,q)=1,q\\neq 0(p,q)=1,q=0 。 证明： 定理3.7 定理3.7：令 a,b,ca,b,ca,b,c 是整数，那么 (a,b)=(a+bc,b)(a,b)=(a+bc,b)(a,b)=(a+bc,b) 。 证明： 定理3.8 定义：如果 a,ba,ba,b 是整数，那么它们的线性组合具有形式 ma+nbma+nbma+nb ，其中 m,nm,nm,n 都是整数。 定理3.8：两个不全为零的整数 a,ba,ba,b 的最大公因子是 a,ba,ba,b 的线性组合中最小的正整数。 证明： 令 ddd 是 a,ba,ba,b 的线性组合中最小的正整数。（因为当 a≠0a\\neq 0a=0 时，两个线性组合 1×a+0×b1\\times a+0\\times b1×a+0×b 和 0×a+1×b0\\times a+1\\times b0×a+1×b 中必有一个为正，因此根据良序性，存在最小的正整数）。 我们有 d=ma+nbd=ma+nbd=ma+nb ，其中 m,nm,nm,n 是整数 。\\qquad\\qquad （1） 我们将证明 d∣a,d∣bd\\mid a,d\\mid bd∣a,d∣b 。 由带余除法，得到 a=dq+ra=dq+ra=dq+r，0≤r&lt;d0\\le r&lt;d0≤r&lt;d 。由这个方程和（1）可以得到 r=a−dq=a−q(ma+nb)=(1−mq)a−qnbr=a-dq=a-q(ma+nb)=(1-mq)a-qnbr=a−dq=a−q(ma+nb)=(1−mq)a−qnb 。这就证明了整数 rrr 是 a,ba,ba,b 的线性组合。因为 0≤r&lt;d0\\le r&lt;d0≤r&lt;d ，因为 ddd 是 a,ba,ba,b 的线性组合中最小的正整数，于是我们得到 r=0r=0r=0，因此 d∣ad\\mid ad∣a 。同理可得 d∣bd\\mid bd∣b 。 接下来证明它是 a,ba,ba,b 的最大公因子。为此只需证明 a,ba,ba,b 所有的公因子 ccc 都可整除 ddd 。 由于 d=ma+nbd=ma+nbd=ma+nb ，因此如果 c∣ac\\mid ac∣a 且 c∣bc\\mid bc∣b ，那么由定理1.9有 c∣dc\\mid dc∣d ，因此 d≥cd\\ge cd≥c 。 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 推论3.8.1-贝祖定理 推论3.8.1（Bezout，贝祖定理）：如果 a,ba,ba,b 均为整数，则有整数 m,nm,nm,n ，使得 ma+nb=gcd⁡(a,b)ma+nb=\\gcd(a,b)ma+nb=gcd(a,b) 。 方程 ma+nb=(a,b)ma+nb=(a,b)ma+nb=(a,b) 被称为 Bezout 等式，对给定的整数 a,ba,ba,b 满足该等式的整数 m,nm,nm,n 被称为是 a,ba,ba,b 的 Bezout 系数或 Bezout 数。 推论3.8.2 推论3.8.2：整数 a,ba,ba,b 互素当且仅当存在整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 。 证明： 定理3.9 定理3.9：如果 a,ba,ba,b 是正整数，那么所有 a,ba,ba,b 的线性组合构成的集合与所有 (a,b)(a,b)(a,b) 的倍数构成的集合相同。 证明： 假设 d=(a,b)d=(a,b)d=(a,b) ， 我们首先证明每个 a,ba,ba,b 的线性组合是 ddd 的倍数。 我们现在证明每一个 ddd 的倍数也是 a,ba,ba,b 的线性组合。 证毕。 定理3.10 定理3.10：如果 a,ba,ba,b 是不全为 000 的整数，那么正整数 ddd 是 a,ba,ba,b 的最大公因子，当且仅当 \\qquad\\qquad（i） d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b； \\qquad\\qquad（ii） 如果 ccc 是整数且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b ，那么 c∣dc\\mid dc∣d； 证明：\\qquad假设 d=(a,b)d=(a,b)d=(a,b) ， 证毕。 不依赖于整数的有序性定义最大公因子。 定义：令 是不全为零的整数。这些整数的公因子中最大的整数就是最大公因子。 的最大公因子记为 。(注意 在这里面出现的顺序不影响结果) 引理3.2 引理3.2：如果 是不全为零的整数，那么 。 欧几里得算法 引理3.3 - (a，b) = (b，a % b) 引理3.3 如果 是整数且 ，其中 是整数，那么 。 证明：在定理3.7中，取 ，即得到该引理。 定理3.11（欧几里得） 定理3.11(欧几里得算法) 证明：令 是正整数且满足 ，那么通过连续运用带余除法，我们求得 . 可以确定最后一定会有一个余数为零，这是因为余数组成的序列 所包含的项的个数不会大于 (因为每个余数都是整数)，由引理3.3，我们得到 ，因此 ，这是最后一个非零余数。 欧几里得算法是一种快速地求最大公因子的方法。接下来，当我们用欧几里得算法求两个正整数的最大公因子来估算除法的最大步数时会看到这一点。 int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 定理3.12-斐波那契与欧几里得 定理3.12：令 和 是斐波那契数列中连续的两项，那么用欧几里得算法证明 一共需要 步除法。 证明： 证毕。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 欧几里得算法的计算复杂度 定理3.13-拉梅定理 定理3.13（拉梅定理）：用欧几里得算法计算两个正整数的最大公因子时，所需的除法次数不会超过两个整数中较小的那个十进制的位数的5倍。 证明： 推论3.13.1 求两个正整数 的最大公因子需要 次的位运算。 拉梅定理的推论，它告诉我们欧几里得算法是非常高效的。 证明： 定理3.14（扩欧） 用线性组合的方式来表示最大公因子 如果已经求得 ，那么因为 ， 我们有 从 到 ，最终 这显示了如何沿着欧几里得算法产生的等式递进最终使得 的最大公因子 可以表示为 的线性组合。 自底向上计算 扩展欧几里得算法 只需用一次欧几里得算法就能计算出 。 然而写算法时，由于使用递归，倒推回去也可。 若使用以下方法。若输入数据不满足被除数大于除数，答案错误。 扩展欧几里得算法（自顶向下计算） 定理3.14 令 是正整数，那么 ， 其中 是下面定义的递归序列的第 项： 且 ， 其中 ，而 是欧几里得算法求 时每一步的商。 证明：我们将证明 ​ ， (3.2) 因为 ，一旦等式(3.2)成立，我们就有 。 我们用第二数学归纳原理来证明。 对于 ，有 。因此对 成立。类似地， ，所以对于 成立。 现在假设 ， 对于 成立。那么由欧几里得算法的第 步，我们有 ， 由归纳假设，得到 * * * 。 证毕。 算术基本定理 引理3.4 引理3.4 如果 是正整数，满足 且 ，则 。 证明：由于 ，存在整数 使得 。等式两边同时乘以 ，得 。根据定理1.9， ，这是因为这是 的线性组合，而它们都可以被 整除。因此 。 引理3.5 引理3.5：如果 整除 ，其中 为素数，且 是正整数，则存在整数 ，使得 p∣aip\\mid a_ip∣ai​ 。 证明：我们通过数学归纳法证明。①当 时，显然成立。②假定结果对 成立。考虑 个整数的乘积 ，它是能够被素数 整除的(这是如果，我们要证明的是 则，，，)。对于 的其中 项，要么是 ，要么是 。若 ，则由引理3.4， 。若 ，由归纳假设， 。因此存在整数 ，使得 。这样就证明了这个结果。 定理3.15-算术基本定理 定理3.15（算术基本定理）：每个大于 111 的正整数都可以被唯一地写成素数的乘积，在乘积中的素因子按照非降序排列。 证明： ①我们采用反证法：证明：每个大于 111 的数必能写成素数的乘积。 假定某正整数不能被写成素数的乘积。设 是这样的整数中最小的(良序性)。如果 是素数，那么它显然是素数的乘积，即一个素数 。所以 一定是合数。设 ，其中 。但是由于 都比 小，因此它们一定可以写成素数的乘积(良序性)。又由于 ，我们得到 也是素数的乘积。这个矛盾说明每个正整数都可以写成素数的乘积。 ②我们现在通过证明这个分解的唯一性来完成算术基本定理的证明。 假定整数 有两种不同的素数分解形式： ，其中 和 为素数，且 。 在这两个分解式中约去相同的素数，得到 *。*其中等式左边的素数与右边的不同， 。 然而，这导致了与引理3.5的矛盾。由该引理，一定存在某一个 使得 整除 ，这是不可能的，因为每个 都是与 不同的素数。 因此，正整数 nnn 的素因子分解是唯一的。■\\qquad\\qquad\\qquad\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 整数分解中把素因子组合成幂的形式被称为素幂因子分解（prime-power factorization）。 唯一因子分解在哪里不成立：每个正整数有唯一的素因子分解这个事实是整数集合与其他一些集合共有的一个特殊性质，但并非所有的数系都有这个性质。 素因子分解的应用 用素因子分解描述最大公因子 求两个正整数的最小公倍数。 定义：两个非零整数 的最小公倍数（lcm）是能够被 整除的最小正整数。 的最小公倍数记为 。也可用记号 。 如果 其中 是 的素因子。 其中 是 的素因子。 则 ，其中 是 素因子的并集 。 求解大整数的素因子分解比较耗费时间。因此，我们想要一种求两个整数的最小公倍数但却不使用整数的素因子分解的方法。 引理3.6 证明：分类讨论。 定理3.16 定理3.16 如果 是正整数，则 ，其中 分别是 的最小公倍数和最大公因子。 证明： 下述推论将在后面用到。 引理3.7 证明： 狄利克雷定理中一种特殊情形的证明。 关于无理数的结果 因子分解法和费马数 线性丢番图方程","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"贪心算法的证明","slug":"DS_Algorithm证明与讲解/贪心/贪心算法的证明","date":"2021-08-21T16:00:00.000Z","updated":"2021-08-22T09:45:55.046Z","comments":true,"path":"2021/08/22/DS_Algorithm证明与讲解/贪心/贪心算法的证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/22/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E/","excerpt":"","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"离散化","slug":"DS_Algorithm证明与讲解/基础算法/离散化","date":"2021-08-15T16:00:00.000Z","updated":"2021-09-22T01:54:28.300Z","comments":true,"path":"2021/08/16/DS_Algorithm证明与讲解/基础算法/离散化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/","excerpt":"","text":"思路 保序 将所有值排序 去重 二分查找 无序 const int N = 1e5 + 10;unordered_map&lt;int, int&gt; hash;int p[N];int get(int x) // 无序离散化&#123; if(h.count(x) == 0) hash[x] = ++ n; return hash[x];&#125;int main()&#123; int cnt = 0; hash.clear(); for(int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; p[i] = get(l); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford","date":"2021-08-15T03:19:20.673Z","updated":"2021-08-15T03:19:38.275Z","comments":true,"path":"2021/08/15/DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/Bellman-Ford/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BFS","slug":"题目/搜索/BFS","date":"2021-08-14T16:00:00.000Z","updated":"2021-09-04T06:08:19.731Z","comments":true,"path":"2021/08/15/题目/搜索/BFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/BFS/","excerpt":"","text":"多源BFS AcWing 173. 矩阵距离 最小步数模型 AcWing 1107. 魔板 双端队列广搜 AcWing 175. 电路维修 洛谷 P1948 [USACO08JAN]Telephone Lines S 洛谷 CF1063B Labyrinth 洛谷 CF1031D Minimum path 双向广搜 AcWing 190. 字串变换 A* AcWing 178. 第K短路：估价函数 AcWing 179. 八数码：估价函数","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Dijkstra","slug":"DS_Algorithm证明与讲解/图论/最短路/Dijkstra","date":"2021-08-14T16:00:00.000Z","updated":"2021-08-15T03:18:54.880Z","comments":true,"path":"2021/08/15/DS_Algorithm证明与讲解/图论/最短路/Dijkstra/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/Dijkstra/","excerpt":"","text":"Dijkstra证明 朴素版Dijkstra 堆优化版 Dijkstra","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://xiaoke-jin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"BFS求单源最短路证明","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS求单源最短路证明","date":"2021-08-13T16:00:00.000Z","updated":"2021-08-15T02:29:07.251Z","comments":true,"path":"2021/08/14/DS_Algorithm证明与讲解/搜索/BFS/BFS求单源最短路证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/14/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%E6%B1%82%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AF%81%E6%98%8E/","excerpt":"","text":"BFS求单源最短路证明 2021-08-15 算法导论 P364 挖个坑，日后补充。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"搜索讲解","slug":"DS_Algorithm证明与讲解/搜索/BFS&DFS","date":"2021-08-12T16:00:00.000Z","updated":"2021-08-15T02:23:59.450Z","comments":true,"path":"2021/08/13/DS_Algorithm证明与讲解/搜索/BFS&DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/13/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS&DFS/","excerpt":"","text":"四联通与八联通 「四联通」 int dx[5] = &#123;-1, 0, 1, 0&#125;, dy[5] = &#123;0, 1, 0, -1&#125;;for(int i = 0; i &lt; 4; i++) for(int j = 0; j &lt; 4; j++)&#123; int nx = x + dx[i], ny = y + dy[j]; &#125; 「八连通」 // 1int dx[10] = &#123;-1, -1, 0, 1, 1, 1, 0, -1&#125;, dy[10] = &#123;0, 1, 1, 1, 0, -1, -1, -1&#125;;// 2for(int i = x - 1; i &lt;= x + 1; i++) for(int j = y - 1; j &lt;= y + 1; j++)&#123; if(i == x &amp;&amp; j == y)continue; // 遍历到自己，跳过&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS求最短路","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS大纲","date":"2021-08-12T16:00:00.000Z","updated":"2021-09-05T15:36:13.680Z","comments":true,"path":"2021/08/13/DS_Algorithm证明与讲解/搜索/BFS/BFS大纲/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/13/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"本质：转换为Dijkstra 扩展 多源BFS 最小步数模型 双端队列广搜 双向广搜 A*","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"高精度板子","slug":"DS_Algorithm证明与讲解/基础算法/高精度板子","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:21:53.095Z","comments":true,"path":"2021/08/12/DS_Algorithm证明与讲解/基础算法/高精度板子/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%9D%BF%E5%AD%90/","excerpt":"","text":"加 ​ 减 ​ 乘 ​ 除 ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://xiaoke-jin.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"RMQ题目","slug":"题目/基础算法/RMQ","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:23:31.923Z","comments":true,"path":"2021/08/12/题目/基础算法/RMQ/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/RMQ/","excerpt":"","text":"AcWing 1273. 天才的记忆 离线算法 预处理：O(nlog⁡n)O(n\\log{n})O(nlogn)，查询：O(1)O(1)O(1)。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"}]},{"title":"并查集题目","slug":"题目/数据结构/并查集","date":"2021-08-11T16:00:00.000Z","updated":"2021-09-24T09:58:31.851Z","comments":true,"path":"2021/08/12/题目/数据结构/并查集/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"基础操作：查询，合并 洛谷 P3367 【模板】并查集 AcWing 1250. 格子游戏 洛谷 P1455 搭配购买 洛谷 P1955 程序自动分析 并查集扩展版 维护 size （集合中元素数量） AcWing 837. 连通块中点的数量 边带权 和 扩展域 洛谷 P2024 食物链 普通做法：扩展域 带权并查集的做法：AcWing 240. 食物链(带权并查集) 洛谷 P5937 [CEOI1999]Parity Game：注意与 洛谷 P1955 程序自动分析 的区别；是 洛谷 P2024 食物链 简化版 洛谷 P1196 [NOI2002] 银河英雄传说 Kruskal","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"数据结构","slug":"题目/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://xiaoke-jin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"STL与常用库函数","slug":"DS_Algorithm证明与讲解/基础算法/STL","date":"2021-08-10T16:00:00.000Z","updated":"2021-09-20T14:49:09.427Z","comments":true,"path":"2021/08/11/DS_Algorithm证明与讲解/基础算法/STL/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/11/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/STL/","excerpt":"","text":"常用库函数 reverse() sort pair 基本操作 pair&lt;int, int&gt; p;p.first; // 第一个元素p.second; // 第二个元素// 初始化pair&lt;int, int&gt; p = (1, 1);p = make_pair(10, &quot;yxc&quot;);p = (20, &quot;abc&quot;);// 使用 &#123;&#125;快速构造一个pairq.push_back(&#123;1, 1&#125;); 支持比较运算 以first为第一关键字，以second为第二关键字（字典序）。 vector 初始化 vector&lt;int&gt; a; // 定义一个vectorvector&lt;int&gt; a(n); // 定义一个长度为 n的vectorvector&lt;int&gt; a(10, 3); // 定义一个长度为 10,且每个元素值为 3的vectorvector&lt;int&gt; a[10]; // 定义 10个vector 函数 size(); // 返回vector中元素个数empty(); // 若vector为空,返回true; 否则返回 falseclear(); // 清空vectorpush_back()/pop_back(); // 在末尾插入/删除一个元素front()/begin(); // 返回第一个/最后一个元素// 返回向量头指针,指向第一个元素/返回向量尾指针,指向向量最后一个元素的「下一个位置」begin()/end();[]; // 支持数组操作; 下标从0开始 三种遍历方式 for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;// vector&lt;int&gt;::iterator可用 auto代替for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;for(auto x : a) cout &lt;&lt; x &lt;&lt; &quot; &quot;;cout &lt;&lt; endl; 支持比较运算 vector&lt;int&gt; a(4, 3), b(3, 4);// 按字典序比较if(a &lt; b) puts(&quot;a &lt; b&quot;); string 函数 size()/length() // 字母个数empty() // 是否为空clear() // 清空substr(n) // 返回从下标 n开始的子串substr(n, m) // 返回从下标 n开始, 长度为 m的子串; 若越界的话, 会输出到最后一个字符为止。printf(&quot;%s\\n&quot;, a.c_str()); // 使用 %s输出字符串 运算符 string a = &quot;yxc&quot;;a += &quot;nb&quot;; // 支持 +=操作a += &#x27;1&#x27;string b = &quot;1111&quot;;b[1] = &#x27;\\0&#x27;;b[2] = &#x27; &#x27;;cout &lt;&lt; b &lt;&lt; endl; // 输出 “1 1”，空格被输出;空字符跳过,不输出; 关于'\\0' std::string：标准中未规定需要'\\0'作为字符串结尾。编译器在实现时既可以在结尾加'\\0'，也可以不加。（因编译器不同） 但是，当通过c_str()或data()（二者在 C++11 及以后是等价的）来把std::string转换为const char *时，会发现最后一个字符是'\\0'。但是C++11，string字符串都是以'\\0'结尾。 Q：为什么C语言风格的字符串要以'\\0'结尾，C++可以不要？ A：C语言用char*指针作为字符串时，在读取字符串时需要一个特殊字符0来标记指针的结束位置，也就是通常认为的字符串结束标记。而C++语言则是面向对象的，长度信息直接被存储在了对象的成员中，读取字符串可以直接根据这个长度来读取，所以就没必要需要结束标记了。而且结束标记也不利于读取字符串中夹杂0字符的字符串。 queue 函数 size()empty()push()pop()front()back()q = queue&lt;int&gt;();// 重新构造一次即可清空队列; 没有 clear函数 priority_queue 定义 // 默认定义大根堆priority_queue&lt;int&gt; heap;// 定义小根堆// 1.插入负数// 2.priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; 函数 push()top()pop()// 无 clear() stack 函数 size()empty()push()pop()top() deque 函数 size()empty()clear()front()back()push_back()/pop_back()push_front()/pop_front()begin()/end()[] set 不能有重复元素 map multiset 可以有重复元素 multimap unordered_set unordered_map unordered_map&lt;key, T&gt; a; // key:键的类型, T:值的类型 unordered_multiset unordered_multimap bitset bitset&lt;n&gt; s; // 定义长度为 n的bool数组/* 支持位运算：~ &amp; | ^ &lt;&lt; &gt;&gt; * ==, != * [] */count() // 返回有多少个 1any() // 判断是否至少有一个 1none() // 判断是否全为 0set() // 把所有位置为 1set(k, v) // 将第k位变为 vreset() // 把所有位变成 0 flip() // 所有位取反flip(k) // 把第k位取反","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://xiaoke-jin.github.io/tags/STL/"}]},{"title":"洛谷名字颜色","slug":"杂文/洛谷名字颜色","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T05:07:28.636Z","comments":true,"path":"2021/08/10/杂文/洛谷名字颜色/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E6%9D%82%E6%96%87/%E6%B4%9B%E8%B0%B7%E5%90%8D%E5%AD%97%E9%A2%9C%E8%89%B2/","excerpt":"","text":"名字颜色规则 动态等级是根据用户在一段时间内的刷题、社区活跃、打卡、题解、违规情况，按照一定算法得出的结果，该算法不公开。动态等级比较准确的表现了用户一段时间内在洛谷的综合行为。 动态等级由 -1 到 4， 管理员的用户名颜色为 紫色\\color{purple}{紫色}紫色，不受动态等级影响。 用户名的颜色为分别对应为棕色、灰色、蓝色、绿色、橙色、红色。 -1 棕色\\color{brown}{棕色}棕色 作弊者 0 灰色\\color{Grey}{灰色}灰色 见习用户 即咕值&lt;100&lt;100&lt;100的用户 1 蓝色\\color{blue}{蓝色}蓝色 普通用户 即咕值在[100,119][100,119][100,119]的用户 2 绿色\\color{green}{绿色}绿色 算法爱好者 即咕值在[120,169][120,169][120,169]的用户 3 橙色\\color{orange}{橙色}橙色 刷题健将 即咕值在[170,229][170,229][170,229]的用户 4 红色\\color{RED}{红色}红色 虐题狂魔 即咕值&gt;229&gt;229&gt;229的用户 新用户的初始动态等级为 0，也就是 灰色\\color{Grey}{灰色}灰色 用户名。用户在洛谷中按照洛谷社区规则使用各项功能，会增加动态等级。如果长时间不使用洛谷或者有违规行为，可能会降级。除非用户有严重违规行为或者在长时间不使用洛谷且未进行实名认证的情况下，一旦用户达到蓝名，则不会掉到 灰色\\color{Grey}{灰色}灰色 。你可以在打卡之后在打卡结果中看到自己用户名的颜色。在犇犇或者讨论中询问颜色名字和咕值相关的一些问题将被和谐。 如果用户抄袭题解或非恶意比赛作弊，将降级至棕名及名字旁带有 Cheater\\color{brown}{Cheater}Cheater 标签，每次查到持续 15 日，并且在 90 日内不得在任何比赛获得排名。15 日后，变成 灰色\\color{Grey}{灰色}灰色 并清空所有 ACACAC 记录。（即，变为 Unaccepted 100Unaccepted\\ \\ \\ 100Unaccepted 100 分状态）。（注：棕名\\color{brown}{棕名}棕名用户是仅次于封号的最严厉警告，如果发生任何违反洛谷社区规则的事情，直接立刻封禁一年。） 动态等级影响洛谷内很多权限，例如创建比赛、团队、提交冷却时间、图床、下载数据等。灰名\\color{Grey}{灰名}灰名 会有较多的限制。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://xiaoke-jin.github.io/tags/%E6%B4%9B%E8%B0%B7/"}]},{"title":"LaTeX","slug":"语言/LaTeX","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-10T09:00:31.417Z","comments":true,"path":"2021/08/10/语言/LaTeX/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E8%AF%AD%E8%A8%80/LaTeX/","excerpt":"","text":"LaTeX入门 LaTeX入门 KaTeX KaTeX源码 其他网站 在线LaTeX编辑器","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://xiaoke-jin.github.io/tags/LaTeX/"}]},{"title":"Markdown","slug":"语言/Markdown","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-15T02:06:55.617Z","comments":true,"path":"2021/08/10/语言/Markdown/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E8%AF%AD%E8%A8%80/Markdown/","excerpt":"","text":"Markdown编辑器 Markdown语法 如何在Markdown中输入数学公式 Markdown KaTeX多个公式对齐 格式手册 行间公式 如果这些多行对齐的公式需要 编号，请用 align 或 equation 环境； 请使用 \\begin&#123;aligned&#125; ... \\end&#123;aligned&#125; 表示多行对齐的公式； 每行式子分别编号：使用 align d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{align} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{align} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​​ 一坨式子一个编号：使用 aligned d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{aligned} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{aligned} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​ 不编号：align* a=b+c=e+f\\begin{align*} a&amp;=b+c\\\\ &amp;=e+f \\end{align*} a​=b+c=e+f​ 公式左对齐 \\begin{align*}\\label{2} & X(0) = x(0)W_{N}^{0\\cdot0} + x(1)W_{N}^{0\\cdot1} + \\cdots + x(N-1)W_{N}^{0\\cdot(N-1)}\\\\ & X(1) = x(0)W_{N}^{1\\cdot0} + x(1)W_{N}^{1\\cdot1} + \\cdots + x(N-1)W_{N}^{1\\cdot(N-1)} \\\\ & \\cdots \\\\ & X(N-1) = x(0)W_{N}^{(N-1)\\cdot0} + x(1)W_{N}^{(N-1)\\cdot1} + \\cdots + x(N-1)W_{N}^{(N-1)\\cdot(N-1)} \\\\ \\end{align*} 数学公式 数学公式中的中文文字 必须置于 \\text&#123;&#125; 命令之中，而变量、数字、运算符、函数名称则必须置于 \\text&#123;&#125; 命令之外。请不要在 \\text&#123;&#125; 命令中嵌套数学公式； 使用 array 环境时请注意 实际列数与对齐符号的数量保持一致。例如下面的公式中，数据实际有 3 列（&amp; 是列分隔符），因此需要 3 个对齐符号（l/r/c 分别表示左、右、居中对齐）。 F1={01,11}F2={01,12,11}\\begin{array}{lll} F_1=\\{\\frac{0}{1},&amp;&amp;\\frac{1}{1}\\}\\\\ F_2=\\{\\frac{0}{1},&amp;\\frac{1}{2},&amp;\\frac{1}{1}\\}\\\\ \\end{array} F1​={10​,F2​={10​,​21​,​11​}11​}​ 使用巨型运算符：加上 \\displaystyle $\\displaystyle \\sum_&#123;j=m&#125;^&#123;n&#125;ca_j=c\\sum_&#123;j=m&#125;^&#123;n&#125;a_j$ LaTeX公式的要求 使用 Roman 体表示常量和函数。使用 Italic 体表示变量。 如果遇到没有预先定义好的需要使用 Roman 体的 函数名，我们可以使用 $\\operatorname&#123;something&#125;$ 来产生，如我们可以使用 $\\operatorname&#123;lcm&#125;$ 产生正体的最小公倍数（函数）符号。 同理，产生 Roman 体的 常量 应用 $\\mathrm&#123;&#125;$；产生 Roman 体粗体符号应用 $\\mathbf&#123;&#125;$； 产生 Italic 体粗体符号应用 $\\boldsymbol&#123;&#125;$（如向量 ）。 对于多字母的变量，应当使用 $\\textit&#123;&#125;$。 其他非数学内容，包括英文、特殊符号等，一律使用 $\\text&#123;&#125;$。中文我们则建议不放在 LaTeX 公式中。 在行内使用分数的时候，请使用 $\\dfrac&#123;&#125;&#123;&#125;$。比如 $\\dfrac&#123;1&#125;&#123;2&#125;$，效果 12\\dfrac{1}{2}21​ ，而不是 $\\frac&#123;1&#125;&#123;2&#125;$，效果 12\\frac{1}{2}21​。 组合数请使用 \\dbinom&#123;n&#125;&#123;m&#125;，效果 (nm)\\dbinom{n}{m}(mn​)，而不是 &#123;n \\choose m&#125;（在 LaTeX 中这种写法已不推荐）；与上一条关于分数的约定相似，请不要使用 \\binom&#123;n&#125;&#123;m&#125;，效果 (nm)\\binom{n}{m}(mn​)。 在不会引起歧义的情况下，请用 $\\times$ 代替星号。叉乘请使用 $\\times$，点乘请使用 $\\cdot$。如 a×ba\\times ba×b，a⋅ba\\cdot ba⋅b ，而不是 a∗ba*ba∗b。 请注意，不要在非代码区域使用任何程序设计语言的表示方式，而是使用 LaTeX 公式。例如，使用 $=$ 而不是 $==$（如 a=ba=ba=b ，而不是 a==ba==ba==b ）、使用 a&lt;&lt;1 或者 $a\\times 2$ 而不是 $a&lt;&lt;1$、使用 $a\\bmod b$ 代替 $a\\%b$（如 a mod ba\\bmod bamodb，而不是 a%ba\\%ba%b ）等。 公式中不要使用中括号连缀（即 C++ 高维数组的表示方式）而多使用下标。 为了统一且书写方便，复杂度分析时大 OOO 记号请直接使用 $O()$ 而不是 $\\mathcal O()$。","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://xiaoke-jin.github.io/tags/Markdown/"}]},{"title":"RMQ","slug":"DS_Algorithm证明与讲解/基础算法/RMQ","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-22T01:59:44.458Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/RMQ/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/RMQ/","excerpt":"","text":"RMQ RMQ ( Range Minimum/Maximum Query )，即区间最值查询。 RMQRMQRMQ 算法一般用较长时间做预处理，时间复杂度为 O(nlog⁡n)O(n\\log{n})O(nlogn)，然后可以在 O(1)O(1)O(1) 的时间内处理每次查询。 ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"}]},{"title":"二分","slug":"DS_Algorithm证明与讲解/基础算法/二分","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:12:12.350Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/二分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分本质 「二段性」 只要能确定目标一定在mid左边或右边。 ​ 注意事项 「边界问题」 小于所有元素，大于所有元素。即不属于查找范围内。 ​ 整数二分 while(l &lt; r) ​ 实数二分 「精度问题」：如果要求保留到n位，则while(r - l &gt; 1e-(n + 2))即可。 ​ ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"前缀和与差分","slug":"DS_Algorithm证明与讲解/基础算法/前缀和与差分","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-04T13:59:49.358Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/前缀和与差分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 一维前缀和 求前n个数的和 a[i] = a[i - 1] + a[i] 求某区间 [l,r][l, r][l,r] 的和 x = a[r] - a[l - 1] 差分 应用：对区间进行加或减操作。 一维差分 概念：对数列 {an}\\{a_n\\}{an​} 有数列 {bn}\\{b_n\\}{bn​} ，使得 an=bn+bn−1+bn−2+⋯+b1a_n=b_n+b_{n-1}+b_{n-2}+\\cdots+b_1an​=bn​+bn−1​+bn−2​+⋯+b1​ 。 构造方式： an=(an−an−1)+(an−1−an−2)+⋯+(a1−a0)=an−a0=ana_n=(a_n-a_{n-1})+(a_{n-1}-a_{n-2})+\\cdots+(a_1-a_0)=a_n-a_0=a_nan​=(an​−an−1​)+(an−1​−an−2​)+⋯+(a1​−a0​)=an​−a0​=an​ 。 for(int i = 1; i &lt;= n; i++) b[i] = a[i] - a[i - 1]; 对区间 [l,r][l,r][l,r] 加或减 xxx：改变序列 {bn}\\{b_n\\}{bn​} 中的一个或两个数。 b[l] += x;b[r + 1] -= x; // 若r=n, 这一步可以省略 二维差分","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"}]},{"title":"排序题目","slug":"题目/基础算法/排序","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:22:35.154Z","comments":true,"path":"2021/08/10/题目/基础算法/排序/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序 AcWing 105. 七夕祭 AcWing 106. 动态中位数 求中位数 对顶堆 ==对顶思想== 逆序对 AcWing 788. 逆序对的数量 AcWing 107. 超快速排序 最少执行多少交换操作才能对给定的输入序列进行排序。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://xiaoke-jin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"小技巧","slug":"题目/小技巧","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-15T03:37:12.836Z","comments":true,"path":"2021/08/09/题目/小技巧/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"倒着来！！！ 字典序最小 AcWing 12. 背包问题求具体方案 记录方案 AcWing 1076. 迷宫问题","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"小技巧","slug":"题目/小技巧","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"感想","slug":"题目/感想","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-13T08:13:51.981Z","comments":true,"path":"2021/08/09/题目/感想/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/","excerpt":"","text":"2021/08/10/22:41 拜服于大佬的精妙思想 ​ 2021/08/12 最难的不是数据结构与算法的学习，而是对题目进行深入分析，发掘其本质，将其转换为「易于求解的等价问题」。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"刷题注意事项","slug":"题目/注意事项","date":"2021-08-08T16:00:00.000Z","updated":"2021-09-04T14:16:11.331Z","comments":true,"path":"2021/08/09/题目/注意事项/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"需要特判的情况 搜索：起点和终点相同。 区间内第一个整除某素数的数不一定是合数，可能是其本身。 注意高精度、LL的坑 int 十进制：−231=−2147483648-2^{31}=-21 4748 3648−231=−2147483648 到 231−1=21474836472^{31}-1=21 4748 3647231−1=2147483647 。共10位，21亿。 求方案数； 逆序对数量； ​ 数组下标需要从1开始 数组堆； 背包DP； 前缀和与差分； 输入字符 注意空字符； %c会读入换行符、空格； %s输入输出会略过空格、换行符； 输入「带空格」的字符矩阵 char g[N][N];for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 2 * m; j++)&#123;//读入末尾换行符 char ch; scanf(&quot;%c&quot;, &amp;ch); if(ch == &#x27; &#x27; || ch == &#x27;\\n&#x27;) ; // 不进行任何操作 else g[i][j/2] = ch; // j/2 &#125; 输入「不带空格」的字符矩阵 输入为数字但「数字之间没有空格」，将其视为字符串。 char g[100][100];for(int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]); 输入单个字符 char op[2];scanf(&quot;%s&quot;, op); ​ 二分 (l + r) / 2 与 (l + r + 1) / 2； 考虑目标元素小于或大于区间内所有元素； ​ 双指针 防止指针越界 注意指针位置 ​","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}],"tags":[{"name":"刷题注意事项","slug":"刷题注意事项","permalink":"http://xiaoke-jin.github.io/tags/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}]},{"title":"递推与递归","slug":"题目/基础算法/递推与递归","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-08T14:20:16.399Z","comments":true,"path":"2021/08/08/题目/基础算法/递推与递归/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/08/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"递推 AcWing 95. 费解的开关 递归 AcWing 98. 分形之城","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递推与递归","slug":"递推与递归","permalink":"http://xiaoke-jin.github.io/tags/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/"}]},{"title":"位运算题目","slug":"题目/基础算法/位运算","date":"2021-08-06T16:00:00.000Z","updated":"2021-08-14T07:55:38.057Z","comments":true,"path":"2021/08/07/题目/基础算法/位运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/07/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"位运算 二进制枚举 快速幂，快速加 AcWing 90. 64位整数乘法 AcWing 875. 快速幂","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://xiaoke-jin.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"背包讲解","slug":"DS_Algorithm证明与讲解/DP/背包","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-13T01:13:17.488Z","comments":true,"path":"2021/08/06/DS_Algorithm证明与讲解/DP/背包/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/DP/%E8%83%8C%E5%8C%85/","excerpt":"","text":"01背包 AcWing 423. 采药【01背包DP模型+朴素优化】","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"前缀和与差分题目","slug":"题目/基础算法/前缀和与差分","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-14T07:57:23.609Z","comments":true,"path":"2021/08/06/题目/基础算法/前缀和与差分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 AcWing 99. 激光炸弹 差分 AcWing 100. 增减序列 分析 三种类型的操作 贪心——尽快得到0 优先操作一(可以改变两个数)，然后再使用操作二、三补充。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"}]},{"title":"贪心题目","slug":"题目/贪心/贪心","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-14T07:58:41.013Z","comments":true,"path":"2021/08/06/题目/贪心/贪心/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"贪心","slug":"题目/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"二分题目","slug":"题目/基础算法/二分","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-13T08:15:31.708Z","comments":true,"path":"2021/08/05/题目/基础算法/二分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/05/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分 AcWing_P790 浮点数二分 AcWing 102. 最佳牛围栏 平均值最大的问题，一般都可以转化为二分。 AcWing 113. 特殊排序 本题的解答过程事实上证明了：任意有向完全图（又称竞赛图）都存在Hamilton路径。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"背包题目","slug":"题目/DP/背包","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-15T02:14:43.991Z","comments":true,"path":"2021/08/05/题目/DP/背包/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/05/%E9%A2%98%E7%9B%AE/DP/%E8%83%8C%E5%8C%85/","excerpt":"","text":"求方案数 物品选择顺序不影响方案数 求方案数 AcWing 278. 数字组合 AcWing 1023. 买书 AcWing 1021. 货币系统 求最小方案数 洛谷 P1679. 神奇的四次方数 求最优方案数 AcWing 11. 背包问题求方案数 物品选择顺序影响方案数 AcWing 3643. 上楼梯 求具体方案 要求字典序最小 AcWing 12. 背包问题求具体方案 求任意一个方案 1. 至多、恰好、至少 问题 至多 AcWing 423. 采药 AcWing 1019. 庆功会 洛谷 P1802 5倍经验日 至少 AcWing 1020. 潜水员 恰好 多维费用背包问题 AcWing 8. 二维费用的背包问题 AcWing 1022. 宠物小精灵之收服 墨染空的优化 链接 洛谷 P1509 找啊找啊找GF 分组背包 AcWing 1013. 机器分配 AcWing 487. 金明的预算方案 背包 + AcWing 734. 能量石","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"DP","slug":"题目/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]}],"categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"},{"name":"数论","slug":"题目/数论","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E8%AE%BA/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"工具/VSCode","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/VSCode/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"题目/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"},{"name":"小技巧","slug":"题目/小技巧","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"},{"name":"贪心","slug":"题目/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"题目/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/DP/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/tags/Github/"},{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"},{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"},{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"最短路","slug":"最短路","permalink":"http://xiaoke-jin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"高精度","slug":"高精度","permalink":"http://xiaoke-jin.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"},{"name":"并查集","slug":"并查集","permalink":"http://xiaoke-jin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"STL","slug":"STL","permalink":"http://xiaoke-jin.github.io/tags/STL/"},{"name":"洛谷","slug":"洛谷","permalink":"http://xiaoke-jin.github.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://xiaoke-jin.github.io/tags/LaTeX/"},{"name":"Markdown","slug":"Markdown","permalink":"http://xiaoke-jin.github.io/tags/Markdown/"},{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"name":"排序","slug":"排序","permalink":"http://xiaoke-jin.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"刷题注意事项","slug":"刷题注意事项","permalink":"http://xiaoke-jin.github.io/tags/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"递推与递归","slug":"递推与递归","permalink":"http://xiaoke-jin.github.io/tags/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/"},{"name":"位运算","slug":"位运算","permalink":"http://xiaoke-jin.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]}