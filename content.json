{"meta":{"title":"Cloud","subtitle":"Just for fun!","description":"Welcome To The World Of Algorithm","author":"A Cloud","url":"http://Xiaoke-Jin.github.io","root":"/"},"pages":[{"title":"","date":"2021-08-01T07:35:22.898Z","updated":"2021-08-01T07:35:22.898Z","comments":true,"path":"manifest.json","permalink":"http://xiaoke-jin.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2021-09-30T01:53:23.182Z","updated":"2021-09-30T01:53:23.182Z","comments":true,"path":"css/style.css","permalink":"http://xiaoke-jin.github.io/css/style.css","excerpt":"","text":"/* 网页侧边滚动条样式 */ ::-webkit-scrollbar { width: 8px; height: 8px; } /* 鼠标样式 */ body { cursor: url(https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/default.cur), default; } a, img { cursor: url(https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/pointer.cur), default; } /* 网页底部 */ #footer { background: transparent; } #footer-wrap { color: black; }"},{"title":"文章分类","date":"2021-07-29T14:53:49.000Z","updated":"2021-08-01T04:28:40.971Z","comments":true,"path":"categories/index.html","permalink":"http://xiaoke-jin.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-30T09:43:50.000Z","updated":"2021-08-01T04:28:40.966Z","comments":true,"path":"about/index.html","permalink":"http://xiaoke-jin.github.io/about/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T09:05:40.000Z","updated":"2021-08-01T04:28:40.976Z","comments":true,"path":"link/index.html","permalink":"http://xiaoke-jin.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T04:53:46.000Z","updated":"2021-08-01T04:28:40.981Z","comments":true,"path":"tags/index.html","permalink":"http://xiaoke-jin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Github访问优化","slug":"Github/Github访问加速","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-10T08:35:56.086Z","comments":true,"path":"20201/08/01/Github/Github访问加速/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Github/Github%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/","excerpt":"","text":"Sky03’ Blog: Github访问优化","categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/tags/Github/"}]},{"title":"静态博客访问优化","slug":"Hexo/静态博客访问优化","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-10T08:36:58.317Z","comments":true,"path":"20201/08/01/Hexo/静态博客访问优化/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Hexo/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96/","excerpt":"","text":"Sky03’ Blog: 静态博客访问优化","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"一个开源博客项目","slug":"Hexo/一个开源项目","date":"+020201-07-31T16:00:00.000Z","updated":"2021-08-08T14:33:30.122Z","comments":true,"path":"20201/08/01/Hexo/一个开源项目/","link":"","permalink":"http://xiaoke-jin.github.io/20201/08/01/Hexo/%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"Hexo+Github博客搭建完全教程","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"Butterfly主题及其美化","slug":"Hexo/Butterfly主题及其美化","date":"+020201-07-29T16:00:00.000Z","updated":"2021-08-10T08:37:25.035Z","comments":true,"path":"20201/07/30/Hexo/Butterfly主题及其美化/","link":"","permalink":"http://xiaoke-jin.github.io/20201/07/30/Hexo/Butterfly%E4%B8%BB%E9%A2%98%E5%8F%8A%E5%85%B6%E7%BE%8E%E5%8C%96/","excerpt":"","text":"官方文档 Butterfly官方文档 卷二兔 图片自适应 webp 及全站 CDN 加速 更换博客背景图片及图片压缩","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"}],"tags":[]},{"title":"","slug":"题目/错误统计","date":"2021-11-02T11:09:40.234Z","updated":"2021-11-02T11:11:45.184Z","comments":true,"path":"2021/11/02/题目/错误统计/","link":"","permalink":"http://xiaoke-jin.github.io/2021/11/02/%E9%A2%98%E7%9B%AE/%E9%94%99%E8%AF%AF%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"没用注意到爆 int：2 没有调用预处理函数：1 等号写成 = ：1","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/关于和式","date":"2021-10-31T09:46:00.630Z","updated":"2021-11-01T13:49:48.498Z","comments":true,"path":"2021/10/31/DS_Algorithm证明与讲解/数论/关于和式/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/31/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E5%85%B3%E4%BA%8E%E5%92%8C%E5%BC%8F/","excerpt":"","text":"求和符号 ∑ 视频链接：南大蒋炎岩","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/具体数学/第二章 和式","date":"2021-10-31T03:48:53.399Z","updated":"2021-10-31T03:49:04.527Z","comments":true,"path":"2021/10/31/读书笔记/数学/具体数学/第二章 和式/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%92%8C%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/数论分块","date":"2021-10-31T02:12:35.598Z","updated":"2021-10-31T08:57:58.943Z","comments":true,"path":"2021/10/31/DS_Algorithm证明与讲解/数论/数论分块/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/31/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/","excerpt":"","text":"链接：OI-Wiki 数论分块，作者@Luckyblock，ThinkofBlank 的博客 , 新数论分块的推广及其复杂度证明 。 数论分块可以快速计算一些含有除法向下取整的和式（即形如 ∑i=1nf(i)g(⌊ni⌋)\\sum_{i=1}^nf(i)g(\\left\\lfloor\\dfrac ni\\right\\rfloor)∑i=1n​f(i)g(⌊in​⌋) 的和式）。当可以在 O(1)O(1)O(1) 内计算 f(r)−f(l)f(r)-f(l)f(r)−f(l) 或已经预处理出 fff 的前缀和时，数论分块就可以在 O(n)O(\\sqrt n)O(n​) 的时间内计算上述和式的值。 它主要利用了富比尼定理（Fubini’s theorem），将 ⌊ni⌋\\left\\lfloor\\dfrac ni\\right\\rfloor⌊in​⌋ 相同的数打包同时计算。 富比尼定理 又称“算两次”，以意大利数学家圭多 · 富比尼（Guido Fubini）命名。 富比尼定理的积分形式：只要二重积分 ∫∫∣f(x,y)∣dxdy\\int\\int |f(x,y)|dxdy∫∫∣f(x,y)∣dxdy 有界，则可以逐次计算二重积分，并且可以交换逐次积分的顺序。 积分号也是特殊的求和号，因此在一般求和中，富比尼定理往往呈现为更换计数顺序，即交换两个求和号。 组合数学中的富比尼定理表现为，用两种不同的方法计算同一个量，从而建立相等关系。","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/狄利克雷卷积","date":"2021-10-28T14:33:51.952Z","updated":"2021-10-28T15:19:42.538Z","comments":true,"path":"2021/10/28/DS_Algorithm证明与讲解/数论/狄利克雷卷积/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/28/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/","excerpt":"","text":"链接：铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演，算法学习笔记(35): 狄利克雷卷积，狄利克雷卷积和莫比乌斯反演","categories":[],"tags":[]},{"title":"第七章 乘性函数","slug":"读书笔记/数学/初等数论及其应用/第七章 乘性函数","date":"2021-10-25T16:00:00.000Z","updated":"2021-11-02T14:42:42.627Z","comments":true,"path":"2021/10/26/读书笔记/数学/初等数论及其应用/第七章 乘性函数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E4%B9%98%E6%80%A7%E5%87%BD%E6%95%B0/","excerpt":"","text":"导言 在本章中，我们研究定义在整数集合上的一类称为 乘性函数（或积性函数）的特殊函数。 乘性函数具有这样的性质，即它在一个整数上的函数值等于对该整数做素幂因子分解后所有素数幂上的函数值之积。 我们将证明一些重要的函数是乘性的，包括 因子个数函数、因子和函数 以及 欧拉 φ\\varphiφ 函数。利用这些函数是乘性函数的性质，基于正整数 nnn 的素幂因子分解，我们得到这些函数在 nnn 处的函数值的公式. 进一步，我们将研究一类称为 完全数 的特殊正整数，这类数与其 真因子 之和相等。我 们将证明所有偶完全数由一类称为梅森素数的特殊素数生成，梅森素数是那些形如 2p−12^p-12p−1（ppp 是素数）的素数。人们很早就开始寻找新的梅森素数，而具有很强计算能力的计算机和因特 网的出现加速了这类素数的寻找. 我们还将证明如何用 算术函数（即对所有正整数定义的函数）的 和函数 来得到函数自身的一些信息。函数 fff 的和函数在 nnn 处的函数值等于 fff 在 nnn 的所有正因子处的函数值之和。著名的 莫比乌斯反演公式 证明了如何从和函数的取值得到 fff 的函数取值. 最后，我们将研究关于 无限制拆分 和 受限制拆分 的算术函数。 所谓 拆分 是指将一个正整数表示为若干个正整数的和，不计其中的次序。 受限制拆分则是指拆分项受到一定的约束。 我们将给出一系列令人惊讶的关于这些算术函数之间的等式，并且引入诸多在研究拆分时很重要的概念。 7.1 欧拉函数 在本节中将证明欧拉函数是乘性函数。我们可以通过整数的素幂因子分解来给出乘性函数在该整数上的函数值的计算公式。 定义：定义在所有正整数上的函数称为算术函数。 在本章中，我们关心的是具有某些特殊性质的算术函数。 定义：如果算术函数 fff 对任意两个互素的正整数 n, mn,\\ mn, m ，均有 f(mn)=f(m)f(n)f(mn)=f(m)f(n)f(mn)=f(m)f(n) ，就称为 乘性函数（或积性函数）。如果对任意两个正整数 n, mn,\\ mn, m ，均有 f(mn)=f(m)f(n)f(mn)=f(m)f(n)f(mn)=f(m)f(n) ，就称为 完全乘性（或完全积性）函数。 定理 7.1 乘性函数的计算 如果 fff 是一个乘性函数，那么对于给定的 nnn 的素幂因子分解，能够得到 f(n)f(n)f(n) 的一个简单计算公式。这是一个很有用的结果，它告诉我们在已知 nnn 的素幂因子分解 n=p1a1p2a2⋯psasn=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n=p1a1​​p2a2​​⋯psas​​ 的情况下如何从 f(piai) (i=1,2,⋯ ,s)f(p_i^{a_i})\\ (i=1,2,\\cdots,s)f(piai​​) (i=1,2,⋯,s) 中得到 f(n)f(n)f(n) 的值。 定理 7.1：如果 fff 是一个乘性函数，且对任意正整数 nnn 有素幂因子分解 n=p1a1p2a2⋯psasn=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n=p1a1​​p2a2​​⋯psas​​ ，那么 f(n)=f(p1a1)f(p2a2)⋯f(psas)f(n)=f(p_1^{a_1})f(p_2^{a_2})\\cdots f(p_s^{a_s})f(n)=f(p1a1​​)f(p2a2​​)⋯f(psas​​) 。 证明： 现在回到欧拉函数，首先考虑它在素数与素数幂处的值。分别在定理 7.2、7.3中说明。 定理 7.2 欧拉函数在素数处的值 定理 7.2：如果 ppp 是素数，那么 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 。反之，如果 ppp 是正整数且满足 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 ，那么 ppp 是素数。 证明：如果 ppp 是素数，那么任意小于 ppp 的正整数都是与 ppp 互素的。因为有 p−1p-1p−1 个这样的整数，所以 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 。反之，若 ppp 是正整数且满足 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 ，说明 p≠1p\\ne 1p=1 且 ppp 除了 1 和它本身没有别的因数，所以 ppp 为素数。 证明：如果 ppp 是素数，那么任意小于 ppp 的正整数都是与 ppp 互素的。因为有 p−1p-1p−1 个这样的整数，所以 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 。反之，如果 ppp 不是素数，那么 p=1p=1p=1 或 ppp 是合数。如果 p=1p=1p=1 ，那么 φ(p)≠p−1\\varphi(p)\\ne p-1φ(p)=p−1 ，因为 φ(1)=1\\varphi(1)=1φ(1)=1 。如果 ppp 是合数，那么 ppp 有一个因子 ddd 满足 1&lt;d&lt;p1&lt;d&lt;p1&lt;d&lt;p ，显然 ddd 和 ppp 不互素。由于 p−1p-1p−1 个整数 1,2,⋯ ,p−11,2,\\cdots,p-11,2,⋯,p−1 中至少有一个整数（即 ddd ）是不和 ppp 互素的，故 φ(p)⩽p−2\\varphi(p)\\leqslant p-2φ(p)⩽p−2 。因此，如果 φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 ，那么 ppp 必是素数。 定理 7.3 欧拉函数在素数幂处的值 定理 7.3：设 ppp 是素数， aaa 是一个正整数，那么 φ(pa)=pa−pa−1\\varphi(p^a)=p^a-p^{a-1}φ(pa)=pa−pa−1 。 证明：不超过 pap^apa 且和 pap^apa 不互素的正整数就是那些不超过 pap^apa 且能够被 ppp 整除的整数，即 kpkpkp ，其中 1⩽k⩽pa−11\\leqslant k\\leqslant p^{a-1}1⩽k⩽pa−1 ，因为恰有 pa−1p^{a-1}pa−1 个这样的整数，所以存在 pa−pa−1p^a-p^{a-1}pa−pa−1 个不超过 pap^apa 且和 pap^apa 互素的正整数。所以 φ(pa)=pa−pa−1\\varphi(p^a)=p^a-p^{a-1}φ(pa)=pa−pa−1 。 定理 7.4 欧拉函数是乘性函数 给定 nnn 的素幂因子分解，为了给出 φ(n)\\varphi(n)φ(n) 的公式，需要证明 φ\\varphiφ 是乘性函数。 定理 7.5 欧拉函数的计算 由定理 7.3，7.4，我们得到下面关于 φ(n)\\varphi(n)φ(n) 的公式。 定理 7.5：设 n=p1a1p2a2⋯pkakn=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}n=p1a1​​p2a2​​⋯pkak​​ 为正整数 nnn 的素幂因子分解，那么 φ(n)=n(1−1p1)(1−1p2)⋯(1−1pk)\\varphi(n)=n(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots (1-\\dfrac{1}{p_k})φ(n)=n(1−p1​1​)(1−p2​1​)⋯(1−pk​1​) 。 证明：因为 φ\\varphiφ 是乘性函数，故由定理 7.1 可知 φ(n)=φ(p2a2)φ(pkak)⋯φ(p1a1)\\varphi(n)=\\varphi(p_2^{a_2})\\varphi(p_k^{a_k})\\cdots \\varphi(p_1^{a_1})φ(n)=φ(p2a2​​)φ(pkak​​)⋯φ(p1a1​​) 。 另外由定理 7.3，我们知道当 j=1,2,⋯ ,kj=1,2,\\cdots,kj=1,2,⋯,k 时，有 φ(pjaj)=pjaj−pjaj−1=pjaj(1−1pj)\\varphi(p_j^{a_j})=p_j^{a_j}-p_{j}^{a_{j-1}}=p_j^{a_j}(1-\\dfrac{1}{p_j})φ(pjaj​​)=pjaj​​−pjaj−1​​=pjaj​​(1−pj​1​) 。 因此 φ(n)=p1a1(1−1p1)p2a2(1−1p2)⋯pkak(1−1pk)=p1a1p2a2⋯pkak(1−1p1)(1−1p2)⋯(1−1pk)=n(1−1p1)(1−1p2)⋯(1−1pk)\\begin{align*} \\varphi(n)&amp;=p_1^{a_1}(1-\\dfrac{1}{p_1})p_2^{a_2}(1-\\dfrac{1}{p_2})\\cdots p_k^{a_k}(1-\\dfrac{1}{p_k})\\\\ &amp;=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots(1-\\dfrac{1}{p_k})\\\\ &amp;=n(1-\\dfrac{1}{p_1})(1-\\dfrac{1}{p_2})\\cdots(1-\\dfrac{1}{p_k}) \\end{align*} φ(n)​=p1a1​​(1−p1​1​)p2a2​​(1−p2​1​)⋯pkak​​(1−pk​1​)=p1a1​​p2a2​​⋯pkak​​(1−p1​1​)(1−p2​1​)⋯(1−pk​1​)=n(1−p1​1​)(1−p2​1​)⋯(1−pk​1​)​ 定理 7.6 欧拉函数值的奇偶 定理 7.6：设 nnn 是一个大于 2 的正整数，那么 φ(n)\\varphi(n)φ(n) 是偶数。 证明：设 nnn 的素幂因子分解为 n=p1a1p2a2⋯psasn=p_1^{a_1}p_2^{a_2}\\cdots p_s^{a_s}n=p1a1​​p2a2​​⋯psas​​ 。因为 φ\\varphiφ 是乘性函数，所以 φ(n)=∏j=1sφ(pjaj)\\varphi(n)=\\displaystyle \\prod_{j=1}^{s}\\varphi(p_j^{a_j})φ(n)=j=1∏s​φ(pjaj​​) 。由定理 7.3，我们知道 φ(pjaj)=pjaj−1(pj−1)\\varphi(p_j^{a_j})=p_j^{a_j-1}(p_j-1)φ(pjaj​​)=pjaj​−1​(pj​−1) 。可以看到当 pjp_jpj​ 是奇素数时， φ(pjaj)\\varphi(p_j^{a_j})φ(pjaj​​) 是偶数，这是因为当 pjp_jpj​ 是奇数时， pj−1p_j-1pj​−1 是偶数；当 pj=2p_j=2pj​=2 且 aj&gt;1a_j&gt;1aj​&gt;1 时， pjaj−1p_j^{a_j-1}pjaj​−1​ 是偶数。给定 n&gt;2n&gt;2n&gt;2 ， pjp_jpj​ 是奇数或者 pj=2p_j=2pj​=2 且 aj&gt;1a_j&gt;1aj​&gt;1 这两个条件中至少满足一个，所以 φ(pjaj)\\varphi(p_j^{a_j})φ(pjaj​​) 在 1⩽j⩽s1\\leqslant j\\leqslant s1⩽j⩽s 时至少有一个是偶数，因此 φ(n)\\varphi(n)φ(n) 是偶数。 和函数 设 fff 是一个算术函数，那么 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) 代表 fff 在 nnn 的所有正因子处的值之和。函数 FFF 称为 fff 的 和函数。 下面证明欧拉函数在 nnn 的所有正因子处的值之和为 nnn ，这个结果在后面也是有用的。这表明欧拉函数的和函数是个 恒等函数，即在 nnn 处的值恰是 nnn 。 定理 7.7 欧拉函数的和函数 定理 7.7：设 nnn 为正整数，那么 ∑d∣nφ(d)=n\\sum_{d\\mid n}\\varphi(d)=n∑d∣n​φ(d)=n 。 证明：我们将从 111 到 nnn 的整数构成的集合进行分类。整数 mmm 如果与 nnn 的最大公因子为 ddd ，则 mmm 属于 CdC_dCd​ 类。也就是说，如果 mmm 属于 CdC_dCd​ ，那么 (m/d, n/d)=1(m/d,\\ n/d)=1(m/d, n/d)=1 。所以 CdC_dCd​ 中所含的整数的个数是所有不超过 n/dn/dn/d 且和 n/dn/dn/d 互素的正整数的个数，即 CdC_dCd​ 中存在 φ(n/d)\\varphi(n/d)φ(n/d) 个正整数。所以我们可以把这 nnn 个数分为互不相交的类。因此 n=∑d∣nφ(n/d)n=\\sum_{d\\mid n}\\varphi(n/d)n=∑d∣n​φ(n/d) 。 因为 ddd 取遍所有整除 nnn 的正整数， n/dn/dn/d 也取遍 nnn 的所有正因子，所以 n=∑d∣nφ(n/d)=∑d∣nφ(d)n=\\sum_{d\\mid n}\\varphi(n/d)=\\sum_{d\\mid n}\\varphi(d)n=∑d∣n​φ(n/d)=∑d∣n​φ(d) 。 欧拉函数的一些性质 性质 1：∀n, n&gt;1\\forall n,\\ n&gt;1∀n, n&gt;1 ，1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 中与 nnn 互质的数的和为 n×φ(n)2n\\times \\dfrac{\\varphi(n)}{2}n×2φ(n)​ 。 性质 2：设 ppp 是 nnn 的因数（无论是质数或素数），若 p∣np\\mid np∣n 且 p2∣np^2\\mid np2∣n ，则 φ(n)=φ(n/p)×p\\varphi(n)=\\varphi(n/p)\\times pφ(n)=φ(n/p)×p 。（因为 p, n/pp,\\ n/pp, n/p 不互质且 nnn 和 n/pn/pn/p 的质因子集合相同） 性质 3：设 ppp 是 nnn 的质因数，若 p∣p\\midp∣ 且 p2∤np^2\\nmid np2∤n ，则 φ(n)=φ(n/p)×φ(p)\\varphi(n)=\\varphi(n/p)\\times \\varphi(p)φ(n)=φ(n/p)×φ(p) 。（因为 p, n/pp,\\ n/pp, n/p 互质，若 ppp 为合数，则 p, n/pp,\\ n/pp, n/p 是否互质不确定） 性质 4：若 i, ji,\\ ji, j 不互质，则 φ(i×j)=φ(i)φ(j)gcd⁡(i, j)φ(gcd⁡(i, j))\\varphi(i\\times j)=\\dfrac{\\varphi(i)\\varphi(j)\\gcd(i,\\ j)}{\\varphi(\\gcd(i,\\ j))}φ(i×j)=φ(gcd(i, j))φ(i)φ(j)gcd(i, j)​ 。 一个关于欧拉函数的方程 设 kkk 是一个给定的正整数，求满足 φ(n)=k\\varphi(n)=kφ(n)=k 的所有正整数 nnn 的解的一个有用的方法就是给出满足方程 φ(n)=∏i=1kpiai−1(pi−1)\\varphi(n)=\\displaystyle\\prod_{i=1}^{k}p^{a_i-1}_{i}(p_i-1)φ(n)=i=1∏k​piai​−1​(pi​−1) 的所有整数解 nnn ，其中 nnn 的素幂因子分解为 n=∏i=1kpiain=\\displaystyle\\prod_{i=1}^{k}p_i^{a_i}n=i=1∏k​piai​​ 。 狄利克雷卷积 定义：两个算术函数 f, gf,\\ gf, g 可以用狄利克雷卷积，定义为 (f∗g)(n)=∑d∣nf(d)g(n/d)(f*g)(n)=\\sum_{d\\mid n}f(d)g(n/d)(f∗g)(n)=∑d∣n​f(d)g(n/d) 。或 (f∗g)(n)=∑ab=nf(a)g(b)(f*g)(n)=\\sum_{ab=n}f(a)g(b)(f∗g)(n)=∑ab=n​f(a)g(b) 。 证明：f∗g=g∗ff*g=g*ff∗g=g∗f 。 证明：(f∗g)∗h=f∗(g∗h)(f*g)*h=f*(g*h)(f∗g)∗h=f∗(g∗h) 。 我们定义 ε\\varepsilonε 函数 ε={1if n=10if n&gt;1\\varepsilon = \\begin{cases} 1 &amp;\\text{if }\\ n=1 \\\\ 0 &amp;\\text{if }\\ n&gt;1 \\end{cases} ε={10​if n=1if n&gt;1​ 证明： ε\\varepsilonε 是乘性函数。 证明：对任意算术函数 fff 有 ε∗f=f∗ε=f\\varepsilon * f=f*\\varepsilon=fε∗f=f∗ε=f 。 算术函数 ggg 称为算术函数 fff 的逆函数，如果满足 f∗g=g∗f=εf*g=g*f=\\varepsilonf∗g=g∗f=ε 。证明算术函数 fff 可逆当且仅当 f(1)≠0f(1)\\ne 0f(1)=0 。证明：如果 fff 可逆，则逆函数是唯一的。 证明：如果 f, gf,\\ gf, g 是乘性函数，那么狄利克雷积 f∗gf*gf∗g 也是乘性函数。 7.2 因子和 与 因子个数 定义：因子和函数 σ\\sigmaσ 定义为整数 nnn 的所有正因子之和，记为 σ(n)\\sigma(n)σ(n) 。 定义：因子个数函数 τ\\tauτ 定义为正整数 nnn 的所有正因子个数，记为 τ(n)\\tau(n)τ(n) 。 用和式表示即为 σ(n)=∑d∣nd\\sigma(n)=\\displaystyle \\sum_{d\\mid n}dσ(n)=d∣n∑​d ， τ(n)=∑d∣n1\\tau(n)=\\displaystyle \\sum_{d\\mid n}1τ(n)=d∣n∑​1 。 定理 7.8 和函数也是积性函数 定理 7.8：如果 fff 是乘性函数，那么 fff 的和函数，即 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) 也是乘性函数。 证明：为了证明 FFF 是一个乘性函数，我们必须证明如果 m, nm,\\ nm, n 是互素的正整数，那么 F(mn)=F(m)F(n)F(mn)=F(m)F(n)F(mn)=F(m)F(n) 。所以首先假设 (m, n)=1(m,\\ n)=1(m, n)=1 ，有 F(mn)=∑d∣mnf(d)F(mn)=\\sum_{d\\mid mn}f(d)F(mn)=∑d∣mn​f(d) 。 由引理 3.7，因为 (m, n)=1(m,\\ n)=1(m, n)=1 ，故每个 mnmnmn 的因子可以唯一地写成 mmm 的因子 d1d_1d1​ 和 nnn 的因子 d2d_2d2​ 之积，并且这两个因子互素，即 d=d1d2d=d_1d_2d=d1​d2​ ，所以有 F(mn)=∑d1∣m, d2∣nf(d1d2)F(mn)=\\sum_{d_1\\mid m,\\ d_2\\mid n}f(d_1d_2)F(mn)=∑d1​∣m, d2​∣n​f(d1​d2​) 。 因为 fff 是乘性的，且 (d1, d2)=1(d_1,\\ d_2)=1(d1​, d2​)=1 ，故（mnmnmn 的因子个数 = mmm 的因子个数 ×\\times× nnn 的因子个数） F(mn)=∑d1∣m,d2∣nf(d1)f(d2)=∑d1∣mf(d1)∑d2∣nf(d2)=F(m)F(n)\\begin{align*} F(mn)&amp;=\\sum_{d_1\\mid m,\\\\ d_2\\mid n}f(d_1)f(d_2)\\\\ &amp;=\\sum_{d_1\\mid m}f(d_1)\\sum_{d_2\\mid n}f(d_2)\\\\ &amp;=F(m)F(n) \\end{align*} F(mn)​=d1​∣m,d2​∣n∑​f(d1​)f(d2​)=d1​∣m∑​f(d1​)d2​∣n∑​f(d2​)=F(m)F(n)​ 引理 7.1 当 n 为一个素数的幂时 定理 7.9 因子和、因子个数函数的计算 7.3 完全数和梅森素数 7.4 莫比乌斯反演 定义：莫比乌斯函数 μ(n)\\mu(n)μ(n) 定义为 μ(n)={1如果 n=1(−1)r如果 n=p1p2⋯pr,其中 pi为不同的素数0其他情况 \\mu(n) = \\begin{cases} 1 &amp;\\text{如果 }\\ \\ n=1 \\\\ (-1)^r &amp;\\text{如果 }\\ \\ n=p_1p_2\\cdots p_r,\\text{其中}\\ p_i \\text{为不同的素数}\\\\ 0 &amp;\\text{其他情况 }\\\\ \\end{cases} μ(n)=⎩⎨⎧​1(−1)r0​如果 n=1如果 n=p1​p2​⋯pr​,其中 pi​为不同的素数其他情况 ​ 定理 7.14 莫比乌斯函数是乘性函数 定理 7.15 莫比乌斯函数的和函数 定理 7.15：莫比乌斯函数的和函数在整数 nnn 处的值 F(n)=∑d∣nμ(d)F(n)=\\sum_{d\\mid n}\\mu(d)F(n)=∑d∣n​μ(d) ，满足 ∑d∣nμ(d)={1如果 n=10如果 n&gt;1\\sum_{d\\mid n}\\mu(d) = \\begin{cases} 1 &amp;\\text{如果 }\\ \\ n=1 \\\\ 0 &amp;\\text{如果 }\\ \\ n&gt;1\\\\ \\end{cases} d∣n∑​μ(d)={10​如果 n=1如果 n&gt;1​ 证明：当 n=1n=1n=1 时，显然。 当 n&gt;1n&gt;1n&gt;1 ， 定理 7.16 莫比乌斯反演公式 定理 7.16：若 fff 是算术函数，FFF 为 fff 的和函数，即对任意正整数 nnn 满足 F(n)=∑d∣nf(d)F(n)=\\sum_{d\\mid n}f(d)F(n)=∑d∣n​f(d) ，则对任意正整数 nnn ， f(n)=∑d∣nμ(d)F(n/d)f(n)=\\sum_{d\\mid n}\\mu(d)F(n/d)f(n)=∑d∣n​μ(d)F(n/d) 。 证明： 莫比乌斯反演公式可以用来构造许多新的等式，这些等式用别的方法是很难证明的。 定理 7.17 定理 7.17：设 fff 是算术函数，它的和函数为 F(n)=∑d∣nf(n)F(n)=\\sum_{d\\mid n}f(n)F(n)=∑d∣n​f(n) 。那么如果 FFF 是乘性函数，则 fff 也是乘性函数。 证明： 7.5 拆分","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/约数","date":"2021-10-24T15:36:00.629Z","updated":"2021-10-25T03:45:31.382Z","comments":true,"path":"2021/10/24/DS_Algorithm证明与讲解/数论/约数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/24/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E7%BA%A6%E6%95%B0/","excerpt":"","text":"求所有约数 先分解质因式（一个数最多有一个大于根号 nnn 的质因子，因此分解复杂度为 x/ln_x / 2） #include&lt;bits/stdc++.h&gt;using namespace std;const int N = 50010;int primes[N], cnt;bool st[N];struct Factor&#123; int p, s;&#125;factor[10];int fcnt;int dividor[1601], dcnt;void init(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] * i &lt;= n; j ++ ) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;void dfs(int u, int p)&#123; // 根据素幂因子分解q if (u == fcnt) &#123; dividor[dcnt ++ ] = p; return; &#125; for (int i = 0; i &lt;= factor[u].s; i ++ ) &#123; dfs(u + 1, p); p *= factor[u].p; &#125;&#125;void div()&#123; for (int i = 0; primes[i] * primes[i] &lt;= t; i ++ ) &#123; int p = primes[i]; if (t % p == 0) &#123; int s = 0; while (t % p == 0) t /= p, s ++ ; factor[fcnt ++ ] = &#123;p, s&#125;; &#125; &#125; if (t &gt; 1) factor[fcnt ++ ] = &#123;t, 1&#125;; dcnt = 0; dfs(0, 1);&#125;","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/题单","date":"2021-10-23T04:34:01.892Z","updated":"2021-10-23T04:35:33.048Z","comments":true,"path":"2021/10/23/DS_Algorithm证明与讲解/数论/题单/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/23/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E9%A2%98%E5%8D%95/","excerpt":"","text":"一些好玩的数学题 一些好玩的数论题 Part 1 一些好玩的数论题 Part 2","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/线性代数/高斯消元","date":"2021-10-23T04:28:47.823Z","updated":"2021-10-23T04:29:46.487Z","comments":true,"path":"2021/10/23/DS_Algorithm证明与讲解/线性代数/高斯消元/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/23/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"题目 洛谷题单：【线性代数】线性代数基础题","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/数学期望","date":"2021-10-23T04:24:02.202Z","updated":"2021-10-23T04:24:37.671Z","comments":true,"path":"2021/10/23/DS_Algorithm证明与讲解/数论/数学期望/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/23/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/","excerpt":"","text":"题目 洛谷题单：【日报配套题单】数论小白都能看懂的数学期望讲解","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/组合数学/生成函数","date":"2021-10-23T04:22:31.501Z","updated":"2021-10-23T04:30:37.079Z","comments":true,"path":"2021/10/23/DS_Algorithm证明与讲解/组合数学/生成函数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/23/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/","excerpt":"","text":"题目 洛谷题单：生成函数之 OGF &amp; EGF - 从入门到入土 洛谷题单：【数学】生成函数基础","categories":[],"tags":[]},{"title":"P1516 青蛙的约会","slug":"题解/数论/欧几里得算法/青蛙的约会","date":"2021-10-21T16:00:00.000Z","updated":"2021-10-22T01:32:32.104Z","comments":true,"path":"2021/10/22/题解/数论/欧几里得算法/青蛙的约会/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/22/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/","excerpt":"","text":"原题链接：P1516 青蛙的约会 步骤 由 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 得到 ax−my=bax-my=bax−my=b 。最终得到 ad(x−x0)=md(y−y0)\\dfrac{a}{d}(x-x_0)=\\dfrac{m}{d}(y-y_0)da​(x−x0​)=dm​(y−y0​) 。 求 gcd(a, m) 时，a,ma, ma,m 的正负影响 gcd 的正负，但 gcd 的正负不影响 有无整数解的判断。 再得 x=x0+mdnx=x_0+\\dfrac{m}{d}nx=x0​+dm​n ， y=y0+adny=y_0+\\dfrac{a}{d}ny=y0​+da​n 。 遇到的问题 Q：为什么 exgcd((m - n), -L, x, y); 和 exgcd((m - n), L, x, y); 都能 AC？ A：经测试，①m-n 取正，L 为正或负，②m-n 取负，L 为正或负，得到的最大公因子符号相反，x 的符号也相反。所以 x *= (b - a) / d; 这一步得到的 xxx 的值相同。即两种写法均可得到 ax−my=bax-my=bax−my=b 的一个正确特解。且 gcd, x 的正负对后续步骤无影响。 Q：为什么必须使 md\\dfrac{m}{d}dm​ 为正？ A ：若 md\\dfrac{m}{d}dm​ 为负，则 (x0 % md+md) % md(x_0\\ \\%\\ \\dfrac{m}{d}+\\dfrac{m}{d})\\ \\%\\ \\dfrac{m}{d}(x0​ % dm​+dm​) % dm​ 可能得到负数结果。稍作改动： x=x0+(−md)(−n)x=x_0+(-\\dfrac{m}{d})(-n)x=x0​+(−dm​)(−n) ，则 (x0 % md+md) % md(x_0\\ \\%\\ \\dfrac{m}{d}+\\dfrac{m}{d})\\ \\%\\ \\dfrac{m}{d}(x0​ % dm​+dm​) % dm​ 必得到最小非负解。 代码 #include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int a, b, m, n, L, x, y;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) return x = 1, y = 0, a; int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d;&#125;signed main() &#123; // a, b:青蛙A B的起始位置; m, n:青蛙A B一次跳的距离; L:圆的周长 scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;a, &amp;b, &amp;m, &amp;n, &amp;L); int d = exgcd((m - n), -L, x, y); if ((b - a) % d) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; &#125; else &#123; x *= (b - a) / d; int t = abs(L / d); cout &lt;&lt; (x % t + t) % t &lt;&lt; endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Hankson 的趣味题","slug":"题解/数论/欧几里得算法/Hankson 的趣味题","date":"2021-10-21T16:00:00.000Z","updated":"2021-10-26T08:21:51.044Z","comments":true,"path":"2021/10/22/题解/数论/欧几里得算法/Hankson 的趣味题/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/22/%E9%A2%98%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/Hankson%20%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/","excerpt":"","text":"题目链接：[NOIP2009 提高组] Hankson 的趣味题 思路 暴力 首先，我们知道这两个等式：(a0,x)=a1,[b0,x]=b1(a0,x)=a1,[b0,x]=b1 于是，我们可以设：x=a1p,b1=xtx=a1∗p,b1=x∗t 于是有：a1pt=b1a1∗p∗t=b1 所以我们令：b1/a1=sb1/a1=s 则：pt=sp∗t*=s 即：t=s/pt=s/p 又由最大公约数与最小公倍数的定义与性质可得： (a0/a1,p)=1,(b1/b0,t)=1(a0/a1,p)=1,(b1/b0,t)=1 所以我们令：a0/a1=m,b1/b0=na0/a1=m,b1/b0=n 则有：(p,m)=1,(s/p,n)=1(p,m)=1,(s/p,n)=1 这就是第一个结论，我们称其为结论一。事实上，我们其实已经可以由结论一整理出可以AC的方法，即用sqrt(s)的复杂度枚举s的因数，然后将每个因数放到结论一中，看看是否成立，再统计所有符合结论一的因数的个数，然后输出即可。这种算法的复杂度是：O(sqrt(s)*log(s)*n)。这样其实也能卡过数据，但是还是没有达到理论上的通过。所以我们还要继续优化。 进一步优化 我们考虑(s/p,n)=1。如果s/p与n有相同质因数，则意思那个无法使(s/p,n)=1成立。于是，我们可以将s与n所有相同的质因数从s中去掉，得到剩余的数l（这一点还是很需要技巧的，在程序中会有解析）。于是，s/p就必须是l的约数。 我们继续考虑(p,m)=1。因为s/p是l的约数，那么p就一定可以表示为这样的形式： p=(s/l)rp*=(s/l)∗r 即：p一定是s/l的倍数（因为s/p是l的约数）。而r也必须是l的约数。于是就又有： r|l,(r,m)=1r∣l,(r,m)=1 这就是第二个结论，我们称其为结论二。而解决结论二的方法便很明显了。我们可以用与解决结论一相似的方法，将l与m所有相同的质因数从l中去掉，得到剩余的数q。那么这样，所有符合条件的r都是q的因数了。然后，我们可以用sqrt(q)的复杂度枚举q的所有因数，输出q的因数个数就行了。这样，复杂度便降到了：O((sqrt(s)+log(s))*n)，从理论来说也不会超时了。 还有一点需要注意，那就是特判没有符合要求的x的情况。这种情况出现只有四种可能： ###1、s不为整数 ###2、m不为整数 ###3、n不为整数 ###4、(s/l,m)≠1，即因为p是s/l的倍数，所以无论r取何值，都会有(p,m)≠1 加上这四个特判，这道题便做完了。 暴力代码 // 337ms https://www.luogu.com.cn/record/60566847#include &lt;bits/stdc++.h&gt;using namespace std;// #define int long long // 若开long long(917ms)：https://www.luogu.com.cn/record/60517389const int N = 1e6 + 233;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125;int a[N];signed main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) // 2000 &#123; int a0, a1, b0, b1; scanf(&quot;%d %d %d %d&quot;, &amp;a0, &amp;a1, &amp;b0, &amp;b1); if (b1 % a1) printf(&quot;0\\n&quot;); else &#123; int cnt = 0, ans = 0, x = b1 / a1; for (int i = 1; i * i &lt;= x; i++) // 写成除法(579ms)：https://www.luogu.com.cn/record/60566591 &#123; // 求约数 if (x % i == 0) &#123; a[++cnt] = i; if (x != i * i) a[++cnt] = x / i; &#125; &#125; // printf(&quot;cnt = %d\\n&quot;, cnt); for (int i = 1; i &lt;= cnt; i++) &#123; x = a[i] * a1; if (gcd(x, a0) == a1 &amp;&amp; x / gcd(x, b0) * b0 == b1) ans++; &#125; printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; 优化代码 // 179ms https://www.luogu.com.cn/record/60530753#include &lt;bits/stdc++.h&gt;using namespace std;int a0, a1, b0, b1;int m, s, l;int T;int Div(int a, int b)&#123; //去掉a中与b共有的质因数 int x = sqrt(b); for (int i = 2; i &lt;= x; i++) &#123; if (b % i == 0) while (a % i == 0) a /= i; while (b % i == 0) b /= i; &#125; if (b &gt; 1) while (a % b == 0) a /= b; return a;&#125;int gcd(int a, int b) &#123; return b ? gcd(b, a % b): a; &#125;signed main()&#123; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d %d %d %d&quot;, &amp;a0, &amp;a1, &amp;b0, &amp;b1); if (b1 % a1) &#123; printf(&quot;0\\n&quot;); continue; &#125; m = a0 / a1, s = b1 / a1; l = Div(s, b1 / b0); //求出m、s，然后求出l if (gcd(max(s / l, m), min(s / l, m)) != 1) &#123; printf(&quot;0\\n&quot;); continue; &#125; int q = Div(l, m); int cnt = 0, t = sqrt(q); //求出q，开始枚举q的因数，求出q的因数个数 for (int i = 1; i &lt;= t; i++) if (q % i == 0) cnt += (i == q / i) ? 1 : 2; //这里注意，如果i==q/i，则只加1，否则加2 printf(&quot;%d\\n&quot;, cnt); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/同余理论","date":"2021-10-21T08:55:02.720Z","updated":"2021-10-23T04:28:08.167Z","comments":true,"path":"2021/10/21/DS_Algorithm证明与讲解/数论/同余理论/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/21/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99%E7%90%86%E8%AE%BA/","excerpt":"","text":"洛谷题单：数学·同余方程 HDU 5776：同余，鸽笼原理","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/分解质因数","date":"2021-10-21T08:52:25.671Z","updated":"2021-10-25T03:44:21.892Z","comments":true,"path":"2021/10/21/DS_Algorithm证明与讲解/数论/分解质因数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/21/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/","excerpt":"","text":"分解质因数 直接试除法 任意合数 xxx 最多有一个大于 x\\sqrt{x}x​ 的质因子。 void div(int x)&#123; for(int i = 2; i &lt;= x / i; i++)&#123; if(x % i == 0)&#123; int cnt = 0; while(x % i == 0) x /= i, cnt++; printf(&quot;%d %d\\n&quot;, i, cnt); &#125; if(i * i &gt; x) &#125; if(x != 1) printf(&quot;%d 1&quot;, x);&#125; 使用质数试除 若一个数是大质数或是两个大质数的乘积，此时会达到 O(n)O(\\sqrt{n})O(n​) 的复杂度，则使用质数试除会更快。 所以如果题目中要对多个数进行质因子分解，可先 O(n)O(n)O(n) 预处理，得到 n\\sqrt{n}n​ 内的质数。再进行质因子分解，会快 nln⁡(n)\\dfrac{\\sqrt{n}}{\\ln({\\sqrt{n}})}ln(n​)n​​ 倍（7~10倍）。 int primes[N], cnt;PII factor[N], fnct;void get_primes(int n) // 预处理 根号n 内的素数&#123; for(int i = 2; i &lt;= n; i++) &#123; if(!st[i]) primes[++cnt] = i; for(int j = 1; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if(i % primes[i] == 0) break; &#125; &#125;&#125;void Div(int n) // 分解 n&#123; for(int i = 1; primes[i] * primesp[i] &lt;= n; i++) &#123; // 一个数最多有 1个大于根号 n的质因子 if(n % i == 0) &#123; int s = 0; while(n % i == 0) n /= i, s++; factor[++fcnt] = &#123;i, s&#125;; &#125; &#125; if(n &gt; 1) factor[++fcnt] = &#123;n, 1&#125;;&#125; Pollard Rho 算法77 下面复杂度复杂度更低的 Pollard-Rho 算法是一种用于快速分解非平凡因数的算法（注意！非平凡因子不是素因子）。而在此之前需要先引入生日悖论。 题目 洛谷 P2043 质因子分解：n!n!n! 的质因子分解。①暴力法，②数论定理。","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/筛法","date":"2021-10-21T08:46:54.440Z","updated":"2021-10-21T08:51:41.341Z","comments":true,"path":"2021/10/21/DS_Algorithm证明与讲解/数论/筛法/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/21/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E7%AD%9B%E6%B3%95/","excerpt":"","text":"暴力筛 bool is_prime(int x)&#123; for(int i = 2; i &lt;= x / i; i++)&#123; if(x % i == 0) return false; &#125; return true;&#125;for(int i = 2; i &lt;= n; i++)&#123; if(is_prime(i)) primes[++cnt] = i;&#125; 埃氏筛 for(int i = 2; i &lt;= n; i++)&#123; if(is_prime[i]) continue; primes[++cnt] = i; for(int j = i * i; j &lt;= n; j += i)&#123; is_prime[j] = true; &#125;&#125; 欧拉筛 也称线性筛，O(n)O(n)O(n) 的复杂度筛出 1~n 的所有素数。1e8内共 576_1455个素数。 在1e6时与埃氏筛差不多，在1e7时快一倍。 基本思想 每个合数被其最小质因子筛掉。 线性复杂度证明 每个合数都会被筛掉； 设合数 xxx 的最小质因子为 ppp ，当 iii 遍历到 x/px/px/p 时， xxx 被筛掉。 每个合数只会被筛掉一次； 任意合数 xxx 可被唯一地表示为 x=p×ix=p\\times ix=p×i ，ppp 是 xxx 的最小质因子，iii 是循环变量。 如何判断当前质数是被筛掉数的最小质因子 for j=1 to n 当 i mod p[j]=0i\\bmod p[j] = 0imodp[j]=0 ，p[j]p[j]p[j] 是 p[j]∗ip[j] * ip[j]∗i 的最小质因子。 代码实现 int primes[N], cnt;bool st[N];for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[++cnt] = i; for(int j = 1; primes[j] &lt;= n / i; j++)&#123; // 为了防止溢出,写成这种形式: primes[j] &lt;= n/i /*不需要添加条件 j &lt;= cnt; primes[j] &lt;= i 1.若 i为合数,则 primes[]中，一定包含了其最小质因数,会在 if处结束。 2.若 i为质数，则 i已经加入primes[]中,会在 if处结束。 */ st[primes[j] * i] = true; if(i % primes[j] == 0) break; &#125;&#125; 题目 AcWing 868. 筛质数：欧拉筛板题。 洛谷 P1835 素数密度：区间筛。","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/贝祖定理","date":"2021-10-17T09:16:57.128Z","updated":"2021-10-25T01:53:14.570Z","comments":true,"path":"2021/10/17/DS_Algorithm证明与讲解/数论/贝祖定理/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/17/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/","excerpt":"","text":"贝祖定理 题目 P3951 [NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目 一篇题解","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/Lucas","date":"2021-10-16T15:11:05.902Z","updated":"2021-10-16T15:11:05.902Z","comments":true,"path":"2021/10/16/DS_Algorithm证明与讲解/数论/Lucas/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/Lucas/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/Meissel-Lehmer","date":"2021-10-16T02:12:46.396Z","updated":"2021-10-16T02:14:53.788Z","comments":true,"path":"2021/10/16/DS_Algorithm证明与讲解/数论/Meissel-Lehmer/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/Meissel-Lehmer/","excerpt":"","text":"「Meissel-Lehmer 算法」是一种能在亚线性时间复杂度内求出 1∽n1\\backsim n1∽n 内质数个数的一种算法。","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/原根","date":"2021-10-16T01:06:16.769Z","updated":"2021-10-16T01:06:16.769Z","comments":true,"path":"2021/10/16/DS_Algorithm证明与讲解/数论/原根/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E5%8E%9F%E6%A0%B9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数论/BSGS","date":"2021-10-16T01:01:38.569Z","updated":"2021-10-23T04:17:44.545Z","comments":true,"path":"2021/10/16/DS_Algorithm证明与讲解/数论/BSGS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/BSGS/","excerpt":"","text":"关于高次同余方程，一般有 ax≡b( mod m)a^x\\equiv b(\\bmod m)ax≡b(modm) 和 xa≡b( mod m)x^a\\equiv b(\\bmod m)xa≡b(modm) 两种，这里只讨论第一种高次同余方程，第二种高次同余方程需要利用原根，阶，指标等概念。 BSGS算法 我们这里使用BSGS（Baby Step,Giant Step）算法求解第一类高次同余方程。 题目 洛谷题单：BSGS题单","categories":[],"tags":[]},{"title":"第五章 同余的应用","slug":"读书笔记/数学/初等数论及其应用/第五章 同余的应用","date":"2021-10-15T16:00:00.000Z","updated":"2021-10-16T11:55:23.730Z","comments":true,"path":"2021/10/16/读书笔记/数学/初等数论及其应用/第五章 同余的应用/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%90%8C%E4%BD%99%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"概要 本章广泛涉及了同余的各种类型的有趣应用。 首先，我们将指出如何利用同余进行整除性检验。 然后会推导出一个可以确定历史上任何一天的星期数的同余式。 利用同余编排循环赛赛程。 我们也将讨论同余性质在计算机科学中的一些应用，比如：应用在散列函数上，确定数据存储位置的计算机存储地址。 最后，我们将给出如何利用同余构造校验位。 5.1 整除性检验 在小学大家都学过检验一个整数是否能被 3 整除，只需检验该整数各位数相加之和能否被 3 整除就可以了。这是一个整除性检验的例子，它应用了一个整数的各位数字去检验这个数是否能被一个特定的除数整除，而不是用这个可能的除数直接去除那个整数。在本节中，我们将基于这样的检验给出有关的理论。特别地，将利用同余给出基于 bbb 进制展开的整数的整除性检验，其中 bbb 是一个正整数。取 b=10b=10b=10 即得到著名的用来检验整数能否被 2，3，4，5，7，9，11 和 13 等整除的检验。可能你在很久以前就学过这些整除性检验， 在这里你会明白为什么要那样做。 被 2 的幂整除的检验 被 5 的幂整除的检验 被 3 和 9 整除的检验 被 11 整除的检验 被 7，11，13 整除的检验 基于 b 进制表示的整除性检验 5.2 万年历 5.3 循环赛赛程 5.4 散列函数 5.5 校验位","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"第六章 特殊的同余式","slug":"读书笔记/数学/初等数论及其应用/第六章 特殊的同余式","date":"2021-10-15T16:00:00.000Z","updated":"2021-10-27T01:09:14.219Z","comments":true,"path":"2021/10/16/读书笔记/数学/初等数论及其应用/第六章 特殊的同余式/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%89%B9%E6%AE%8A%E7%9A%84%E5%90%8C%E4%BD%99%E5%BC%8F/","excerpt":"","text":"概要 在本章中，我们将讨论三个在理论和应用中都很重要的同余式： 威尔逊定理（Wilson’s Theorem）证明了若 ppp 是素数，则 ppp 除 (p−1)!(p-1)!(p−1)! 的余数是 −1-1−1。 费马小定理（Fermat’s Little Theorem）给出了一个整数的 ppp 次幂模 ppp 的同余式。特别地，若 ppp 是素数，aaa 是一个整数， 那么 apa^pap 和 aaa 被 ppp 除有相同的余数。 欧拉定理则将费马小定理推广到模不是素数的情形。 这三个同余式有很广泛的应用。例如，我们将解释费马小定理作为基础理论在素性检验和因子分解方面的应用，还要讨论一类称作 伪素数 的合数，这类合数满足像素数在费马小定理中满足的同余式一样的式子。利用伪素数极其稀少的事实还可以导出一种检验法，它可以提供一个几乎不可抗拒的证据来证明一个整数是素数。 6.1 威尔逊定理与费马小定理 定理 6.1 威尔逊定理 定理 6.1（威尔逊定理）：若 ppp 是素数，则 (p−1)!≡−1( mod p)(p-1)!\\equiv -1(\\bmod p)(p−1)!≡−1(modp) 。 证明： 费马小定理 定理 6.3 费马小定理 定理 6.3：设 ppp 是一个素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，则 ap−1≡1( mod p)a^{p-1}\\equiv 1(\\bmod\\ p)ap−1≡1(mod p) 。 定理 6.4 定理 6.4：设 ppp 是一个素数且 aaa 是一个正整数，则 ap≡a( mod p)a^p\\equiv a(\\bmod\\ p)ap≡a(mod p) 。 定理 6.5 费马小定理求乘法逆元 定理 6.5：若 ppp 是素数， aaa 是一个正整数且 p∤ap\\nmid ap∤a ，那么 ap−2a^{p-2}ap−2 是 aaa 模 ppp 的逆。 证明：若 ，则由费马小定理知， a×ap−2=ap−1≡1( mod p)a\\times a^{p-2}=a^{p-1}\\equiv 1(\\bmod\\ p)a×ap−2=ap−1≡1(mod p) 。因此， ap−2a^{p-2}ap−2 是 aaa 模 ppp 的逆。 6.2 伪素数 6.3 欧拉定理 定义：设 nnn 是一个正整数，欧拉函数 φ(n)\\varphi(n)φ(n) 定义为不超过 nnn 且与 nnn 互素的正整数的个数。 定义：模 nnn 的既约剩余系 是由 φ(n)\\varphi(n)φ(n) 个整数构成的集合，集合中的每个元素均与 nnn 互素，且任何两个元素模 nnn 不同余。 定理 6.13 下面是一个关于既约剩余系的定理。 定理 6.13：设 r1,r2,⋯ ,rφ(n)r_1,r_2,\\cdots,r_{\\varphi(n)}r1​,r2​,⋯,rφ(n)​ 是模 nnn 的一个既约剩余系，若 aaa 是一个正整数且 (a, n)=1(a,\\ n)=1(a, n)=1 ，那么集合 ar1,ar2,⋯ ,arφ(n)ar_1,ar_2,\\cdots,ar_{\\varphi(n)}ar1​,ar2​,⋯,arφ(n)​ 也是模 nnn 的一个既约剩余系。 证明： 定理 6.14 欧拉定理 定理 6.14（欧拉定理）：设 mmm 是一个正整数， aaa 是一个整数且 (a, m)=1(a,\\ m)=1(a, m)=1 ，那么 aφ(m)≡1 ( mod m)a^{\\varphi(m)}\\equiv 1\\ (\\bmod\\ m)aφ(m)≡1 (mod m) 。 证明：令 r1,r2,⋯ ,rφ(m)r_1,r_2,\\cdots,r_{\\varphi(m)}r1​,r2​,⋯,rφ(m)​ 是由不超过 mmm 且和 mmm 互素的元素组成的既约剩余系。由定理 6.13 ，因 (a, n)=1(a,\\ n)=1(a, n)=1 ，故集合 ar1,ar2,⋯ ,arφ(m)ar_1,ar_2,\\cdots,ar_{\\varphi(m)}ar1​,ar2​,⋯,arφ(m)​ 也是模 mmm 的一个既约剩余系。从而，在一定的顺序下 ar1,ar2,⋯ ,arφ(m)ar_1,ar_2,\\cdots,ar_{\\varphi(m)}ar1​,ar2​,⋯,arφ(m)​ 的最小正剩余一定是 r1,r2,⋯ ,rφ(m)r_1,r_2,\\cdots,r_{\\varphi(m)}r1​,r2​,⋯,rφ(m)​ 。因此，若把每个既约剩余系中的所有项乘起来，可得 ar1ar2⋯arφ(m)≡r1r2⋯rφ(m) ( mod m)ar_1ar_2\\cdots ar_{\\varphi(m)}\\equiv r_1r_2\\cdots r_{\\varphi(m)}\\ (\\bmod\\ m)ar1​ar2​⋯arφ(m)​≡r1​r2​⋯rφ(m)​ (mod m) 。 因而 aφ(m)r1r2⋯rφ(m)≡r1r2⋯rφ(m) ( mod m)a^{\\varphi(m)}r_1r_2\\cdots r_{\\varphi(m)}\\equiv r_1r_2\\cdots r_{\\varphi(m)}\\ (\\bmod\\ m)aφ(m)r1​r2​⋯rφ(m)​≡r1​r2​⋯rφ(m)​ (mod m) ，因为 (r1r2⋯rφ(m), m)=1(r_1r_2\\cdots r_{\\varphi(m)},\\ m)=1(r1​r2​⋯rφ(m)​, m)=1 ，故由推论 4.5.1知， aφ(m)≡1 ( mod m)a^{\\varphi(m)}\\equiv 1\\ (\\bmod\\ m)aφ(m)≡1 (mod m) 。 欧拉定理求乘法逆元 可以利用欧拉定理来求模 mmm 的逆。若 aaa 和 mmm 互素，则 a×aφ(m)−1=aφ(m)≡1 ( mod m)a\\times a^{\\varphi(m)-1}=a^{\\varphi(m)}\\equiv 1\\ (\\bmod\\ m)a×aφ(m)−1=aφ(m)≡1 (mod m) 。因此， aφ(m)−1a^{\\varphi(m)-1}aφ(m)−1 是 aaa 模 mmm 的逆。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"中国剩余定理","slug":"DS_Algorithm证明与讲解/数论/中国剩余定理","date":"2021-10-14T16:00:00.000Z","updated":"2021-10-23T04:33:11.233Z","comments":true,"path":"2021/10/15/DS_Algorithm证明与讲解/数论/中国剩余定理/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"","text":"中国剩余定理 Garner算法 CRT 的另一个用途是用一组比较小的质数表示一个大的整数。 扩展：模数不互质的情况 题目 洛谷题单：【数论】CRT 与 ExCRT P1495 【模板】中国剩余定理(CRT)/曹冲养猪 P2480 [SDOI2010]古代猪文：内置数论知识：欧拉-费马定理，Lucas定理，中国剩余定理(CRT)。这可真是一道“优美”基础数论全家桶！！！！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"题目/数据结构/树状数组","date":"2021-10-08T03:25:19.271Z","updated":"2021-10-08T15:05:28.218Z","comments":true,"path":"2021/10/08/题目/数据结构/树状数组/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/08/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"基本操作 P3374 【模板】树状数组 1：单点修改，区间查询 P3368 【模板】树状数组 2：区间修改，单点查询 AcWing 243. 一个简单的整数问题2：区间修改，区间查询 题解：彩色铅笔的题解 题单 洛谷题单：链接 AcWing 241. 楼兰图腾 P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P4939 Agent2 P5057 [CQOI2006]简单题 P2068 统计和 CF44C Holidays P2367 语文成绩 P2357 守墓人 P1908 逆序对 P5094 [USACO04OPEN]MooFest P1168 中位数 P1637 三元上升子序列 P1471 方差 P2448 无尽的生命 P1972 [SDOI2009]HH的项链 P3531 [POI2012]LIT-Letters P3253 [JLOI2013]删除物品 P5142 区间方差 P7394 「TOCO Round 1」History P2161 [SHOI2009]会场预约 P3149 排序 P3590 [POI2015]TRZ P2154 [SDOI2009]虔诚的墓主人 P3605 [USACO17JAN]Promotion Counting P","categories":[],"tags":[]},{"title":"CF constructive algorithms","slug":"题目/杂项/构造题","date":"2021-10-07T16:00:00.000Z","updated":"2021-10-24T13:58:09.688Z","comments":true,"path":"2021/10/08/题目/杂项/构造题/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/08/%E9%A2%98%E7%9B%AE/%E6%9D%82%E9%A1%B9/%E6%9E%84%E9%80%A0%E9%A2%98/","excerpt":"","text":"CFRating 1400-1600 CF1542B","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"constructive algorithms","slug":"题目/constructive-algorithms","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/constructive-algorithms/"}],"tags":[{"name":"构造题","slug":"构造题","permalink":"http://xiaoke-jin.github.io/tags/%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"快速幂","slug":"DS_Algorithm证明与讲解/数论/快速幂","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-07T08:26:22.578Z","comments":true,"path":"2021/10/02/DS_Algorithm证明与讲解/数论/快速幂/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"a^b % p是什么 设 ab mod pa^b\\bmod pabmodp 的值为 ansansans ，则有 ab≡ans( mod p)a^b\\equiv ans(\\bmod\\ p)ab≡ans(mod p) ，0⩽ans&lt;p0\\leqslant ans&lt;p0⩽ans&lt;p 。 求 ans 若 a≡b( mod p)a\\equiv b(\\bmod\\ p)a≡b(mod p)，则 a2≡b2( mod p)a^2\\equiv b^2(\\bmod\\ p)a2≡b2(mod p) ， a≡(b mod p)( mod p)a\\equiv (b\\bmod\\ p)(\\bmod\\ p)a≡(bmod p)(mod p) 。 若 c≡d( mod p)c\\equiv d(\\bmod\\ p)c≡d(mod p)， a×c≡b×d( mod p)a\\times c\\equiv b\\times d(\\bmod\\ p)a×c≡b×d(mod p) 。 bbb 可表示为 b=(bn−1⋯b1b0)2=bn−1×2n−1+⋯+b1×21+b0×20b=(b_{n-1}\\cdots b_1b_0)_2=b_{n-1}\\times2^{n-1}+\\cdots +b_{1}\\times2^{1}+b_{0}\\times2^{0}b=(bn−1​⋯b1​b0​)2​=bn−1​×2n−1+⋯+b1​×21+b0​×20 ， 因此 ab mod p=abn−1×2n−1+⋯+b1×21+b0×20 mod p=abn−1×2n−1⋯ab1×21ab0×20 mod p\\begin{align*} a^b\\bmod p&amp;=a^{b_{n-1}\\times2^{n-1}+\\cdots +b_{1}\\times2^{1}+b_{0}\\times2^{0}}\\bmod p\\\\ &amp;=a^{b_{n-1}\\times2^{n-1}}\\cdots a^{b_{1}\\times2^{1}}a^{b_0\\times 2^0}\\bmod p \\end{align*} abmodp​=abn−1​×2n−1+⋯+b1​×21+b0​×20modp=abn−1​×2n−1⋯ab1​×21ab0​×20modp​ 设 a0=aa_0=aa0​=a ，对于 a2n−1,⋯ ,a21,a20a^{2^{n-1}},\\cdots,a^{2^{1}},a^{2^{0}}a2n−1,⋯,a21,a20 有 a20≡a0 ( mod p)a21≡a1=(a0×a0)%p ( mod p)a22≡a2=(a1×a1)%p ( mod p)⋮a2n−1≡an−1=(an−2×an−2%p ( mod p))\\begin{align*} a^{2^0}&amp;\\equiv a_0\\ (\\bmod\\ p)\\\\ a^{2^1}&amp;\\equiv a_1=(a_0\\times a_0)\\%p\\ (\\bmod\\ p)\\\\ a^{2^2}&amp;\\equiv a_2=(a_1\\times a_1)\\%p\\ (\\bmod\\ p)\\\\ &amp;\\vdots\\\\ a^{2^{n-1}}&amp;\\equiv a_{n-1}=(a_{n-2}\\times a_{n-2}\\%p\\ (\\bmod\\ p)) \\end{align*} a20a21a22a2n−1​≡a0​ (mod p)≡a1​=(a0​×a0​)%p (mod p)≡a2​=(a1​×a1​)%p (mod p)⋮≡an−1​=(an−2​×an−2​%p (mod p))​ 显然，aia_iai​ 始终小于等于 ppp 。当 bi=0b_i=0bi​=0 ， 0⩽i⩽n−10\\leqslant i\\leqslant n-10⩽i⩽n−1 时，a2i≡1 ( mod p)a^{2^i}\\equiv 1\\ (\\bmod\\ p)a2i≡1 (mod p) 。 设 ans=1ans=1ans=1 ，（当 bi=0b_i=0bi​=0 ， 0⩽i⩽n−10\\leqslant i\\leqslant n-10⩽i⩽n−1 时，不用相乘）（下面的 = 为赋值操作） 1≡ans ( mod p)1×a20≡ans=ans×a0%p ( mod p)1×a21×a20≡ans=ans×a1%p ( mod p)⋮1×a2n−2×⋯×a21×a20≡ans=ans×an−2%p ( mod p)1×a2n−1×⋯×a21×a20≡ans=ans×an−1%p ( mod p)\\begin{align*} 1&amp;\\equiv ans\\ (\\bmod\\ p)\\\\ 1\\times a^{2^0}&amp;\\equiv ans=ans\\times a_0\\%p\\ (\\bmod\\ p)\\\\ 1\\times a^{2^1}\\times a^{2^0}&amp;\\equiv ans=ans\\times a_1\\%p\\ (\\bmod\\ p)\\\\ &amp;\\vdots\\\\ 1\\times a^{2^{n-2}}\\times\\cdots\\times a^{2^1}\\times a^{2^0}&amp;\\equiv ans=ans\\times a_{n-2}\\%p\\ (\\bmod\\ p)\\\\ 1\\times a^{2^{n-1}}\\times\\cdots\\times a^{2^1}\\times a^{2^0}&amp;\\equiv ans=ans\\times a_{n-1}\\%p\\ (\\bmod\\ p)\\\\ \\end{align*} 11×a201×a21×a201×a2n−2×⋯×a21×a201×a2n−1×⋯×a21×a20​≡ans (mod p)≡ans=ans×a0​%p (mod p)≡ans=ans×a1​%p (mod p)⋮≡ans=ans×an−2​%p (mod p)≡ans=ans×an−1​%p (mod p)​ 显然， ansansans 始终小于等于 ppp 。 代码实现 int quick_power(int a, int b, int p)&#123; int ans = 1; a = a % p; // 若 a 大于int范围，需要加这一步 while(b) &#123; if(b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"欧几里得算法","slug":"DS_Algorithm证明与讲解/数论/欧几里得算法","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-23T04:31:36.664Z","comments":true,"path":"2021/10/02/DS_Algorithm证明与讲解/数论/欧几里得算法/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"欧几里得算法 两个数的最大公因子 多个数的最大公因子 扩展欧几里得算法 链接：扩展欧几里得算法详解 类欧几里得算法 题目 洛谷题单：【数论】Exgcd/乘法逆元 P4549 【模板】裴蜀定理 P1072 [NOIP2009 提高组] Hankson 的趣味题 P5656 【模板】二元一次不定方程 (exgcd) 洛谷 P1516 青蛙的约会","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"素数相关算法","slug":"DS_Algorithm证明与讲解/数论/素性","date":"2021-10-01T16:00:00.000Z","updated":"2021-10-28T02:18:52.912Z","comments":true,"path":"2021/10/02/DS_Algorithm证明与讲解/数论/素性/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E7%B4%A0%E6%80%A7/","excerpt":"","text":"素数判断 试除法 任意合数 xxx 都至少有一个小于等于 x\\sqrt{x}x​ 的质因子。 bool is_prime(int x)&#123; for(int i = 2; i &lt;= x / i; i++) if(x % i == 0) return false; return true;&#125; kn+i 法 在枚举因子时只需要考虑可能为素数的因子即可。 kn+ikn+ikn+i 法即枚举形如 kn+ikn+ikn+i 的数，例如取 k=6k=6k=6 ，那么 6n+2,6n+3,6n+4,6n+66n+2,6n+3,6n+4,6n+66n+2,6n+3,6n+4,6n+6 都不可能为素数（显然它们分别有因子 2，3，2，6 ），因此我们只需要枚举形如 6n+1,6n+56n+1,6n+56n+1,6n+5 的数即可，这样整体的时间复杂度就会降低了 23\\dfrac{2}{3}32​ ，也就是 O(n13)O(n^{\\frac{1}{3}})O(n31​) 。 下面是 k=30k=30k=30 的模板： bool isPrime(LL n)&#123; if(n == 2 || n == 3 || n == 5) return 1; if(n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) return 0; LL c = 7, a[8] = &#123;4, 2, 4, 2, 4, 6, 2, 6&#125;; while(c * c &lt;= n) for(auto i : a) &#123; if(n % c == 0) return 0; c += i; &#125; return 1;&#125; 预处理法 Miller-Rabin ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"谷歌浏览器访问慢","slug":"工具/浏览器/谷歌浏览器访问慢","date":"2021-09-30T16:00:00.000Z","updated":"2021-10-01T07:11:54.604Z","comments":true,"path":"2021/10/01/工具/浏览器/谷歌浏览器访问慢/","link":"","permalink":"http://xiaoke-jin.github.io/2021/10/01/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E6%85%A2/","excerpt":"","text":"原文链接：一招解决 Chrome 打开网页速度巨慢的问题 今天偶然发现谷歌旗下的 Chrome 浏览器打开某些网页的时候速度慢的出奇。一经排查，排除了网络或者DNS解析慢的问题，初步锁定是 Chrome 内置的安全机制引起的 Bug。 由于你懂得原因，谷歌服务在墙内大多都是不可用的，而谷歌浏览器自带的网址安全检测功能由于网络不通，不断重试，则可能会导致浏览器打开部分网页时产生几秒的延迟。 解决方法很简单： 点击 Chrome 右上角的小图标，进入“设置” → “显示高级设置”； 找到“隐私设置”选项下的“保护您和您的设备不受危险网站的侵害” 去掉这个设置项前面的对勾，关闭浏览器重新打开，网页打开速度立马秒速全开！","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"浏览器","slug":"工具/浏览器","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第九章 原根","date":"2021-09-27T09:38:22.996Z","updated":"2021-10-05T05:44:52.761Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第九章 原根/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%8E%9F%E6%A0%B9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第十章 原根与整数的阶的应用","date":"2021-09-27T09:38:22.996Z","updated":"2021-10-05T13:46:38.627Z","comments":true,"path":"2021/09/27/读书笔记/数学/初等数论及其应用/第十章 原根与整数的阶的应用/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9A%84%E9%98%B6%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第四章 同余","slug":"读书笔记/数学/初等数论及其应用/第四章 同余","date":"2021-09-25T16:00:00.000Z","updated":"2021-10-16T02:43:45.127Z","comments":true,"path":"2021/09/26/读书笔记/数学/初等数论及其应用/第四章 同余/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%90%8C%E4%BD%99/","excerpt":"","text":"概要 德国大数学家高斯发明了同余的语言，这使得我们差不多能像处理等式一样来处理整除关系。 在本章中， 我们将给出同余的基本性质，描述如何进行同余式的算术运算， 还将研究含有未知数的 同余方程，例如线性同余方程。 我们还将研究 线性同余方程组，它们来源于古代中国难题：求一个数，它被 3，5 和 7 除所得余数分别为 2，3 和 2。我们将学习如何运用著名的 中国剩余定理 来解像上面那样的线性同余方程组难题。 我们还将学习怎样解 多项式同余方程。最后，我们用同余的语言来介绍一种整数分解方法，即 波拉德 ρ\\rhoρ 方法 。 4.1 同余概述 定义：设 mmm 是正整数，若 a,ba,ba,b 是正整数，且 m∣(a−b)m|(a-b)m∣(a−b) ，则称 aaa 和 bbb 模 mmm 同余 ，记为 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 。若 m∤(a−b)m\\nmid (a-b)m∤(a−b) ，则记 a≢b( mod m)a\\not\\equiv b(\\bmod m)a≡b(modm) ，并称 aaa 模 mmm 不同余于 bbb 。并称整数 mmm 称为同余的模。 定理 4.1 定理 4 .1：若 aaa 和 bbb 是整数，则 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，当且仅当存在整数 kkk ，使得 a=b+kma=b+kma=b+km 。 证明：若 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，则 m∣(a−b)m|(a-b)m∣(a−b) 。这说明存在整数 kkk ，使得 km=a−bkm=a-bkm=a−b ，所以 a=b+kma=b+kma=b+km 。 反过来，若存在整数 kkk 使得 a=b+kma=b+kma=b+km ，则 km=a−bkm=a-bkm=a−b 。于是 m∣(a−b)m|(a-b)m∣(a−b) ，因而 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 。 定理 4.2 同余的性质 定理 4 .2：设 mmm 是正整数。模 mmm 的同余满足下面的性质 （i）自反性：若 aaa 是整数，则 a≡a( mod m)a\\equiv a(\\bmod m)a≡a(modm) 。 （ii）对称性：若 a,ba,ba,b 是整数，且 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) ，则 b≡a( mod m)b\\equiv a(\\bmod m)b≡a(modm) 。 （iii）传递性：若 a,b,ca,b,ca,b,c 是整数，且 a≡b( mod m)a\\equiv b(\\bmod m)a≡b(modm) 和 b≡c( mod m)b\\equiv c(\\bmod m)b≡c(modm) ，则 a≡c( mod m)a\\equiv c(\\bmod m)a≡c(modm) 。 证明： （i）因为 m∣(a−a)m\\mid (a-a)m∣(a−a) ，所以 a≡a( mod m)a\\equiv a(\\bmod m)a≡a(modm) 。 （ii） （iii） 同余类 由定理 4.2 可见，整数的集合被分成 mmm 个不同的集合，这些集合称为 模 mmm 剩余类（同余类），每个同余类中的任意两个整数都是模 mmm 同余的。注意，当 m=2m=2m=2 时，整数被分成奇、偶两类。 设 mmm 是正整数，给定整数 aaa ，由带余除法有 a=bm+ra=bm+ra=bm+r ，其中 0≤r≤m−10\\le r\\le m-10≤r≤m−1 ，称 rrr 为 aaa 的模 mmm 最小非负剩余。类似的，当 mmm 不整除 aaa 时，称 rrr 为 aaa 的模 mmm 最小正剩余。 定理 4.3 定理 4.3：如 a, ba,\\ ba, b 为整数， mmm 为正整数，则 a≡b ( mod m)a\\equiv b\\ (\\bmod m)a≡b (modm) 当且仅当 a mod m=b mod ma\\bmod m=b\\bmod mamodm=bmodm 。 证明： 定理 4.4 见定理 4.6 见定理 4.6 定理 4.5 同余式除法 同余式不能随便做除法运算。 定理 4.5：若 a, b, c, ma,\\ b,\\ c,\\ ma, b, c, m 是整数， m&gt;0m&gt;0m&gt;0 ，d=(c, m)d=(c,\\ m)d=(c, m) ，且有 ac≡bc ( mod m)ac\\equiv bc\\ (\\bmod m)ac≡bc (modm) ，则 a≡b ( mod m/d)a\\equiv b\\ (\\bmod m/d)a≡b (modm/d) 。 证明：若 ac≡bc ( mod m)ac\\equiv bc\\ (\\bmod\\ m)ac≡bc (mod m) ，则 m∣(ac−bc)=c(a−b)m\\mid (ac-bc)=c(a-b)m∣(ac−bc)=c(a−b) 。所以，存在整数 kkk ，使得 c(a−b)=kmc(a-b)=kmc(a−b)=km 。两边同时除以 ddd ，得到 (c/d)(a−b)=k(m/d)(c/d)(a-b)=k(m/d)(c/d)(a−b)=k(m/d) 。因为 (m/d,c/d)=1(m/d,c/d)=1(m/d,c/d)=1 。所以根据引理 3.4 ，有 m/d∣(a−b)m/d\\mid (a-b)m/d∣(a−b) 。因此 a≡b ( mod m/d)a\\equiv b\\ (\\bmod m/d)a≡b (modm/d) 。 定理 4.6 同余式加减乘 定理 4.6：若 a, b, c, d, ma,\\ b,\\ c,\\ d,\\ ma, b, c, d, m 是整数， m&gt;0m&gt;0m&gt;0 ，a≡b ( mod m)a\\equiv b\\ (\\bmod m)a≡b (modm) ，且 c≡d ( mod m)c\\equiv d\\ (\\bmod m)c≡d (modm) ，则 （i）a+c≡b+d ( mod m)a+c\\equiv b+d\\ (\\bmod m)a+c≡b+d (modm) （ii）a−c≡b−d ( mod m)a-c\\equiv b-d\\ (\\bmod m)a−c≡b−d (modm) （iii）ac≡bd ( mod m)ac\\equiv bd\\ (\\bmod m)ac≡bd (modm) 证明： 引理 4.1 完全剩余系 由方程 a=bm+ra=bm+ra=bm+r 有 a≡r ( mod m)a\\equiv r\\ (\\bmod\\ m)a≡r (mod m) 。因此，每个整数都和 0,1,⋯ ,m−10,1,\\cdots,m-10,1,⋯,m−1 （也就是 aaa 被 mmm 除所得的余数）中的一个模 mmm 同余。因为 0,1,⋯ ,m−10,1,\\cdots,m-10,1,⋯,m−1 中的任何两个都不是模 mmm 同余的，所以需要 mmm 个整数使得每个整数每个整数都恰与此集合中的一个元素模 mmm 同余。 定义：一个 模 mmm 完全剩余系 是一个整数的集合，使得每个整数恰和此集合中的一个元素模 mmm 同余。 下面的引理帮助我们判定一个 mmm 元集合是否为模 mmm 的完全剩余系。 引理 4.1：mmm 个模 mmm 不同余的整数的集合是一个模 mmm 的完全剩余系。 证明： 定理 4.7 完全剩余系的扩展 定理 4.7：若 r1,r2,⋯ ,rmr_1,r_2,\\cdots,r_mr1​,r2​,⋯,rm​ 是一个模 mmm 的完全剩余系，且正整数 aaa 满足 (a,m)=1(a,m)=1(a,m)=1 ，则对任何整数 bbb ，ar1+b,ar2+b,⋯ ,arm+bar_1+b,ar_2+b,\\cdots,ar_m+bar1​+b,ar2​+b,⋯,arm​+b 都是模 mmm 的完全剩余系。 证明： 定理 4.8 同余式取幂 下面的定理表明同余式两边同时取相同的正整数幂仍保持同余。 定理 4.9 两个数关于不同模的同余式 下面的定理说明如何将两个数关于不同模的同余式结合起来。 定理 4.9： 推论 4.9.1 推论 4.9.1： 证明： 快速模指数运算（快速幂） 4.2 线性同余方程 \\qquad设 xxx 是未知整数，形如 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的同余式称为 一元线性同余方程 。在本节中，我们会看到研究这类同余方程与研究二元线性丢番图方程是类似的。（见 3.7节） \\qquad首先注意到，若 x=x0x=x_0x=x0​ 是同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的一个解，且 x0≡x1 ( mod m)x_0\\equiv x_1\\ (\\bmod\\ m)x0​≡x1​ (mod m) ，则 ax0≡ax1≡b ( mod m)ax_0\\equiv ax_1\\equiv b\\ (\\bmod\\ m)ax0​≡ax1​≡b (mod m) ，所以 也是一个解。因此，若一个模 mmm 同余类中的某个元素是解，则此同余类的所有元素都是解。于是，我们会问模 mmm 的 mmm 个同余类中有多少个是方程的解，这相当于问方程有多少个模 mmm 不同于的解。 定理 4.11 下面的定理告诉我们一元线性同余方程何时有解，在有解时方程有多少个模 mmm 不同余的解。 定理 4.11：设 a, b, ma,\\ b,\\ ma, b, m 是整数， m&gt;0, (a, m)=dm&gt;0,\\ (a,\\ m)=dm&gt;0, (a, m)=d 。若 d∤bd\\nmid bd∤b ，则 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 无解。若 d∣bd\\mid bd∣b ，则 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 恰有 个 ddd 模 mmm 不同余的解。 证明：由定理 4.1 ，线性同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 等价于二元线性丢番图方程 ax−my=bax-my=bax−my=b 。整数 xxx 是 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的解当且仅当存在整数 yyy 使得 ax−my=bax-my=bax−my=b 。 \\qquad由定理 3.23 可知，若 d∤bd\\nmid bd∤b ，则无解。而 d∤bd\\nmid bd∤b 时， 有无穷多解： x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t ， y=y0+(a/d)ty=y_0+(a/d)ty=y0​+(a/d)t 。其中 x=x0x=x_0x=x0​ 和 y=y0y=y_0y=y0​ 是方程的特解。上述 xxx 的值 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 是线性同余方程的解，有无穷多个这样的解。 \\qquad为确定有多少不同余的解，我们找来两个解 x1=x0+(m/d)t1x_1=x_0+(m/d)t_1x1​=x0​+(m/d)t1​ 和 x2=x0+(m/d)t2x_2=x_0+(m/d)t_2x2​=x0​+(m/d)t2​ 模 mmm 同余的条件。若这两个解同余，则 x0+(m/d)t1≡x0+(m/d)t2 ( mod m)x_0+(m/d)t_1\\equiv x_0+(m/d)t_2\\ (\\bmod\\ m)x0​+(m/d)t1​≡x0​+(m/d)t2​ (mod m) 。两边减去 x0x_0x0​ ，有 (m/d)t1≡(m/d)t2 ( mod m)(m/d)t_1\\equiv (m/d)t_2\\ (\\bmod\\ m)(m/d)t1​≡(m/d)t2​ (mod m) 。因为 (m/d)∣m(m/d)\\mid m(m/d)∣m ，所以 (m, m/d)=m/d(m,\\ m/d)=m/d(m, m/d)=m/d ，再由定理 4.5 ， t1≡t2 ( mod d)t_1\\equiv t_2\\ (\\bmod\\ d)t1​≡t2​ (mod d) 。这表明不同余的解的一个完全集合可以通过取 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 得到，其中 ttt 取遍模 ddd 的完全剩余系。这样的一个集合可由 x=x0+(m/d)tx=x_0+(m/d)tx=x0​+(m/d)t 给出，其中 t=0,1,2,⋯ ,d−1t=0,1,2,\\cdots,d-1t=0,1,2,⋯,d−1 。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 推论 4.11.16 推论 4.11.1：若 (a, m)=1(a,\\ m)=1(a, m)=1 ，则线性同余方程 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 有模 mmm 的唯一解。 证明： 模的逆 现在考虑特殊的同余方程 ax≡1 ( mod m)ax\\equiv 1\\ (\\bmod\\ m)ax≡1 (mod m) 。由定理 4.11 ，此方程有解当且仅当 (a, m)=1(a,\\ m)=1(a, m)=1 ，于是其所有的解都模 mmm 同余。 定义：给定整数 aaa ，且满足 (a, m)=1(a,\\ m)=1(a, m)=1 。称 ax≡1 ( mod m)ax\\equiv 1\\ (\\bmod\\ m)ax≡1 (mod m) 的一个解为 aaa 模 mmm 的逆。 当我们有 aaa 模 mmm 的一个逆时，可以用它来解形如 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) 的任何同余方程。为看清这一点，令 aˉ\\bar{a}aˉ 是 aaa 模 mmm 的一个逆。于是，若 ax≡b ( mod m)ax\\equiv b\\ (\\bmod\\ m)ax≡b (mod m) ，则将同余方程两边同时乘以 aˉ\\bar{a}aˉ ，得到 aˉ(ax)≡aˉb ( mod m)\\bar{a}(ax)\\equiv \\bar{a}b\\ (\\bmod\\ m)aˉ(ax)≡aˉb (mod m) ，所以 x≡aˉb ( mod m)x\\equiv \\bar{a}b\\ (\\bmod\\ m)x≡aˉb (mod m) 。 定理 4.12 下面的定理告诉我们哪些整数是其自身模 ppp 的逆，其中 ppp 是素数。 定理 4.12：设 ppp 是素数。正整数 aaa 是其自身模 ppp 的逆当且仅当 a≡1 ( mod p)a\\equiv 1\\ (\\bmod\\ p)a≡1 (mod p) 或 a≡−1 ( mod p)a\\equiv -1\\ (\\bmod\\ p)a≡−1 (mod p) 。 证明：若 a≡1 ( mod p)a\\equiv 1\\ (\\bmod\\ p)a≡1 (mod p) 或 a≡−1 ( mod p)a\\equiv -1\\ (\\bmod\\ p)a≡−1 (mod p) ，则 a2≡1 ( mod p)a^2\\equiv 1\\ (\\bmod\\ p)a2≡1 (mod p) 。所以 aaa 是其自身模 ppp 的逆。 反过来，若 aaa 是其自身模 ppp 的逆，则 a2≡1 ( mod p)a^2\\equiv 1\\ (\\bmod\\ p)a2≡1 (mod p) 。因此， p∣(a2−1)p\\mid (a^2-1)p∣(a2−1) 。又因为 a2−1=(a−1)(a+1)a^2-1=(a-1)(a+1)a2−1=(a−1)(a+1) ，所以 p∣(a−1)p\\mid (a-1)p∣(a−1) 或 。因此， p∣(a−1)p\\mid (a-1)p∣(a−1) ，或者 p∣(a+1)p\\mid (a+1)p∣(a+1) 。 4.3 中国剩余定理 我们考虑仅有一个未知数但有不同模的同余方程组。这样的方程组来源于古代中国难题。 定理 4.13 中国剩余定理 定理 4.13（中国剩余定理）：设 m1,m2,⋯ ,mrm_1,m_2,\\cdots,m_rm1​,m2​,⋯,mr​ 是两两互素的正整数，则同余方程组 x≡a1 ( mod m1)x≡a2 ( mod m2)⋮x≡ar ( mod mr)\\begin{align*} x&amp;\\equiv a_1\\ (\\bmod\\ m_1)\\\\ x&amp;\\equiv a_2\\ (\\bmod\\ m_2)\\\\ &amp;\\vdots\\\\ x&amp;\\equiv a_r\\ (\\bmod\\ m_r)\\\\ \\end{align*} xxx​≡a1​ (mod m1​)≡a2​ (mod m2​)⋮≡ar​ (mod mr​)​ 有模 M=m1m2⋯mrM=m_1m_2\\cdots m_rM=m1​m2​⋯mr​ 的唯一解。 证明：首先，构造同余方程组的一个联立解。为此，令 Mk=M/mk=m1m2⋯mk−1mk+1⋯mrM_k=M/m_k=m_1m_2\\cdots m_{k-1}m_{k+1}\\cdots m_rMk​=M/mk​=m1​m2​⋯mk−1​mk+1​⋯mr​ ，得 (Mk,mk)=1(M_k,m_k)=1(Mk​,mk​)=1 。因此由定理 4.11，可求得 MkM_kMk​ 模 mkm_kmk​ 的一个逆 yky_kyk​ ，所以 Mkyk≡1 ( mod mk)M_ky_k\\equiv 1\\ (\\bmod\\ m_k)Mk​yk​≡1 (mod mk​) 。现在构造和 x=a1M1y1+a2M2y2+⋯+arMryrx=a_1M_1y_1+a_2M_2y_2+\\cdots+a_rM_ry_rx=a1​M1​y1​+a2​M2​y2​+⋯+ar​Mr​yr​ 。 整数 xxx 就是 rrr 个同余方程的联立解。要证明这一点，只需证明对于 k=1,2,⋯ ,rk=1,2,\\cdots,rk=1,2,⋯,r 有 x≡ak ( mod mk)x\\equiv a_k\\ (\\bmod\\ m_k)x≡ak​ (mod mk​) 。因为 j≠kj\\ne kj=k 时 mk∣Mjm_k\\mid M_jmk​∣Mj​ ，所以 Mj≡0 ( mod mk)M_j\\equiv 0\\ (\\bmod\\ m_k)Mj​≡0 (mod mk​) 。因此，在 xxx 的和式中，除了第 kkk 项之外的所有项都和 000 模 mkm_kmk​ 同余。从而 x≡akMkyk≡ak ( mod mk)x\\equiv a_kM_ky_k\\equiv a_k\\ (\\bmod\\ m_k)x≡ak​Mk​yk​≡ak​ (mod mk​) 。现在来证任意两个解都是模 MMM 同余的。设 x0x_0x0​ 和 x1x_1x1​ 都是同余方程组中 rrr 个方程的联立解。则对每个 kkk ，x0≡x1≡ak ( mod mk)x_0\\equiv x_1\\equiv a_k\\ (\\bmod\\ m_k)x0​≡x1​≡ak​ (mod mk​) ，由定理 4.9 可知， M∣(x0−x1)M\\mid (x_0-x_1)M∣(x0​−x1​) 。因此， x0≡x1 ( mod M)x_0\\equiv x_1\\ (\\bmod\\ M)x0​≡x1​ (mod M) 。这说明同余方程组的 rrr 个方程的联立解是模 MMM 唯一的。 4.4 求解多项式同余方程 4.5 线性同余方程组 定理 4.20 4.6 利用波拉德方法分解整数","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"","slug":"题目/图论/最小生成树","date":"2021-09-22T12:23:02.102Z","updated":"2021-09-22T12:23:02.102Z","comments":true,"path":"2021/09/22/题目/图论/最小生成树/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/22/%E9%A2%98%E7%9B%AE/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"题目/图论/最短路","date":"2021-09-22T12:23:02.102Z","updated":"2021-09-22T12:23:11.451Z","comments":true,"path":"2021/09/22/题目/图论/最短路/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/22/%E9%A2%98%E7%9B%AE/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"题单","slug":"题目/题单","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-30T04:11:14.002Z","comments":true,"path":"2021/09/21/题目/题单/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/%E9%A2%98%E7%9B%AE/%E9%A2%98%E5%8D%95/","excerpt":"","text":"2021-09-21 ​ 题单，日后整理","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"}]},{"title":"KMP","slug":"DS_Algorithm证明与讲解/字符串/KMP","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T02:06:41.144Z","comments":true,"path":"2021/09/21/DS_Algorithm证明与讲解/字符串/KMP/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP/","excerpt":"","text":"链接：KMP算法及其优化（超详解）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"离散化题目","slug":"题目/基础算法/离散化","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T02:36:01.214Z","comments":true,"path":"2021/09/21/题目/基础算法/离散化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/","excerpt":"","text":"保序离散化 AcWing 802. 区间和 洛谷 P6602 「EZEC-2」数轴 无序离散化","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"离散数学 第二版 屈婉玲","slug":"读书笔记/数学/离散数学及其应用/离散 屈婉玲","date":"2021-09-20T16:00:00.000Z","updated":"2021-09-21T02:09:12.043Z","comments":true,"path":"2021/09/21/读书笔记/数学/离散数学及其应用/离散 屈婉玲/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%A6%BB%E6%95%A3%20%E5%B1%88%E5%A9%89%E7%8E%B2/","excerpt":"","text":"\\qquad取值1或0的变元称作命题变项，可以用命题变项表示真值可以变化的陈述句。用p、q、r等表示命题变项。 \\qquad定义：命题变项及其否定统称为文字。仅由有限个文字构成的析取式称作简单析取式，仅由有限个文字构成的合取式称作简单合取式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/并查集","date":"2021-09-20T01:48:31.200Z","updated":"2021-09-21T13:25:14.034Z","comments":true,"path":"2021/09/20/DS_Algorithm证明与讲解/数据结构/并查集/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/20/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"基本并查集 int p[N];// p[x] == x的父结点void init()&#123; for(int i = 0; i &lt; n; i++) p[i] = i;&#125;int find(int x)&#123; return x == p[x] ? p[x] : p[x] = find(p[x]); // 路径压缩&#125;void merge(int a, int b)&#123; p[find(a)] = p[find(b)];&#125; 扩展并查集 维护 size int sz[N]; // 集合的大小 == size[根结点]，size[子结点]无意义void init()&#123; for(int i = 0; i &lt; n; i++) p[i] = i, size[i] = 1;&#125;void merge(int a, int b)&#123; int x = find(a), y = find(b); if(x == y) return ; p[x] = p[y]; sz[b] += sz[a];&#125; 维护到根节点距离 int p[N], d[N];int find(int x)&#123; if(x != p[x]) &#123; int u = find(p[x]); d[x] += d[u]; p[x] = u; &#125; return p[x];&#125; 扩展域","categories":[],"tags":[]},{"title":"","slug":"题目/搜索/DFS","date":"2021-09-19T09:52:14.926Z","updated":"2021-09-19T09:58:42.447Z","comments":true,"path":"2021/09/19/题目/搜索/DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/DFS/","excerpt":"","text":"剪枝与优化 洛谷 P1120 小木棍 洛谷 P1731 [NOI1999] 生日蛋糕","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-剪枝与优化","date":"2021-09-19T08:44:47.214Z","updated":"2021-09-19T08:55:44.232Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-剪枝与优化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-%E5%89%AA%E6%9E%9D%E4%B8%8E%E4%BC%98%E5%8C%96/","excerpt":"","text":"常用优化方法 优化搜索顺序：大部分情况下，我们应该优先搜索分支较少的结点。 排除等效冗余： 比如按照组合数枚举而不是排列数。 可行性剪枝 最优性剪枝","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-IDAstar","date":"2021-09-19T08:44:30.425Z","updated":"2021-09-19T08:45:49.868Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-IDAstar/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-IDAstar/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-双向DFS","date":"2021-09-19T08:44:30.425Z","updated":"2021-09-19T08:45:33.289Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-双向DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-%E5%8F%8C%E5%90%91DFS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/搜索/DFS/DFS-迭代加深","date":"2021-09-19T08:44:30.425Z","updated":"2021-09-19T08:44:30.425Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/搜索/DFS/DFS-迭代加深/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/DFS/DFS-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/基础算法/位运算","date":"2021-09-19T07:00:37.335Z","updated":"2021-09-19T08:19:51.009Z","comments":true,"path":"2021/09/19/DS_Algorithm证明与讲解/基础算法/位运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/19/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"lowbit 根据计算机负数表示的特点，如一个数字原码是 10001000，他的负数表示形势是补码，就是反码+1，反码是01110111，加一则是01111000，二者按位与得到了1000，就是我们想要的 lowbit 操作 int lowbit(n)&#123; return n &amp; (n - 1);&#125; 二进制枚举","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/Splay","date":"2021-09-18T08:12:28.459Z","updated":"2021-09-18T08:12:28.459Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/数据结构/Splay/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Splay/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/线段树","date":"2021-09-18T08:12:28.459Z","updated":"2021-09-18T08:12:45.853Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/数据结构/线段树/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/数据结构/树状数组","date":"2021-09-18T08:12:28.459Z","updated":"2021-10-07T14:40:03.575Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/数据结构/树状数组/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"树状数组（Binary Indexed Tree） 求前缀和、修改某个数","categories":[],"tags":[]},{"title":"","slug":"DS_Algorithm证明与讲解/组合数学/斯特林数","date":"2021-09-18T08:12:18.046Z","updated":"2021-09-18T08:12:18.046Z","comments":true,"path":"2021/09/18/DS_Algorithm证明与讲解/组合数学/斯特林数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/18/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"逻辑基础","slug":"读书笔记/数学/离散数学及其应用/逻辑","date":"2021-09-11T16:00:00.000Z","updated":"2021-09-21T02:07:45.723Z","comments":true,"path":"2021/09/12/读书笔记/数学/离散数学及其应用/逻辑/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E9%80%BB%E8%BE%91/","excerpt":"","text":"必要条件：如果没有A，则必然没有B；如果有A而未必有B，则A就是B的必要条件，记作B→\\to→A，读作“B含于A”。数学上简单来说就是如果由结果B能推导出条件A，我们就说A是B的必要条件。 充分条件：如果A能推出B，那么A就是B的充分条件。其中A为B的子集，即属于A的一定属于B，而属于B的不一定属于A。 链接：“当且仅当”是充要条件吗？ 当且仅当 当且仅当 与 充要条件 这两个概念并没有天然的等价，否则也不会有那么多人提问类似的问题了。 当且仅当（ If and only if ），表示“在，并且仅在这些条件成立的时候”的缩写，缩写为 iff 用 P当且仅当Q 来举例。 当： 当Q成立时，P成立。 所以P的充分条件是Q 仅当： 仅当Q成立时，P才成立。也就是说，当Q不成立时，P也不成立。故其等价的 逆否命题 是，当P成立时，Q才成立。所以P的必要条件是Q 综合“当”和“仅当”，可得P的充要条件是Q。 结论: 当且仅当 等价于 充要条件 。 对 p→qp\\to qp→q 的理解 原文链接：[对 p→qp\\to qp→q 的理解]((3 封私信 / 18 条消息) “p仅当q”和“p蕴含q”有什么区别? - 知乎 (zhihu.com)) 在经典主义逻辑框架下， p→qp\\to qp→q 被称为「实质蕴含」，就是说，这句话 不应该 被解释成自然语言中的”如果 ppp，则 qqq “，而是应该解释成”如果 ppp 为真，那么 qqq 也为真“。因为 ppp 和 qqq 可以完全不相干。实质蕴含最让初学者糊涂的地方是，如果 ppp 为假时， p→qp\\to qp→q 居然必然为真。不要小看这点区别，这会引起很多的「反直觉」结论： 反直觉命题一： p→q∨q→pp\\to q\\lor q\\to pp→q∨q→p 这个在经典主义框架下是永真的，这个可以被误读成：世界上的所有东西都是相互关联的。 反直觉命题二： Pierce’s Law ((p→q)→p)→p((p\\to q)\\to p)\\to p((p→q)→p)→p 这个在经典主义框架下也是永真的，解释下试试看，如果一个蕴含式能蕴含它的前件，那么它的前件 p 就为真。请用「如果……，那么……」解释下试试看？ 反直觉命题三：著名的 Drinker’s Paradox，饮酒者悖论 ∃x∈P.D(x)→∀y∈P.D(x)\\exists x\\in P.D(x)\\to \\forall y\\in P.D(x)∃x∈P.D(x)→∀y∈P.D(x) 「如果一个酒吧里面存在一个饮酒者，”那么“ 酒吧里面所有的人都在饮酒。」这句话是不是很荒唐？我们之所以认为荒唐，正是因为我们把蕴含符号「错误解读」成为了”如果……，那么……“。 在经典主义逻辑框架下，「 p→qp\\to qp→q 等价于 ¬p∨q\\neg p\\lor q¬p∨q 」，可以解读为「要么条件 p 为假，要么结论 q 为真」，实际上也还是在解释「实质蕴含」。 当 ppp 为假时，蕴含关系始终是成立的。这是为了保证反证法（或者说逆否命题与原命题的等价性，即 p→qp\\to qp→q 与 ¬q→¬p\\neg q\\to \\neg p¬q→¬p 等价）成立而特别规定的。这常常被称为「假前件可以得出任意结论」。 逻辑学上，若p则q型的命题，等价于“非p或q”，其否定形式是“p且非q”。这在中学数学里虽然避而不讲，但是却经常被不加证明地使用，都用在哪了呢？用在反证法解题中了 。大家回忆一下，反证法为什么第一步要假设与结论相反的的结果，然后与条件结合起来导出矛盾?这其实就是在证明最初命题的否定“p且非q”是假命题，然后依据排中律，说明要证的命题为真。 这是一个老话题，却似乎常聊常新。原因还在于黑格尔那句老话，人是天生的形而上学家，他们直觉地太看重把事情“说通”，而其实把事情“做通”才是更重要的。说通，是语言逻辑的重任，但数理逻辑关心的却是做通。p-&gt;q，语言中是要用p得到q，数学中则不然，可能p根本不存在，根本不存在由p得到q的问题，但却要求p-&gt;q形式地存在。这时你不能从语言角度去纠结 p→qp\\to qp→q 究竟是什么意思，它没有什么意思，它就是数学上一种形式性的或构造性的要求，有了它推导或运算的过程才能进行，事情才能做通。实际上罗素在使用 实质蕴涵 一词来指这个数理逻辑中的所谓蕴涵时就已经制止了把它与自然语言中的蕴涵一词视作同义的想当然，罗素清楚指出这个所谓的蕴涵，其含义不是来自自然语言，而是由其规定的运算或赋值规则本身来定义，这些规则规定才是这个所谓蕴涵的实质，因此它叫做实质蕴涵。 这么定义只是为了 保证前者的「内涵」比后者小 ，集合包含关系的定义就是用蕴含定义的。蕴含关系表示的就是这么一种强弱关系，真真假假的根本不重要，他本身就和若则的语义不相同，其他的解释多少都是别扭的。 对于集合A，B，A ⊆ B 当且仅当∀x ∈ A，x ∈ B(或者说命题P(x):「若x属于A，则x属于B」对于任意x为真)。 那么问题来了，我们应该都承认对于任意集合S，∅ ⊆ S。这意味着命题「若x属于∅，则x属于S」对于任意x为真。然而没有任何x是属于空集的，所以前提(x属于∅)就一定是假的，而原命题(等价于∅ ⊆ S)却总是真的。也就是题主问的蕴含关系 本质上题主说的这种蕴含关系就是一种数学上的约定，方便我们处理类似∅ ⊆ S的问题。就像0这个数字一样，最开始是不显然的，我们完全可以不要它就可以数数(用自然数)，我们引入0只是为了方便数学的发展。这个问题也是一样，只能努力试着去接受大家约定俗成的东西，至少经验上证明它是很好用的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"Java基础","slug":"语言/Java/Java基础","date":"2021-09-09T16:00:00.000Z","updated":"2021-09-14T02:28:39.682Z","comments":true,"path":"2021/09/10/语言/Java/Java基础/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/10/%E8%AF%AD%E8%A8%80/Java/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java平台主要由两部分组成：Java虚拟机、Java应用程序接口 Java虚拟机 是 Java的核心和基础，是Java编译器和操作平台之间的虚拟处理机，利用软件方法实现的抽象的计算机，它有自己完善的架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机执行的是Java的字节码程序，这个字节码可能来自本地计算机，也可能来自网络。Java虚拟机通过类装载，字节码验证，最后执行。Java的跨平台性都是由 Java虚拟机来实现的。 Java API 是Java的应用程序编程基础，是Java标准类的集合，程序员在开发程序的时候，可以直接调用这些现成的类，Java程序若想运行，必须提供Java的运行环境 JRE，JRE提供了运行Java程序所必需的类库、Java API、Java虚拟机及其一些必要的组件。 如果进行Java程序开发，我们要有 Java开发程序包 JDK，这个程序包，包含了JRE 、API 和进行Java程序开发的编译和调试工具。最新版的 JDK11将 JRE和 JDK整合在一起，在安装目录下只有 JDK。 不同的 Java应用程序，需要不同的 Java平台，Java平台版本主要有三种：Java SE、EE、ME。 Java SE提供了标准的JDK开发平台，主要开发 Java桌面应用程序，是我们这门课使用的开发平台； Java EE是构建企业级的服务应用，包含了 Java SE平台，并增加了附加类库，以支持目录管理、交易管理和企业级消息处理等功能； Java ME用于嵌入式的消费产品开发。要想进行 Java的开发，需要先安装Java开发程序包 JDK； Java程序的开发流程 编辑源文件：文本编辑器 字节码文件 .class 编译源文件，生成字节码：javac.exe 运行字节代码：java.exe","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"}]},{"title":"欧拉筛、欧拉函数","slug":"DS_Algorithm证明与讲解/数论/欧拉函数","date":"2021-09-02T16:00:00.000Z","updated":"2021-10-28T02:43:32.415Z","comments":true,"path":"2021/09/03/DS_Algorithm证明与讲解/数论/欧拉函数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/03/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"欧拉函数 定义：设 nnn 是一个正整数，欧拉函数 φ(n)\\varphi(n)φ(n) 定义为不超过 nnn 且与 nnn 互素的正整数的个数。 欧拉函数的性质 具体证明请参考《初等数论及其应用》第6，7章。 欧拉函数是积性函数。 n=∑d∣nφ(d)n = \\sum_{d \\mid n}{\\varphi(d)}n=∑d∣n​φ(d)。 若 n=pkn = p^kn=pk，其中 ppp 是质数，那么 φ(n)=pk−pk−1\\varphi(n) = p^k - p^{k - 1}φ(n)=pk−pk−1。 由唯一分解定理，设 n=∏i=1spikin = \\prod_{i=1}^{s}p_i^{k_i}n=∏i=1s​piki​​，其中 pip_ipi​ 是质数，有 φ(n)=n×∏i=1spi−1pi\\varphi(n) = n \\times \\prod_{i = 1}^s{\\dfrac{p_i - 1}{p_i}}φ(n)=n×∏i=1s​pi​pi​−1​。 ∀n, n&gt;1\\forall n,\\ n&gt;1∀n, n&gt;1 ，1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 中与 nnn 互质的数的和为 n×φ(n)2n\\times \\dfrac{\\varphi(n)}{2}n×2φ(n)​ 。 分解质因数求欧拉函数 如果只要求一个数的欧拉函数值，那么直接根据定义质因数分解的同时求就好了。这个过程可以用 Pollard Rho 算法优化。 int div(int n)&#123; int ans = n; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; while(x % i == 0) x /= i; &#125; ans -= ans / i; &#125; if(n &gt; 1) ans -= ans / n; return ans;&#125; 筛法求欧拉函数 注意到在线性筛中，每一个合数都是被最小的质因子筛掉。比如设 p1p_1p1​ 是 nnn 的最小质因子，n′=np1n&#x27; = \\dfrac{n}{p_1}n′=p1​n​，那么线性筛的过程中 nnn 通过 n′×p1n&#x27; \\times p_1n′×p1​ 筛掉。 观察线性筛的过程，我们还需要处理两个部分，下面对 n′ mod p1n&#x27; \\bmod p_1n′modp1​ 分情况讨论。 如果 n′ mod p1=0n&#x27; \\bmod p_1 = 0n′modp1​=0，那么 n′n&#x27;n′ 包含了 nnn 的所有质因子。 φ(n)=n×∏i=1spi−1pi=p1×n′×∏i=1spi−1pi=p1×φ(n′)\\begin{aligned} \\varphi(n) &amp; = n \\times \\prod_{i = 1}^s{\\frac{p_i - 1}{p_i}} \\\\ &amp; = p_1 \\times n&#x27; \\times \\prod_{i = 1}^s{\\frac{p_i - 1}{p_i}} \\\\ &amp; = p_1 \\times \\varphi(n&#x27;) \\end{aligned} φ(n)​=n×i=1∏s​pi​pi​−1​=p1​×n′×i=1∏s​pi​pi​−1​=p1​×φ(n′)​ 那如果 n′ mod p1≠0n&#x27; \\bmod p_1 \\neq 0n′modp1​=0 呢，这时 n′n&#x27;n′ 和 p1p_1p1​ 是互质的，因为欧拉函数是乘性函数，我们有： φ(n)=φ(p1)×φ(n′)=(p1−1)×φ(n′)\\begin{aligned} \\varphi(n) &amp; = \\varphi(p_1) \\times \\varphi(n&#x27;) \\\\\\\\ &amp; = (p_1 - 1) \\times \\varphi(n&#x27;) \\end{aligned} φ(n)​=φ(p1​)×φ(n′)=(p1​−1)×φ(n′)​ // C++ Versionvoid pre() &#123;// 初始化 memset(is_prime, 0, sizeof(is_prime)); int cnt = 0; phi[1] = 1; int n = 5000000; for (int i = 2; i &lt;= n; i++) &#123; if (!is_prime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; i * prime[j] &lt;= n; j++) &#123; is_prime[i * prime[j]] = 1; if (i % prime[j]) phi[i * prime[j]] = phi[i] * phi[prime[j]]; else &#123; // i % p == 0 phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; &#125; &#125;&#125; 题目 洛谷题单：欧拉函数与欧拉定理 AcWing 201. 可见的点 三维版本：SP7001 VLATTICE - Visible Lattice Points","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"BFS-A*算法证明与详解","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS A-star","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-07T15:31:21.663Z","comments":true,"path":"2021/09/02/DS_Algorithm证明与讲解/搜索/BFS/BFS A-star/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%20A-star/","excerpt":"","text":"写的好垃圾，，，什么时候觉得满意了就删掉，，， ​ 符号说明 g(state)g(state)g(state) ：从初态 st 到当前状态 state 的当前距离；（不一定最短） g∗(state)g^*(state)g∗(state)：从初态 st 到当前状态的实际最小距离； h(state)h(state)h(state) ：从当前状态 state 到终点的估价距离； h∗(state)h^*(state)h∗(state) ：从当前状态 state 到终点的真实距离； f(state)=g(state)+h(state)f(state)=g(state)+h(state)f(state)=g(state)+h(state) ，从初始状态出发经过状态 state 再到达终点的最小代价预估； open list：存储可到达的状态，close list：存储已到达的状态； 估价距离与真实距离： h(state)≤h∗(state)h(state)\\le h^*(state)h(state)≤h∗(state) ； 一旦估价函数确定，则对任意状态 state 的 h(state)h(state)h(state) 就确定了，随着搜索过程变化的是 g(state)g(state)g(state) ，显然，当 g∗(state)=g(state)g^*(state)=g(state)g∗(state)=g(state) 时，g(state)g(state)g(state) 不会再被更新； A* 应用场景 状态空间非常大，普通BFS无脑暴搜则时间复杂度无法接受。若空间比较小不适用，因为使用了优先队列，加入和取出状态的时间复杂度是 O(log⁡n)O(\\log{n})O(logn) 。 有解（无解时，仍然会把所有空间搜索，会比一般的BFS慢，因为优先队列的操作是 log⁡n\\log nlogn 的） 边权非负，如果是负数，那么终点的估值有可能是负无穷，终点可能会直接出堆。 A* 算法流程 while(q.size()) 小根堆 // 谁的d[u]+f[u]更小 谁先出队列 t ← 优先队列的队头 当终点第一次出队时 break ; // 终点第一次出队，到终点距离最小 从该状态向周围状态扩展： if state 未遍历过 || g(state) 可松弛 （松弛时使用 g() 而不是 f() 入队 A*只能保证终点出队时到终点距离最小，不能保证其他点，因为估价距离是相对于终点而言的。 A* 不对状态判重 结点可能会被重复遍历。 当某状态 state 的 d+fd+fd+f 较短时，从该状态出发未必能找到最短路，但是从 state 出发遍历到的点可能是最短路上的点，在未来会再次被访问。 只要搜到的状态 state 未访问过 或 g(state)g(state)g(state) 可松弛 ，就要加入优先队列。 A* 算法证明 设最短路径 Pst−end=start(v0)→v1→v2→⋯→end(vm)P_{st-end}=start(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=start(v0​)→v1​→v2​→⋯→end(vm​) 。 ​ 对于路径上的任意一点 vkv_kvk​，1≤k≤m1\\le k\\le m1≤k≤m ，当其前驱点出堆后，使用前驱点更新 g(k)g(k)g(k)，才能得到 g(k)=g∗(k)g(k)=g^*(k)g(k)=g∗(k) 且 vkv_kvk​ 一定在堆中（被更新或刚加入）且 g∗(k)+h(k)≤g∗(k)+h∗(k)=g∗(end)g^*(k)+h(k)\\le g^*(k)+h^*(k)=g^*(end)g∗(k)+h(k)≤g∗(k)+h∗(k)=g∗(end) 。 ​ 显然，在未取到 g∗(end)g^*(end)g∗(end) 时，end(vm)end(v_m)end(vm​) 一定不是按照最短路一步步更新得到的，即从 start(v0)start(v_0)start(v0​) 开始的最短路尚未走完，则「堆中一定存在最短路径上的某点」。 f()≤g∗(end)f()\\le g^*(end)f()≤g∗(end) 的点未必在最短路上，最短路上的点一定满足 f()≤g∗(end)f()\\le g^*(end)f()≤g∗(end) 。 每次出堆的状态有两种： 若是非最短路上的点，一定会在搜索到 end(vm)end(v_m)end(vm​) 或搜到 end(vm)end(v_m)end(vm​) 之前，得到某个状态 y （包括终点）的 f(y)&gt;g∗(end)f(y)&gt;g^*(end)f(y)&gt;g∗(end)，此时堆中一定存在最短路径上的点。然后会从另一个 f()f()f() 最小的点出发。 若选取到最短路上的点，则离终点更近一步。最终搜到终点使得 g(end)=g∗(end)g(end)=g^*(end)g(end)=g∗(end) 。搜到终点后，堆中可能还会有 f()f()f() 更小的点存在，但这些点向外扩展时都不再改变到 g(end)g(end)g(end) 。 最终 end(vm)end(v_m)end(vm​) 第一次出堆时，即得到最短路。 若最短路径有多条，同理，结论不变。 反证法证明：终点第一次出队列即最优解 1 假设终点第一次出队时不是最优 说明按当前路径得到的 g(终点) 一定严格大于从起点到终点的最小距离 g*(终点) 则说明当前队列中存在点 u 属于最短路径 g(终点) &gt; g*(终点) = g(u) + h*(u) &gt;= g(u) + h(u) 即队列中存在比 g(终点 ) 小的值 2 但我们维护的是一个小根堆，没有比g(队头终点)小的g(u)+h(u)，产生矛盾 证毕 如果当前状态 x 不是最短路上的节点，那么即使 f(x)f(x)f(x) 当前最小，从 x 向外搜索一定会在搜索到 end(vm)end(v_m)end(vm​) 或搜到 end(vm)end(v_m)end(vm​) 之前，得到某个状态 y 的 f(y)&gt;g∗(end)f(y)&gt;g^*(end)f(y)&gt;g∗(end)。 A* 优势 摘抄自《算法竞赛进阶指南》 普通优先队列BFS算法维护了一个优先队列（二叉堆），不断从堆中取出“当前代价最小”的状态（堆顶）进行扩展。每个状态第一次从堆中取出来时，就得到了从初态到该状态的最小代价。 如果给定一个”目标状态”，需要求出从初态到目标状态的最小代价，那么优先队列BFS的这个“优先策略”显然是 不完善 的。一个状态的当前代价最小，只能说明从初态到该状态的代价很小，而在未来的搜索中，从该状态到目标状态的可能会花费很大的代价。另外一些状态虽然当前代价略大，但是未来到目标状态的代价可能会很小，于是从起始状态到目标状态的总代价反而更优。 从 g+hg+hg+h 最短的状态出发未必能搜到最短距离，但概率一定会更大，这样就减少了对 g+hg+hg+h 较大的点的搜索，使得只搜索一部分点就可以保证搜到最短路，使运行效率大大提升。 像这样由估价函数引导的、能优先选择一些点的搜索方式称为启发式搜索。 A* 常见估价函数 在可上下左右四个方向扩展的平面图，使用曼哈顿距离作为估价函数。 欧拉距离 严谨证明 链接：A*算法证明与详解 算法本身性质一：每次队头的状态是 f(n)=g(n)+h(n)f(n)=g(n)+h(n)f(n)=g(n)+h(n) 最小的状态。而且 open list上任一具有 f(n)&lt;f∗(end)f(n)&lt;f^*(end)f(n)&lt;f∗(end) 的状态 n ，一定会在 end 出队前出队并进行扩展 。（最短路径上的点一定会在终点出队前出队） 算法本身性质二：h(n)≤h∗(n)h(n)\\le h^*(n)h(n)≤h∗(n)，预估代价小于等于实际最小代价。 首先证明：如果有解，那么算法一定可以找到终点。 有限图：边、点有限的图，无限图：边、点无限的图。 定理一：对有限图，如果从初始节点 st 到目标节点 end 有路径存在，则A*算法一定成功结束。 首先证明算法必定结束。由于搜索图为有限图，如果算法能找到解，则会成功结束；如果算法找不到解，那么必然会因为 open list 为空而结束。因此A*算法必然会结束。 然后证明算法一定会成功结束。由于至少存在一条由初始点到目标点的路径，设此路径为 Pst−end=st(v0)→v1→v2→⋯→end(vm)P_{st-end}=st(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=st(v0​)→v1​→v2​→⋯→end(vm​) 。 对于无限图，略。（算法题中都是有限图） 再证明：如果有解，算法找的解一定是最优解 。 我们利用反证法进行证明： 假设A*算法求出的不是最优解，那么我们通过A*算法寻到了一条从 st 到 end 的路径 PA∗P_{A*}PA∗​ ，而这条路径并不是最短路径。 那么存在最短路径 Pst−endP_{st-end}Pst−end​ ，有 ∣Pst−end∣&lt;∣PA∗∣|P_{st-end}|&lt;|P_{A*}|∣Pst−end​∣&lt;∣PA∗​∣。 设最短路径 Pst−end=st(v0)→v1→v2→⋯→end(vm)P_{st-end}=st(v_0)\\to v_1\\to v_2\\to \\cdots\\to end(v_m)Pst−end​=st(v0​)→v1​→v2​→⋯→end(vm​) 。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS-最小步数模型","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS-最小步数模型","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-05T02:08:43.506Z","comments":true,"path":"2021/09/02/DS_Algorithm证明与讲解/搜索/BFS/BFS-最小步数模型/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"八数码 判断是否有解 链接：八数码问题有解的条件及其推广 将矩阵从上到下从左到右的顺序分布成一个数列，并去掉空格，例如： 2 8 3 (0为空格) 分布成数列后： 1 0 4 2 8 3 1 4 7 6 5 7 6 5 如果此 初始状态的数列(矩阵) 与 目标状态的数列(矩阵) 的 逆序对数 的 奇偶性相同 ，则此问题有解。 必要性证明：若有解，逆序对数奇偶性一定相同；反之一定不同。 充分性证明：若逆序对数奇偶性相同，一定有解；反之一定无解。 状态存储 判重 康托展开 unordered_map","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS双向广搜","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS双向广搜","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-05T02:10:02.357Z","comments":true,"path":"2021/09/02/DS_Algorithm证明与讲解/搜索/BFS/BFS双向广搜/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/02/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C/","excerpt":"","text":"应用场景 最小步数模型","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"VSCode输出中文乱码如何解决","slug":"工具/VSCode/VSCode输出中文乱码","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-22T12:22:40.785Z","comments":true,"path":"2021/09/01/工具/VSCode/VSCode输出中文乱码/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E5%B7%A5%E5%85%B7/VSCode/VSCode%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"在code runner的settings中， &quot;code-runner.executorMap&quot;: &#123; // chcp 65001的作用是让终端（CMD、PowerShell）的编码格式变为UTF-8 &quot;cpp&quot;: &quot;chcp 65001 &amp;&amp; cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt.exe &amp;&amp; $dir$fileNameWithoutExt.exe&quot;,&#125;","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"工具/VSCode","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/VSCode/"}],"tags":[]},{"title":"第一章 基础：逻辑和证明","slug":"读书笔记/数学/离散数学及其应用/第一章 基础：逻辑和证明","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-18T10:11:45.821Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第一章 基础：逻辑和证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%BB%E8%BE%91%E5%92%8C%E8%AF%81%E6%98%8E/","excerpt":"","text":"本章将解释一个正确的数论证是如何组成的，并介绍构造这样的论证的工具。 我们将开发一系列不同的证明方法以「证明许多不同类型的结论」。 在介绍了多种不同证明方法后，我们将介绍一些「构造证明的策略」。 我们还将介绍猜想的概念，并通过研究来解释数学发展的过程。 命题逻辑 逻辑规则给出数学语句的准确含义，这些规则可以用来区分数学论证的有效或无效。 逻辑的基本构件——命题。命题是一个陈述语句，它的真值或真或假，但不能既真又假。（真值：真实值） 有些命题的真假目前不知道，但可以确定其真值是唯一的。（例：2050年元旦是晴天） 我们用字母来表示 命题变量（或称为语句变量），即表示命题的变量。如果一个命题是真命题，则它的真值为真，用 TTT 表示；如果它是假命题，则其真值为假，用 FFF 表示。不能用简单的命题来表示的命题称为 原子命题 。 涉及命题的逻辑领域称为 命题演算 或 命题逻辑。它最初是 2300 多年前由古希腊哲学家亚里士多德系统地创建的。 从已有命题产生新命题的方法：许多数学陈述都是由一个或多个命题组成的。由已知命题用 逻辑运算符 组合而来的新命题也被称为 复合命题 。二元逻辑运算符也称为 联结词 。 逻辑运算符 令 p、qp、qp、q 为命题， ppp 的否定记作 ¬p\\neg p¬p ，指“ 不是 ppp 所指的情形 ”。命题 ¬p\\neg p¬p 读作“ 非 ppp ”。 ¬p\\neg p¬p 的真值与 ppp 的真值相反。 p、qp、qp、q 的合取即命题“ ppp 并且 qqq ”，记作 p∧qp\\land qp∧q 。当 p、qp、qp、q 都是真命题时，p∧qp\\land qp∧q 命题为真，否则为假。 p、qp、qp、q 的析取即命题“ ppp 或 qqq ” ，记作 p∨qp\\lor qp∨q 。当 p、qp、qp、q 均为假命题时，p∨qp\\lor qp∨q 命题为假，否则为真。 p、qp、qp、q 的异或记作 p⊕qp\\oplus qp⊕q 。当 p、qp、qp、q 中只有一个为真时命题为真，否则为假。 条件语句 p→qp\\to qp→q 是命题”若 ppp ，则 qqq &quot;。当 ppp 为真而 qqq 为假时，条件语句 p→qp\\to qp→q 为假，否则为真。在条件语句 p→qp\\to qp→q 中，ppp 称为假设（前提），qqq 称为结论。等价于「 ¬p∨q\\neg p\\lor q¬p∨q 」。 双条件语句 p↔qp\\leftrightarrow qp↔q 是命题“ ppp 但且仅当 qqq ”。当 p、qp、qp、q 有同样的真值时，双条件语句为真，否则为假。双条件语句也称为 双向蕴含 。等价于：(p→q)∧(q→p)(p\\to q)\\land (q\\to p)(p→q)∧(q→p) 。 用或表示异或： p⊕q=(¬p∧q)∨(p∧¬q)p\\oplus q=(\\neg p\\land q)\\lor (p\\land\\neg q)p⊕q=(¬p∧q)∨(p∧¬q) 。 语句 p→qp\\to qp→q 称为条件语句，因为 p→qp\\to qp→q 可以判定在条件 ppp 成立时 qqq 为真。条件语句也称为 蕴含。 表达 p→qp\\to qp→q 的术语也很多：ppp 蕴含 qqq ，ppp 是 qqq 的充分条件，ppp 的必要条件是 qqq ，ppp 仅当 qqq ，qqq 除非 ¬p\\neg p¬p 对条件语句的表达方式的理解：「 ppp 仅当 qqq 」说的是当 qqq 不为真时 ppp 不能为真。也就是说，如果 ppp 为真但 qqq 为假，则这个语句为假。当 ppp 为假时，qqq 可以为真也可以为假，因为语句没有谈及 qqq 的真值。「 qqq 除非 ¬p\\neg p¬p 」：如果 ¬p\\neg p¬p 是假的，则 qqq 必是真的。也就是说，当 ppp 为真，而 qqq 为假时，语句“ qqq 除非 ¬p\\neg p¬p ”是假的，否则是真的。 表达 p↔qp\\leftrightarrow qp↔q 的术语：“ ppp 是 qqq 的充要条件”、“如果 ppp 那么 qqq ，反之亦然”、“ ppp 当且仅当 qqq ”、“ ppp 恰好当 qqq ”。当且仅当（if and only if）可以用 iff 代替。 在数学推理中我们考虑的条件语句比语言中使用的要广泛一些。条件语句作为一个数学概念不依赖于假设和结论之间的因果关系。 逆命题： 逆否命题： 反命题： 逆否命题与原命题真值相同。 逻辑运算符的优先级： 运算符 优先级 ¬\\neg¬ 1 ∧\\land∧ 2 ∨\\lor∨ 3 →\\to→ 4 ↔\\leftrightarrow↔ 5 逻辑运算和比特运算：比特是一个具有两个可能值的符号，即 0 和 1 。如果一个变量的值或真或假，则此变量称为 布尔变量 。 模糊逻辑： 命题逻辑的应用 语句翻译 系统规范说明 布尔搜索 逻辑谜题 逻辑电路 命题等价式 \\qquad数学证明中的一个重要步骤就是用真值相同的一个语句替换另一条语句。因此，从给定复合命题生成具有相同真值命题的方法广泛用于数学证明的构造。 定义：一个真值永远是真的复合命题（无论其中出现的命题变量的真值是什么），称为 永真式（ tautology ），也称为重言式。一个真值永远为假的复合命题称为 矛盾式（ contradiction ）。既不是永真式也不是矛盾式的复合命题称为 可能式（ contingency ）。 定义：如果 p↔qp\\leftrightarrow qp↔q 是永真式，则命题 p,qp,qp,q 称为是逻辑等价的。用记号 p≡qp\\equiv qp≡q 表示 p,qp,qp,q 是 逻辑等价 的。 常见等价式： 名称 等价式 双重否定律 p≡¬¬pp\\equiv \\neg\\neg pp≡¬¬p 幂等律 p≡p∨pp\\equiv p\\lor pp≡p∨p，p≡p∧pp\\equiv p\\land pp≡p∧p 交换律 p∨q≡q∨pp\\lor q\\equiv q\\lor pp∨q≡q∨p，p∧q≡q∧pp\\land q\\equiv q\\land pp∧q≡q∧p 结合律 (p∧q)∧r≡p∧(q∧r)(p\\land q)\\land r\\equiv p\\land (q\\land r)(p∧q)∧r≡p∧(q∧r) (p∨q)∨r≡p∨(q∨r)(p\\lor q)\\lor r\\equiv p\\lor (q\\lor r)(p∨q)∨r≡p∨(q∨r) 分配律 p∧(q∨r)≡(p∧q)∨(p∧r)p\\land (q\\lor r)\\equiv (p\\land q)\\lor (p\\land r)p∧(q∨r)≡(p∧q)∨(p∧r)，∧\\land∧ 对 ∨\\lor∨ 的分配律 p∨(q∧r)≡(p∨q)∧(p∨r)p\\lor (q\\land r)\\equiv (p\\lor q)\\land (p\\lor r)p∨(q∧r)≡(p∨q)∧(p∨r)，∨\\lor∨ 对 ∧\\land∧ 的分配律 德 · 摩根律 ¬(p∨q)≡¬p∧¬q\\neg(p\\lor q)\\equiv \\neg p\\land \\neg q¬(p∨q)≡¬p∧¬q，¬(p∧q)≡¬p∨¬q\\neg(p\\land q)\\equiv \\neg p\\lor \\neg q¬(p∧q)≡¬p∨¬q 吸收律 p∨(p∧q)≡pp\\lor (p\\land q)\\equiv pp∨(p∧q)≡p，p∧(p∨q)≡pp\\land(p\\lor q)\\equiv pp∧(p∨q)≡p 排中律 p∨¬q≡1p\\lor \\neg q\\equiv 1p∨¬q≡1 矛盾律 p∧¬p≡0p\\land \\neg p\\equiv 0p∧¬p≡0 归谬论 (p→q)∧(p→¬q)≡¬p(p\\to q)\\land (p\\to \\neg q)\\equiv \\neg p(p→q)∧(p→¬q)≡¬p 蕴涵等值式 p→q≡¬p∨qp\\to q\\equiv \\neg p\\lor qp→q≡¬p∨q 德 · 摩根律可以扩展为 ¬(p1∨p2∨⋯∨pn)≡(¬p1∧¬p2∧⋯∧¬pn)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\neg(p_1\\lor p_2 \\lor \\cdots\\lor p_n)\\equiv (\\neg p_1\\land\\neg p_2\\land\\cdots\\land\\neg p_n)¬(p1​∨p2​∨⋯∨pn​)≡(¬p1​∧¬p2​∧⋯∧¬pn​) ¬(p1∧p2∧⋯∧pn)≡(¬p1∨¬p2∨⋯∨¬pn)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\neg(p_1\\land p_2\\land\\cdots\\land p_n)\\equiv (\\neg p_1\\lor\\neg p_2\\lor\\cdots\\lor\\neg p_n)¬(p1​∧p2​∧⋯∧pn​)≡(¬p1​∨¬p2​∨⋯∨¬pn​) 我们有时用符号 ⋁j=1npj\\displaystyle \\bigvee_{j=1}^{n} p_jj=1⋁n​pj​ 来表示 p1∨p2∨⋯∨pnp_1\\lor p_2 \\lor \\cdots\\lor p_np1​∨p2​∨⋯∨pn​ ，用 ⋀j=1npj\\displaystyle \\bigwedge_{j=1}^{n} p_jj=1⋀n​pj​ 来表示 p1∧p2∧⋯∧pnp_1\\land p_2\\land\\cdots\\land p_np1​∧p2​∧⋯∧pn​ 。采用这种记法扩展的德 · 摩根律就可以简洁地写成 ¬(⋁j=1npj)≡⋀j=1n¬pj\\neg(\\displaystyle \\bigvee_{j=1}^{n} p_j)\\equiv \\bigwedge_{j=1}^{n}\\neg p_j¬(j=1⋁n​pj​)≡j=1⋀n​¬pj​ 和 ¬(⋀j=1npj)≡⋁j=1n¬pj\\neg(\\displaystyle \\bigwedge_{j=1}^{n} p_j)\\equiv \\bigvee_{j=1}^{n}\\neg p_j¬(j=1⋀n​pj​)≡j=1⋁n​¬pj​ 。 \\qquad有 n 个命题变量的复合命题的真值表有 2n2^n2n 行，由于随着 n 的增加，行数增加异常迅速，所以随着变量数的增加，利用真值表来建立等价式就变得不切实际。其他方法就会更快捷一些，比如利用我们已知的逻辑等价式。 可满足性 \\qquad一个复合命题称为是 可满足的，如果这个命题不是永假式。不可满足式是永假式，也就是说：一个命题是不可满足的当且仅当它的否定是永真式。 \\qquad当我们找到一个特定的使得复合命题为真的真值赋值时，就证明了它是可满足的。这样的一个赋值称为这个特定的可满足性问题的一个 解。可是，要证明一个复合命题是不可满足的，我们需要证明每一组变量的真值赋值都使其为假。 可满足性的应用 \\qquad在机器人学、软件测试、人工智能规划、计算机辅助设计、机器视觉、集成电路分析、计算机网络以及遗传学等不同的领域中许多问题都可以用命题的可满足性来建立模型。 n 皇后问题 \\qquadnnn 皇后问题要求在一个 n×nn\\times nn×n 的棋盘上放置 nnn 个皇后，目的是使皇后之间可以共存，即任意两个皇后不能在同一列、同一行或同一对角线上。（八皇后问题于 1848 年由 Max Bezzel 提出，由 Franz Nauck 在 1850 年彻底解决。 数独 可满足性问题求解 \\qquad当许多应用建模涉及成千上万个变量的复合命题的可满足性时，问题就来了。当变量数为 1000 时，要检查 210002^{1000}21000 种（这是一个超过 300 位的十进制数）可能的真值组合中的每一种，一台计算机在几万亿年之内都不可能完成。 \\qquad迄今尚没有其他已知的计算过程能使计算机在合理的时间之内判定变量数这么大的复合命题是否为可满足式。 \\qquad可是，在实际应用中某些特定类型的复合命题的可满足性问题求解方法还是有一些进展，比如数独迷题的求解。已经开发出许多计算机程序可以用来求解有实际应用的可满足性问题。 \\qquad在第 3 章讨论算法主题时，我们将进一步讨论这个问题。特别是，我们将解释命题的可满足性问题在算法复杂度学习中扮演的重要角色。 谓词和量词 \\qquad在 1.1~1.3 节中所学习的命题逻辑不能表达数学语言和自然语言中所有语句的确切意思。本节我们将介绍一种表达能力更强的逻辑，即 谓词逻辑。为了理解谓词逻辑，我们首先需要介绍谓词的概念，之后我们将介绍量词的概念。它可以让我们对这样的语句进行推理：某一性质对于某一类型的所有对象均成立，存在一个对象使得某一特性成立。 \\qquad语句“ x 大于 3”有两个部分。第一部分即变量 x 是语句的主语。第二部分（ 谓词 “大于 3”）表明语句的主语具有的一个性质。我们可以用 P(x)P(x)P(x) 表示语句“ x &gt; 3”，其中 PPP 表示谓词“大于 3”，而 x 是变量。语句 P(x)P(x)P(x) 也可以说成是命题函数 PPP 在 x 的值。一旦给变量 x 赋一个值，语句 P(x)P(x)P(x) 就成为命题且具有真值。 \\qquad有些语句还可以含有不止一个变量。例如，考虑语句“x = y + 3”。我们可以用 Q(x,y)Q(x,y)Q(x,y) 表示这个语句，其中 x , y 为变量，QQQ 为谓词。当 x , y 被赋值时，语句 Q(x,y)Q(x,y)Q(x,y) 就有真值了。 \\qquad一般地，涉及 n 个变量 x1,x2,⋯ ,xnx_1,x_2,\\cdots,x_nx1​,x2​,⋯,xn​ 的语句可以表示成 P(x1,x2,⋯ ,xn)P(x_1,x_2,\\cdots,x_n)P(x1​,x2​,⋯,xn​) 。形式为 P(x1,x2,⋯ ,xn)P(x_1,x_2,\\cdots,x_n)P(x1​,x2​,⋯,xn​) 的语句是 命题函数 PPP 在 n 元组 (x1,x2,⋯ ,xn)(x_1,x_2,\\cdots,x_n)(x1​,x2​,⋯,xn​) 的值，PPP 也称为 n位谓词 或 n元谓词。 \\qquad量化 也可以从命题函数生成一个命题。量化表示在何种程度上谓词对于一定范围的个体成立。在自然语言中，“所有、某些、没有、少量“这些词都可以用在量化上。这里我们集中讨论两类量化：全称量化，它告诉我们一个谓词对所考虑范围内的每一个体都为真；存在量化，它告诉我们一个谓词对所考虑范围内的一个或多个个体为真。处理谓词和量词的逻辑领域称为 谓词演算。 命题 什么时候为真 什么时候为假 ∀x P(x)\\forall x\\ P(x)∀x P(x) 对每个 x，P(x)P(x)P(x) 都为真 存在 x，使 P(x)P(x)P(x) 为假 ∃x P(x)\\exists x\\ P(x)∃x P(x) 存在 x，使 P(x)P(x)P(x) 为真 对每个 x，P(x)P(x)P(x) 都为假 全称量词：许多数学命题断言某一性质对于变量在某一特定域内的所有值都为真，这一特定域称为变量的 论域（domain of discourse）（或 全体域（universe of discourse）），时常简称为 域（domain）。这类语句可以用全称量化表示。对特定论域而言 P(x)P(x)P(x) 的全称量化是这样一个命题：它断言 P(x)P(x)P(x) 对 x 在其论域中的所有值均为真。注意，论域规定了变量 x 所有可能取的值。当论域改变时， P(x)P(x)P(x) 的全称量化的意义也随之改变。在使用全称量词时必须指定论域，否则语句的全称量化就是无定义的。 定义：P(x)P(x)P(x) 的全称量化是语句” P(x)P(x)P(x) 对 x 在其论域的所有值为真“ ，用符号 ∀x P(x)\\forall x\\ P(x)∀x P(x) 来表示，其中 $\\forall $ 称为全称量词。命题 ∀x P(x)\\forall x\\ P(x)∀x P(x) 读作 ”对所有 x ，P(x)P(x)P(x) “。一个使 P(x)P(x)P(x) 为假的个体称为 ∀x P(x)\\forall x\\ P(x)∀x P(x) 的反例。 存在量词： 嵌套量词 推理规则 证明导论 证明的方法和策略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第三章 算法","slug":"读书笔记/数学/离散数学及其应用/第三章 算法","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:45:51.656Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第三章 算法/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法 函数的增长 算法的复杂度","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第九章 关系","slug":"读书笔记/数学/离散数学及其应用/第九章 关系","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:47:50.667Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第九章 关系/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%85%B3%E7%B3%BB/","excerpt":"","text":"关系及其性质 nnn原关系及其应用 关系的表示 关系的闭包 等价关系 偏序","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第二章 基本结构：集合、函数、序列、求和与矩阵","slug":"读书笔记/数学/离散数学及其应用/第二章 基本结构：集合、函数、序列、求和与矩阵","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:43:51.617Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第二章 基本结构：集合、函数、序列、求和与矩阵/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%9A%E9%9B%86%E5%90%88%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%BA%8F%E5%88%97%E3%80%81%E6%B1%82%E5%92%8C%E4%B8%8E%E7%9F%A9%E9%98%B5/","excerpt":"","text":"集合 集合运算 函数 序列与求和 集合的基数 矩阵","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第五章 归纳与递归","slug":"读书笔记/数学/离散数学及其应用/第五章 归纳与递归","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:45:14.475Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第五章 归纳与递归/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"数学归纳法 强归纳法与良序性 递归定义与结构归纳法 递归算法 程序正确性","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第八章 高级计数技术","slug":"读书笔记/数学/离散数学及其应用/第八章 高级计数技术","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:29:59.764Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第八章 高级计数技术/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E8%AE%A1%E6%95%B0%E6%8A%80%E6%9C%AF/","excerpt":"","text":"递推关系的应用 求解线性递推关系 分治算法和递推关系 生成函数 容斥 容斥原理的应用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第六章 计数","slug":"读书笔记/数学/离散数学及其应用/第六章 计数","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:07.723Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第六章 计数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%AE%A1%E6%95%B0/","excerpt":"","text":"计数的基础 鸽巢原理 排列与组合 二项式系数和恒等式 排列与组合的推广 生成排列和组合","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十一章 树","slug":"读书笔记/数学/离散数学及其应用/第十一章 树","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:14.118Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第十一章 树/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%A0%91/","excerpt":"","text":"树的概述 树的应用 树的遍历 生成树 最小生成树","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十二章 布尔代数","slug":"读书笔记/数学/离散数学及其应用/第十二章 布尔代数","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:42.190Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第十二章 布尔代数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0/","excerpt":"","text":"布尔函数 布尔函数的表示 逻辑门电路 电路的极小化","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"第十章 图","slug":"读书笔记/数学/离散数学及其应用/第十章 图","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T14:30:21.328Z","comments":true,"path":"2021/09/01/读书笔记/数学/离散数学及其应用/第十章 图/","link":"","permalink":"http://xiaoke-jin.github.io/2021/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%9B%BE/","excerpt":"","text":"图和图模型 图的术语和几种特殊的图 图的表示和图的同构 连通性 欧拉通路与哈密顿通路 最短通路问题 平面图 图着色","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"","slug":"Windows/鼠标右键菜单设置","date":"2021-08-31T13:01:39.022Z","updated":"2021-08-31T13:02:32.204Z","comments":true,"path":"2021/08/31/Windows/鼠标右键菜单设置/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/31/Windows/%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"增加和删除win右键的Open Folder as PyCharm Project，Jetbrains系列","categories":[],"tags":[]},{"title":"","slug":"读书笔记/数学/初等数论及其应用/第二章 整数的表示法和运算","date":"2021-08-23T03:26:59.246Z","updated":"2021-09-01T06:29:40.494Z","comments":true,"path":"2021/08/23/读书笔记/数学/初等数论及其应用/第二章 整数的表示法和运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第三章 素数和最大公因子","slug":"读书笔记/数学/初等数论及其应用/第三章 素数和最大公因子","date":"2021-08-22T16:00:00.000Z","updated":"2021-11-02T07:43:12.028Z","comments":true,"path":"2021/08/23/读书笔记/数学/初等数论及其应用/第三章 素数和最大公因子/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B4%A0%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/","excerpt":"","text":"大纲 要点：素数无穷，素数分布（素数定理），唯一分解定理，最大公因子，欧几里得算法，整数分解，费马数，丢番图方程。 尽管数学家做了几百年的努力，仍有关于素数的许多问题未被解决。 我们将选取讨论其中的一些，包括最著名的两个：孪生素数猜想 和 哥德巴赫（Goldbach）猜想。 在数论中常常研究具有特殊形式的数。本章中，我们将介绍 费马数 ，即形如 2n+12^n+12n+1 的整数。（费马猜想它们都是素数，但是这被证明是不对的）。 最后，我们将介绍 丢番图方程，它是只考虑整数解的方程。 我们将证明如何用最大公因子来帮助求解 线性丢番图方程。 与其他丢番图方程不同，线性丢番图方程能够容易地系统解决。 3.1 素数 定义：素数是大于 111 的正整数，并且除了 111 和它本身外不能被其他正整数所整除。 定义：大于 111 的不是素数的正整数称为合数。 本节将讨论 给定正整数集中素数的分布 并 证明该分布的一些基础性质 。同时还将讨论关于素数分布的一些更强的结论。 在我们将要介绍的定理中包含了数论中一些最著名的结论。 「素数的无限性」：我们从证明有无穷多个素数开始，为此需要下面的引理。 我们将在本章的后面介绍一些证明素数无穷性的其他方法。（见这一节末尾的习题8以及3.3、3.5和3.6节的习题）。 引理 3.1-每个大于 1 的正整数都有一个素因子 引理3.1：每个大于 111 的正整数都有一个素因子。 证明：反证法。假设存在一个大于 1 的正整数没有素因子，那么大于 1 且没有素因子的正整数构成的集合非空，由良序性知集合中存在一个大于 1 且没有素因子的最小正整数 nnn 。由于 nnn 能被 nnn 整除且 nnn 没有素因子，因此 nnn 不是素数。于是 nnn 可以写成 n=a×bn=a\\times bn=a×b ，其中 1&lt;a&lt;n1&lt;a&lt;n1&lt;a&lt;n ，1&lt;b&lt;n1&lt;b&lt;n1&lt;b&lt;n 。因为 a&lt;na&lt;na&lt;n ，所以 aaa 一定有素因子。由定理 1.8，aaa 的任何因子也是 nnn 的因子，因此 nnn 必有素因子。与假设矛盾。所以我们就得到结论：任何一个大于 111 的正整数至少有一个素因子。 定理 3.1-素数无限性 定理3.1：存在无穷多个素数。 证明：假设只有有限个素数 p1,p2,⋯ ,pnp_1,p_2,\\cdots,p_np1​,p2​,⋯,pn​ ，其中 nnn 是正整数，考虑整数 Qn=p1p2⋯pn+1Q_n=p_1p_2\\cdots p_n+1Qn​=p1​p2​⋯pn​+1 。由引理 3.1， QnQ_nQn​ 至少有一个素因子，设为 qqq 。如果 q=pjq=p_jq=pj​ ，其中 jjj 为某个整数且 1≤j≤n1\\le j\\le n1≤j≤n 。由于 Qn−p1p2⋯pn=1Q_n-p_1p_2\\cdots p_n=1Qn​−p1​p2​⋯pn​=1 ，且 qqq 可以整除 QnQ_nQn​，p1p2⋯pnp_1p_2\\cdots p_np1​p2​⋯pn​ ，因此由定理 1.9， q∣1q\\mid 1q∣1 。这显然是不可能的，因为 1 不能被任何素数整除。于是 qqq 不是 pjp_jpj​ 的任何一个。这与假设矛盾。 证毕。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理 3.1 的证明过程不是构造性的，因为我们在证明中构造的整数 QnQ_nQn​（由前 nnn 个素数的积加 1 得到）可以是素数也可以不是（见习题11）。因此，在证明过程中我们只是知道存在一个新的素数但是并没有求得它。 求素数：在下面的章节中，我们将把兴趣放在 如何求大素数 和 使用大素数 上。 定理 3.2 合数必有一个小于等于 sqrt(n) 的素因子 将素数和合数加以区分的测试是至关重要的，这种测试叫做 素性检验。最基本的素性检验是「试除法」。 bool is_prime()&#123; for(int i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false;y &#125; return true;&#125; 定理3.2：如果 nnn 是一个合数，那么 nnn 一定有一个不超过 n\\sqrt{n}n​ 的素因子。 证明：既然 nnn 是合数，那么 nnn 可以写成 n=a×bn=a\\times bn=a×b，其中 a, b 为整数且 1&lt;a≤b&lt;n1&lt;a≤b&lt;n1&lt;a≤b&lt;n 。 我们一定有 a≤na\\le \\sqrt{n}a≤n​ ，否则若 b≥a&gt;nb\\ge a&gt;\\sqrt{n}b≥a&gt;n​，那么有 a×b&gt;n×n=na\\times b&gt;\\sqrt{n}\\times\\sqrt{n}=na×b&gt;n​×n​=n 。由引理3.1，aaa 至少有一个素因子，再由定理1.8，aaa 的因子一定也是 nnn 的因子，显然这个因子小于等于 n\\sqrt{n}n​ 。 证毕。 ■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 给定一个正整数 nnn ，使用定理 3.2 可以找到所有小于等于 nnn 的素数。这种方法就是「埃拉托色尼斯筛法」。 int primes[1000], cnt;bool is_prime[1000];for(int i = 2; i &lt;= n; i++)&#123; if(is_primes[i]) continue; primes[++cnt] = i; if(i &lt;= sqrt(n)) &#123; // 使用小于等于sqrt(n)的所有质数即可 for(int j = i * i; j &lt;= n; j += i) is_primes[j] = true; &#125;&#125; 对于一个特定的整数 nnn ，我们将在后面给出一个更好的方法来判断一个整数是否是素数，即定理 6.11。 定理 3.3 狄利克雷 定理3.3（狄利克雷关于「等差数列中素数的定理」）：假设 a,ba,ba,b 是互素的整数，那么等差数列 an+b (n=1,2,3,⋯ )an+b\\ (n=1,2,3,\\cdots)an+b (n=1,2,3,⋯) 包含了无穷多的素数。 目前为止狄利克雷定理没有简单的证法。（狄利克雷的原始证明使用了复变量。后来爱尔迪希（Erdos）和塞尔伯格（Selberg）在 20世纪 50年代给出了一个初等但较复杂的证明）。 但是狄利克雷定理的一些特例很容易证。我们将通过在 3.5 节中证明有无穷多个 4n+34n+34n+3 型的素数来说明这一点。 已知的最大素数：在近千百年的历史中，数学家和一些数学爱好者们总是试图找到一个比已知的最大素数更大的素数。一个人会因为找到这样的素数而至少在当时一举成名，并且他或她的名字也将被载入史册。因为有无穷多的素数，因而总有素数比当时的已知最大素数要大。寻找新素数也有一些系统化的方法。人们并不是随机挑选一些数来检验其是否为素数，而是选取一些特殊形式的数。例如，我们将在第7章中讨论具有 2p−12^p-12p−1 形式的素数，其中是 ppp 素数；这种数被称为 梅森素数（Mersenne primes）。我们将看到用一种特殊的测试可以检验出 2p−12^p-12p−1 是否为素数，而不需要用试除法。过去几百年中多数时间里最大的素数一直是梅森素数。目前已知的最大素数的世界纪录是 243 112 609−12^{43\\ 112\\ 609}-1243 112 609−1 。 素数公式 是否有一个公式只产生素数呢？ 关于一个变元的多项式没有这种性质，习题23证明了这一点。同样，关于 nnn 个变元的多项式不能只产生素数，其中 nnn 是一个正整数（这个结论超出了本书的范围）。 有一些可以只产生素数的公式但是不实用。例如，米尔斯（Mills）证明了存在一个常数 Θ\\varThetaΘ 使得函数 f(n)=[Θ3n]f(n)=[\\varTheta^{3^n}]f(n)=[Θ3n] 只生成素数，我们只知道 Θ\\varThetaΘ 的近似值 Θ≈1.3064\\varTheta\\approx1.3064Θ≈1.3064 。 如果没有一个实用的公式可以产生大素数，那么怎么才能生成它们呢？在第6章中将介绍如何用概率素性检验法来生成大素数。 素性证明 在 广义黎曼猜想 成立的条件下，米勒（G. L. Miller）于1975年给出了一个可用 O((log⁡n)5)O((\\log{n})^5)O((logn)5) 次位运算来证明一个整数是素数的算法。但可惜的是，广义黎曼猜想到现在尚未被证明。 ★\\bigstar★ 由于广义黎曼猜想并没有被证明，其后由Michael O. Rabin教授作出修改，提出了不依赖于该假设的 随机化算法。 在1983年，Leonard Adleman、Carl Pomerance和Robert Rumely建立了一个计算复杂度为 (log⁡n)c log⁡log⁡log⁡n(\\log n)^{c\\ \\log\\log\\log{n}}(logn)c logloglogn 的算法，其中 ccc 是常数。 虽然他们的算法不是 多项式时间 ，但是它已经接近多项式时间了，因为 log⁡log⁡log⁡n\\log\\log\\log{n}logloglogn 增长得非常慢。 使用他们的算法结合现在的计算机确定一个100位的整数是否为素数只需几毫秒，确定一个400位的整数是否为素数用时不超过 1 秒，而确定一个1000位的整数是否为素数用时少于一个小时。 素性验证的多项式时间算法 2002年，一位印度计算机教授 我们现在只是讨论了素性检验中的「确定性算法」（deterministic algorithms），即用来确定一个整数是否为素数的算法。 在第6章中我们将讨论 概率素性检验法，即 米勒-拉宾算法，定理6.11 。这个测试将告诉我们一个整数有很高的可能性是素数，但并不确定其为素数。 3.2 素数的分布 在18世纪后期，数学家们通过手算建立了素数表。通过这些数值，他们开始寻找函数来估计 π(x)\\pi(x)π(x) 。 定理 3.4-素数定理 定义：函数 π(x)\\pi(x)π(x) 表示不超过 xxx 的素数的个数，其中 xxx 是正实数。 定理3.4（素数定理）：随着 xxx 的无限增长，π(x)\\pi(x)π(x) 和 xln⁡x\\dfrac{x}{\\ln{x}}lnxx​ 的比趋于 111。 如果用极限的语言来表述，我们有 lim⁡x→∞π(x)(x/ln⁡x)=1\\lim\\limits_{x \\to \\infty} \\dfrac{\\pi(x)}{(x/\\ln x)}=1x→∞lim​(x/lnx)π(x)​=1。 用一个简单的方法来表述素数定理是写成 π(x)∽xln⁡x\\pi(x)\\backsim\\dfrac{x}{\\ln{x}}π(x)∽lnxx​。这里符号 ∽\\backsim∽ 表示渐进于。 推论 3.4.1 第 n 个素数的大小 推论3.4.1：令 pnp_npn​ 是第 nnn 个素数，其中 nnn 是正整数，那么 pn∽nlog⁡np_n\\backsim n\\log npn​∽nlogn ，即第 nnn 个素数渐进于 log⁡n\\log{n}logn 。 随机选到素数的概率 如果随机地选择一个正整数，那么它是素数的概率有多大呢？ 定理 3.5 定理3.5：对于任意的正整数 nnn，存在至少 nnn 个连续的正合数。 证明： 关于素数的猜想 伯兰特猜想； 「孪生素数猜想」； 「哥德巴赫猜想」：每个大于 222 的正偶数可以写成两个素数的和。 素数等差数列的「厄尔多斯猜想」：对任意的正整数 n≥3n\\ge 3n≥3，有一个由素数组成的长度为 nnn 的等差数列。 2006年Ben Green和陶哲轩取得了突破性进展从而证明了该猜想。 n2+1n^2+1n2+1 猜想：存在无穷多个形如 n2+1n^2+1n2+1 的素数，其中 nnn 是正整数。 勒让德猜想 3.3 最大公因子及其性质 定理 3.6 定理3.6 ：a,ba,ba,b 是整数，且 (a,b)=d(a,b)=d(a,b)=d ，那么 (ad,bd)=1(\\dfrac{a}{d},\\dfrac{b}{d})=1(da​,db​)=1 。（换言之，a/da/da/d 与 b/db/db/d 互素）。 证明：假设还有其他正整数 eee 使得 e∣(a/d)e\\mid (a/d)e∣(a/d) 且 e∣(b/d)e\\mid (b/d)e∣(b/d) ，那么存在整数 kkk 和 lll 使得 a/d=kea/d=kea/d=ke ，b/d=leb/d=leb/d=le ，于是 a=dkea=dkea=dke ，b=dleb=dleb=dle 。因此 dedede 是 a,ba,ba,b 的公因子。因为 ddd 是 a,ba,ba,b 的最大公因子，故 de⩽dde\\leqslant dde⩽d ，于是 e=1e=1e=1 。因此 (ad,bd)=1(\\dfrac{a}{d},\\dfrac{b}{d})=1(da​,db​)=1 。 推论 3.6.1 如果 (p ,q)=1(p\\ ,q)=1(p ,q)=1 ，则分数 p/qp/qp/q 被称为既约分数。 下面的推论告诉我们每一个分数都与另一个既约分数相等。 推论3.6.1：如果 a,ba,ba,b 为整数，且 b≠0b\\neq 0b=0 ，则 ab=pq\\dfrac{a}{b}=\\dfrac{p}{q}ba​=qp​ ，其中 p,qp,qp,q 为整数，且 (p,q)=1,q≠0(p,q)=1,q\\neq 0(p,q)=1,q=0 。 证明：假设 a,ba,ba,b 为整数且 b≠0b\\ne 0b=0 ，令 p=a/dp=a/dp=a/d ，q=b/dq=b/dq=b/d ，其中 d=(a,b)d=(a,b)d=(a,b) ，则 p/q=(a/d)/(b/d)p/q=(a/d)/(b/d)p/q=(a/d)/(b/d) 。由定理 3.6 可知 (p,q)=1(p,q)=1(p,q)=1 。 定理 3.7 (a,b)=(a+cb,b) 定理3.7：令 a,b,ca,b,ca,b,c 是整数，那么 (a,b)=(a+cb,b)(a,b)=(a+cb,b)(a,b)=(a+cb,b) 。 证明：令 eee 是 a,ba,ba,b 的公因子，由定理 1.9 可知 e∣a+cbe\\mid a+cbe∣a+cb ，所以 eee 是 a+cba+cba+cb 和 bbb 的公因子。如果 fff 是 a+cba+cba+cb 和 bbb 的公因子，那么由定理 1.9 可知 fff 整除 (a+cb)−cb=a(a+cb)-cb=a(a+cb)−cb=a ，所以 fff 是 a,ba,ba,b 的公因子。即 a,ba,ba,b 的公因子与 a+cb,ba+cb,ba+cb,b 的公因子相同。因此 (a+cb,b)=(a,b)(a+cb,b)=(a,b)(a+cb,b)=(a,b) 。 定理 3.8 gcd与线性组合 定义：如果 a,ba,ba,b 是整数，那么它们的 线性组合 具有形式 ma+nbma+nbma+nb ，其中 m,nm,nm,n 都是整数。 定理3.8：两个不全为零的整数 a,ba,ba,b 的最大公因子是 a,ba,ba,b 的线性组合中 最小 的正整数。 证明： 令 ddd 是 a,ba,ba,b 的线性组合中最小的正整数。（因为当 a≠0a\\neq 0a=0 时，两个线性组合 1×a+0×b1\\times a+0\\times b1×a+0×b 和 0×a+1×b0\\times a+1\\times b0×a+1×b 中必有一个为正，因此根据良序性，存在最小的正整数）。 我们有 d=ma+nbd=ma+nbd=ma+nb ，其中 m,nm,nm,n 是整数 。\\qquad\\qquad （1） 我们先证明 d∣ad\\mid ad∣a ， d∣bd\\mid bd∣b 。 由带余除法，得到 a=dq+ra=dq+ra=dq+r，0≤r&lt;d0\\le r&lt;d0≤r&lt;d 。由这个方程和（1）可以得到 r=a−dq=a−q(ma+nb)=(1−mq)a−qnbr=a-dq=a-q(ma+nb)=(1-mq)a-qnbr=a−dq=a−q(ma+nb)=(1−mq)a−qnb 。这就证明了整数 rrr 是 a,ba,ba,b 的线性组合。因为 0≤r&lt;d0\\le r&lt;d0≤r&lt;d 且 ddd 是 a,ba,ba,b 的线性组合中最小的正整数，于是我们得到 r=0r=0r=0，因此 d∣ad\\mid ad∣a 。同理可得 d∣bd\\mid bd∣b 。 接下来证明它是 a,ba,ba,b 的最大公因子。为此只需证明 a,ba,ba,b 所有的公因子 ccc 都可整除 ddd 。 由于 d=ma+nbd=ma+nbd=ma+nb ，因此如果 c∣ac\\mid ac∣a 且 c∣bc\\mid bc∣b ，那么由定理 1.9 有 c∣dc\\mid dc∣d ，因此 d≥cd\\ge cd≥c 。 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 推论 3.8.1 贝祖定理 推论3.8.1（Bezout，贝祖定理）：如果 a,ba,ba,b 均为整数，则有整数 m,nm,nm,n ，使得 ma+nb=gcd⁡(a,b)ma+nb=\\gcd(a,b)ma+nb=gcd(a,b) 。 虽然该推论被称作是 Bezout 定理，但多年以前 Claude Gaspar Bachet 已经证明了该结果。 方程 ma+nb=(a,b)ma+nb=(a,b)ma+nb=(a,b) 被称为 Bezout 等式，对给定的整数 a,ba,ba,b 满足该等式的整数 m,nm,nm,n 被称为是 a,ba,ba,b 的 Bezout 系数或 Bezout 数。 推论 3.8.2 推论3.8.2：整数 a,ba,ba,b 互素当且仅当存在整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 。（充要条件的证明） 证明：若 (a,b)=1(a,b)=1(a,b)=1 。由定理 3.8 可知，1 是 a,ba,ba,b 的线性组合的最小正整数。于是存在整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 。反之，如果有整数 m,nm,nm,n 使得 ma+nb=1ma+nb=1ma+nb=1 ，则由定理 3.8 可得 (a,b)=1(a,b)=1(a,b)=1 。这是由于 a,ba,ba,b 不为 0 且 1 显然是 a,ba,ba,b 的线性组合中的最小正整数。 定理 3.9 线性组合与gcd的倍数 定理3.9：如果 a, ba,\\ ba, b 是正整数，那么所有 a, ba,\\ ba, b 的线性组合构成的集合与所有 (a, b)(a,\\ b)(a, b) 的倍数构成的集合相同。 证明： 假设 d=(a, b)d=(a,\\ b)d=(a, b) ， 我们首先证明每个 a,ba,ba,b 的线性组合是 ddd 的倍数。 我们现在证明每一个 ddd 的倍数也是 a,ba,ba,b 的线性组合。 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理 3.10 一种定义gcd的方式 不依赖于整数的有序性定义最大公因子。 定理3.10：如果 a,ba,ba,b 是不全为 000 的整数，那么正整数 ddd 是 a,ba,ba,b 的最大公因子，当且仅当 \\qquad\\qquad（i） d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b； \\qquad\\qquad（ii） 如果 ccc 是整数且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b ，那么 c∣dc\\mid dc∣d； 证明：\\qquad假设 d=(a,b)d=(a,b)d=(a,b) ， 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 引理 3.2 多个数的最大公因子 定义：令 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 是不全为零的整数。这些整数的公因子中最大的整数就是最大公因子。 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 的最大公因子记为 (a1,a2,a3,…,an)(a_1,a_2,a_3,\\dots,a_n)(a1​,a2​,a3​,…,an​) 。（注意 aia_iai​ 在这里面出现的顺序不影响结果） 引理3.2：如果 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​ 是不全为零的整数，那么 (a1,a2,a3,…,an)=(a1,a2,a3,…,(an−1,an))(a_1,a_2,a_3,\\dots,a_n)=(a_1,a_2,a_3,\\dots,(a_{n-1},a_n))(a1​,a2​,a3​,…,an​)=(a1​,a2​,a3​,…,(an−1​,an​)) 。 互素，两两互素 3.4 欧几里得算法 引理 3.3 (a，b) = (b，a % b) 引理3.3：如果 e,de,de,d 是整数且 e=dq+re=dq+re=dq+r ，其中 q,rq,rq,r 是整数，那么 (e,d)=(d,r)(e,d)=(d,r)(e,d)=(d,r) 。 证明：在定理 3.7 中，取 a=ra=ra=r ， b=db=db=d ， c=qc=qc=q 即得到该引理。 定理 3.11 欧几里得算法 定理3.11（欧几里得算法） 证明：令 r0=ar_0=ar0​=a ，r1=br_1=br1​=b 是正整数且满足 a⩾ba\\geqslant ba⩾b ，那么通过连续运用带余除法，我们求得 r0=r1q1+r20⩽r2&lt;r1,r1=r2q2+r30⩽r3&lt;r2, ⋮rj−2=rj−1qj−1+rj0⩽rj&lt;rj−1, ⋮rn−4=rn−3qn−3+rn−20⩽rn−2&lt;rn−3,rn−3=rn−2qn−2+rn−10⩽rn−1&lt;rn−2,rn−2=rn−1qn−1+rn 0⩽rn&lt;rn−1,rn−1=rnqn\\begin{align*} r_0&amp;=r_1q_1+r_2\\qquad\\qquad 0\\leqslant r_2&lt;r_1,\\\\ r_1&amp;=r_2q_2+r_3\\qquad\\qquad 0\\leqslant r_3&lt;r_2,\\\\ \\qquad&amp;\\ \\ \\vdots\\\\ r_{j-2}&amp;=r_{j-1}q_{j-1}+r_j\\qquad 0\\leqslant r_j&lt;r_{j-1},\\\\ \\qquad&amp;\\ \\ \\vdots\\\\ r_{n-4}&amp;=r_{n-3}q_{n-3}+r_{n-2}\\qquad 0\\leqslant r_{n-2}&lt;r_{n-3},\\\\ r_{n-3}&amp;=r_{n-2}q_{n-2}+r_{n-1}\\qquad 0\\leqslant r_{n-1}&lt;r_{n-2},\\\\ r_{n-2}&amp;=r_{n-1}q_{n-1}+r_{n}\\qquad\\ \\ \\ \\ 0\\leqslant r_n&lt;r_{n-1},\\\\ r_{n-1}&amp;=r_nq_n \\end{align*} r0​r1​rj−2​rn−4​rn−3​rn−2​rn−1​​=r1​q1​+r2​0⩽r2​&lt;r1​,=r2​q2​+r3​0⩽r3​&lt;r2​, ⋮=rj−1​qj−1​+rj​0⩽rj​&lt;rj−1​, ⋮=rn−3​qn−3​+rn−2​0⩽rn−2​&lt;rn−3​,=rn−2​qn−2​+rn−1​0⩽rn−1​&lt;rn−2​,=rn−1​qn−1​+rn​ 0⩽rn​&lt;rn−1​,=rn​qn​​ 可以确定最后一定会有一个余数为零，这是因为余数组成的序列 a=r0⩾r1&gt;r2&gt;r3&gt;⋯⩾0a=r_0\\geqslant r_1&gt;r_2&gt;r_3&gt;\\cdots\\geqslant 0a=r0​⩾r1​&gt;r2​&gt;r3​&gt;⋯⩾0 所包含的项的个数不会大于 aaa （因为每个余数都是整数），由引理 3.3，我们得到 (a,b)=(r0,r1)=(r1,r2)=(r2,r3)=⋯=(rn−2,rn−1)=(rn−1,rn)=(rn,0)(a,b)=(r_0,r_1)=(r_1,r_2)=(r_2,r_3)=\\cdots=(r_{n-2},r_{n-1})=(r_{n-1},r_{n})=(r_n,0)(a,b)=(r0​,r1​)=(r1​,r2​)=(r2​,r3​)=⋯=(rn−2​,rn−1​)=(rn−1​,rn​)=(rn​,0) ，因此 (a,b)=rn(a,b)=r_n(a,b)=rn​ ，这是最后一个非零余数。 int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 欧几里得算法是一种快速地求最大公因子的方法。接下来，当我们用欧几里得算法求两个正整数的最大公因子来估算 除法的最大步数 时会看到这一点。 定理 3.12 斐波那契与欧几里得 用欧几里得算法来求斐波那契序列中连续项的最大公因子的速度很慢，因为除了最后一步，其余的每一步的商都是1 。 下面的定理将告诉我们用欧几里得算法求斐波那契序列中连续两项的最大公因子需要多少步除法。 定理3.12：令 fn+1f_{n+1}fn+1​ 和 fn+2 (n&gt;1)f_{n+2}\\ \\ (n&gt;1)fn+2​ (n&gt;1) 是斐波那契数列中连续的两项，那么用欧几里得算法证明 (fn+1,fn+2)=1(f_{n+1},f_{n+2})=1(fn+1​,fn+2​)=1 一共需要 nnn 步除法。证明： 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 欧几里得算法的计算复杂度 定理 3.13 欧几里得算法的高效性 定理3.13（拉梅定理）：用欧几里得算法计算两个正整数的最大公因子时，所需的除法次数不会超过两个整数中较小的那个十进制的位数的 5 倍。 证明： 拉梅定理的推论，它告诉我们 欧几里得算法是非常高效的 。 推论3.13.1：求两个正整数 a,ba,ba,b，a&gt;ba&gt;ba&gt;b 的最大公因子需要 O((log⁡2a)3)O((\\log_2a)^3)O((log2​a)3) 次的位运算。 证明： 定理 3.14（扩欧） 用线性组合的方式来表示最大公因子 如果已经求得 ，那么因为 ， 我们有 从 到 ，最终 这显示了如何沿着欧几里得算法产生的等式递进最终使得 a,ba,ba,b 的最大公因子 (a,b)(a,b)(a,b) 可以表示为 a,ba,ba,b 的线性组合。 自底向上计算 扩展欧几里得算法 只需用一次欧几里得算法就能计算出 (a,b)(a,b)(a,b) 。 然而写算法时，由于使用递归，倒推回去也可。 若使用以下方法。若输入数据不满足被除数大于除数，答案错误。 扩展欧几里得算法（自顶向下计算） 定理 3.14：令 (a,b)(a,b)(a,b) 是正整数，那么 rn=(a,b)=sna+tnbr_n=(a,b)=s_na+t_nbrn​=(a,b)=sn​a+tn​b ，其中 sn,tns_n,t_nsn​,tn​ 是下面定义的递归序列的第 nnn 项： 且 ， 其中 j=2,3,⋯ ,nj=2,3,\\cdots,nj=2,3,⋯,n ，而 qjq_jqj​ 是欧几里得算法求 (a.b)(a.b)(a.b) 时每一步的商。 证明：我们将证明 ， (3.2) 因为 ，一旦等式(3.2)成立，我们就有 。 我们用第二数学归纳原理来证明。 对于 ，有 。因此对 成立。类似地， ，所以对于 成立。 现在假设 ，对于 成立。那么由欧几里得算法的第 步，我们有 由归纳假设，得到 证毕。■\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 3.5 算术基本定理 为了证明算术基本定理中分解的唯一性，我们需要先介绍两个引理。 引理 3.4 引理3.4：如果 a,b,ca,b,ca,b,c 是正整数，满足 (a,b)=1(a,b)=1(a,b)=1 且 a∣bca\\mid bca∣bc ，则 a∣ca\\mid ca∣c 。 证明：由于 (a,b)=1(a,b)=1(a,b)=1 ，存在整数 xxx 使得 ax+by=1ax+by=1ax+by=1 。等式两边同时乘以 ccc ，得 acx+bcy=cacx+bcy=cacx+bcy=c 。根据定理 1.9 得 a∣(acx+bcy)a\\mid (acx+bcy)a∣(acx+bcy)，这是因为这是 a,bca,bca,bc 的线性组合，而它们都可以被 aaa 整除。因此 a∣ca\\mid ca∣c 。 引理 3.5 引理3.5：如果 p∣a1a2⋯anp\\mid a_1a_2\\cdots a_np∣a1​a2​⋯an​ ，其中 ppp 为素数，且 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 是正整数，则存在整数 i, 1⩽i⩽ni,\\ 1\\leqslant i\\leqslant ni, 1⩽i⩽n ，使得 p∣aip\\mid a_ip∣ai​ 。 证明：我们通过数学归纳法证明。对任意素数 ppp \\qquad①当 n=1n=1n=1 时，显然成立。 \\qquad②假定结果对 nnn 成立。考虑 n+1n+1n+1 个整数的乘积 a1a2⋯an+1a_1a_2\\cdots a_{n+1}a1​a2​⋯an+1​ ，它是能够被素数 ppp 整除的。我们知道或者有 (p, a1a2⋯an)=1(p,\\ a_1a_2\\cdots a_n)=1(p, a1​a2​⋯an​)=1 ，或者有 (p, a1a2⋯an)=p(p,\\ a_1a_2\\cdots a_n)=p(p, a1​a2​⋯an​)=p 。如果 (p, a1a2⋯an)=1(p,\\ a_1a_2\\cdots a_n)=1(p, a1​a2​⋯an​)=1 ，则由引理 3.4 ，p∣an+1p\\mid a_{n+1}p∣an+1​ 。另一方面，如果 p∣a1a2⋯anp\\mid a_1a_2\\cdots a_np∣a1​a2​⋯an​ ，由归纳假设，存在整数 i, 1⩽i⩽ni,\\ 1\\leqslant i\\leqslant ni, 1⩽i⩽n ，使得 p∣aip\\mid a_ip∣ai​ 。因此，对某个满足 1⩽i⩽n+11\\leqslant i\\leqslant n+11⩽i⩽n+1 的 iii ，p∣aip\\mid a_ip∣ai​ 。 证毕。 定理 3.15 算术基本定理 定理3.15（算术基本定理）：每个大于 111 的正整数都可以被唯一地写成素数的乘积，在乘积中的素因子按照非降序排列。 证明： ①我们采用反证法：证明：每个大于 111 的数必能写成素数的乘积。 假定某正整数不能被写成素数的乘积。设 是这样的整数中最小的(良序性)。如果 是素数，那么它显然是素数的乘积，即一个素数 。所以 一定是合数。设 ，其中 。但是由于 都比 小，因54此它们一定可以写成素数的乘积(良序性)。又由于 ，我们得到 也是素数的乘积。这个矛盾说明每个正整数都可以写成素数的乘积。 ②我们现在通过证明这个 分解的唯一性 来完成算术基本定理的证明。 假定整数 有两种不同的素数分解形式： ，其中 和 为素数，且 。 在这两个分解式中约去相同的素数，得到 *。*其中等式左边的素数与右边的不同， 。 然而，这导致了与引理3.5的矛盾。由该引理，一定存在某一个 使得 整除 ，这是不可能的，因为每个 都是与 不同的素数。 因此，正整数 nnn 的素因子分解是唯一的。■\\qquad\\qquad\\qquad\\qquad \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 整数分解中把素因子组合成幂的形式被称为 素幂因子分解（prime-power factorization）。 唯一因子分解在哪里不成立：略。 素因子分解的应用 素数 ppp 整除 nnn 当且仅当它出现在 nnn 的素幂因子分解中。 一个素数 ppp 能整除 nnn 的最高次幂是 ppp 在 nnn 的素幂因子分解中的幂次。 一个整数 ddd 整除 nnn 当且仅当 ddd 的素幂因子分解中出现的所有素数都在 nnn 的素幂因子分解中出现，且其出现的幂次大于等于在 ddd 的素幂因子分解中的幂次。 \\qquad用素因子分解来求最大公因子，设 min⁡(a, b)\\min(a,\\ b)min(a, b) 为 a, ba,\\ ba, b 中较小的一个。现在设 a, ba,\\ ba, b 的素因子分解为 \\qquad\\qquad\\qquada=p1a1p2a2⋯pnana=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}a=p1a1​​p2a2​​⋯pnan​​，b=p1b1p2b2⋯pnbnb=p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}b=p1b1​​p2b2​​⋯pnbn​​ 其中 p1, p2,⋯ ,pnp_1,\\ p_2,\\cdots,p_np1​, p2​,⋯,pn​ 是出现在 a, ba,\\ ba, b 的素幂因子分解中的素数（对某些 iii，有可能有 ai=0a_i=0ai​=0 或 bi=0b_i=0bi​=0 ） 可得 (a, b)=p1min⁡(a1, b1)p2min⁡(a2, b2)⋯pnmin⁡(an, bn)\\qquad(a,\\ b)=p_1^{\\min(a_1,\\ b_1)}p_2^{\\min(a_2,\\ b_2)} \\cdots p_n^{\\min(a_n,\\ b_n)}(a, b)=p1min(a1​, b1​)​p2min(a2​, b2​)​⋯pnmin(an​, bn​)​ ，这是因为对每个素数 pip_ipi​ ， a, ba,\\ ba, b 恰好共同拥有 min⁡(ai, bi)\\min(a_i,\\ b_i)min(ai​, bi​) 个因子 pip_ipi​ 。 定义：两个非 0 整数 a, ba,\\ ba, b 的 最小公倍数（the least common multiple）是能够被 a, ba,\\ ba, b 整除的最小正整数。 a, ba,\\ ba, b 的最小公倍数记为 [a, b][a,\\ b][a, b] ，也可写成 lcm⁡(a, b)\\operatorname{lcm}(a,\\ b)lcm(a, b) 。 \\qquad用素因子分解求最小公倍数：如果 a=p1a1p2a2⋯pnana=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}a=p1a1​​p2a2​​⋯pnan​​ ，b=p1b1p2b2⋯pnbnb=p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}b=p1b1​​p2b2​​⋯pnbn​​ ，则对一个能够被 a, ba,\\ ba, b 同时整除的整数，其素幂因子分解中必须出现 pjp_jpj​ 且其幂次至少与 aj, bja_j,\\ b_jaj​, bj​ 一样大。因此，能够被 a, ba,\\ ba, b 同时整除的最小正整数 [a, b][a,\\ b][a, b] 为 [a, b]=p1max⁡(a1, b1)p2max⁡(a2, b2)⋯pnmax⁡(an, bn)\\qquad\\qquad\\qquad\\qquad [a,\\ b]=p_1^{\\max(a_1,\\ b_1)}p_2^{\\max(a_2,\\ b_2)} \\cdots p_n^{\\max(a_n,\\ b_n)}[a, b]=p1max(a1​, b1​)​p2max(a2​, b2​)​⋯pnmax(an​, bn​)​ 其中 max⁡(x, y)\\max(x,\\ y)max(x, y) 表示 x, yx,\\ yx, y 中较大的。 求大整数的素因子分解比较耗费时间。因此我们想要一种求两个整数的最小公倍数但不使用素因子分解的方法。可以由两个正整数的最大公因子求它们的最小公倍数。为此，我们需要证明下面的引理。 引理 3.6 引理 3.6：如果 x,yx,yx,y 是实数，则 max⁡(x, y)+min⁡(x,y)=x+y\\max(x,\\ y)+\\min(x, y)=x+ymax(x, y)+min(x,y)=x+y 。 证明：如果 x&gt;yx&gt;yx&gt;y ，则 如果 x&lt;yx &lt;yx&lt;y ， 如果 x=yx=yx=y ， 定理 3.16 定理3.16：如果 a, ba,\\ ba, b 是正整数，则 [a, b]=ab/(a, b)[a,\\ b]=ab/(a,\\ b)[a, b]=ab/(a, b) ，其中 [a, b][a,\\ b][a, b] 和 (a, b)(a,\\ b)(a, b) 分别是 a, ba,\\ ba, b 的最小公倍数和最大公因子。 证明：设 a, ba,\\ ba, b 的素幂因子分解为 a=p1a1p2a2⋯pnana=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}a=p1a1​​p2a2​​⋯pnan​​ ，b=p1b1p2b2⋯pnbnb=p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}b=p1b1​​p2b2​​⋯pnbn​​ 。现在设 Mj=max⁡(aj, bj)M_j=\\max(a_j,\\ b_j)Mj​=max(aj​, bj​) ，mj=min⁡(aj, bj)m_j=\\min(a_j,\\ b_j)mj​=min(aj​, bj​) 则有 [a, b](a, b)=p1M1p2M2⋯pnMnp1m1p2m2⋯pnmn=p1M1+m1p2M2+m2⋯pnMn+mn=p1a1+b1p2a2+b2⋯pnan+bn=p1a1p2a2⋯pnanp1b1p2b2⋯pnbn=ab\\begin{align*} [a,\\ b](a,\\ b)&amp;=p_1^{M_1}p_2^{M_2}\\cdots p_n^{M_n}p_1^{m_1}p_2^{m_2}\\cdots p_n^{m_n}\\\\ &amp;=p_1^{M_1+m_1}p_2^{M_2+m_2}\\cdots p_n^{M_n+m_n}\\\\ &amp;=p_1^{a_1+b_1}p_2^{a_2+b_2}\\cdots p_n^{a_n+b_n}\\\\ &amp;=p_1^{a_1}p_2^{a_2}\\cdots p_n^{a_n}p_1^{b_1}p_2^{b_2}\\cdots p_n^{b_n}\\\\ &amp;=ab \\end{align*} [a, b](a, b)​=p1M1​​p2M2​​⋯pnMn​​p1m1​​p2m2​​⋯pnmn​​=p1M1​+m1​​p2M2​+m2​​⋯pnMn​+mn​​=p1a1​+b1​​p2a2​+b2​​⋯pnan​+bn​​=p1a1​​p2a2​​⋯pnan​​p1b1​​p2b2​​⋯pnbn​​=ab​ 这是因为根据引理 3.6 ， Mj+mj=max⁡(aj, bj)+min⁡(aj, bj)=aj+bjM_j+m_j=\\max(a_j,\\ b_j)+\\min(a_j,\\ b_j)=a_j+b_jMj​+mj​=max(aj​, bj​)+min(aj​, bj​)=aj​+bj​ 。■\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 引理 3.7 算术基本定理的推论 引理 3.7：设 m, nm,\\ nm, n 是互素的正整数，那么如果 ddd 是 mnmnmn 的一个正因子，则存在唯一的一对 mmm 的正因子 d1d_1d1​ 和 nnn 的正因子 d2d_2d2​ 使得 d=d1d2d=d_1d_2d=d1​d2​ 。反之，如果 d1d_1d1​ 和 d2d_2d2​ 分别是 mmm 和 nnn 的正因子，则 d=d1d2d=d_1d_2d=d1​d2​ 是 mnmnmn 的正因子。 证明： 狄利克雷定理中一种特殊情形的证明（略 引理 3.8 定理 3.17 定理 3.17：存在无穷多个形如 4n+34n+34n+3 的素数，其中 nnn 为正整数。 关于无理数的结果 定理 3.18 定理 3.19 算术基本定理可以用来证明下面的结果，它将著名的黎曼 zeta 函数和素数联系起来。 定理 3.19： 证明： 3.6 因子分解法和费马数 因子分解 试除法 vector&lt;PII&gt; primes;void div(int x)&#123; for(int i = 2; i * i &lt;= x; i++) &#123; if(x % i == 0)&#123; int cnt = 0; while(x % i == 0) x /= i, cnt ++; primes.push_back(&#123;i, cnt&#125;); &#125; if(i * i &gt; x) break;// 任意合数必有一个小于等于sqrt(x)d &#125; if(x &gt; 1) priems.push_back(&#123;x, 1&#125;);&#125; 17世纪初，费马给出了一种因子分解的方法，这个方法是基于将一个合数表示成两个平方数的差的形式。这个方法在理论和某些实际应用中是相当重要的，但是它本身并不是一个十分有效的方法。它基于下面的引理。 引理 3.9 引理 3.9：如果 nnn 是一个正的奇数，那么 nnn 分解为两个正整数的积和表示成两个平方数的差是一一对应的。 证明： 费马因子分解在用来分解一个具有两个相似大小的因子的整数时最有效。尽管费马因子分解很少被用来分解大整数，但是它 的基本思想是计算机计算中广泛使用的很多更有效因子分解算法的基础。 费马数 定理 3.20 利用费马数证明素数无穷性：利用费马数证明存在无穷多的素数是有可能的。我们从证明两个不同的费马数是互素的开始。这将会用到下面的引理。 引理 3.10 定理 3.21 费马素数与几何：费马素数在几何学中很重要 定理 3.22 3.7 线性丢番图方程 \\qquad考虑下面的问题：一个人想购买 510 美元的旅游支票。支票只有 20 美元和 50 美元两种。那么每一种应该买多少？如果令 x 表示他应该买的 20 美元支票的数量，y 表示 50 美元支票的数量，那么就应满足方程 20x+50y=51020x+50y=51020x+50y=510 。为了解决这一问题，应该求出这个方程的所有解，其中 x, yx,\\ yx, y 为非负整数。 \\qquad类似的问题出现在当一个妇女想邮寄一个包裹时。邮局的职员测定邮寄这个包裹的费用是 83 美分，但是只有 6 美分和 15 美分的邮票。那么是否有这两种邮票的组合后的面值恰好可以来邮寄这个包裹呢？为了回答这个问题，我们先令 xxx 表示 6 美分邮票的数量，令 yyy 表示 15 美分邮票的数量。那么有 6x+15y=836x+15y=836x+15y=83 ，其中 x, yx,\\ yx, y 是非负整数。 \\qquad当我们需要求解特定方程的整数解的时候，就得到了一个 丢番图方程。这些方程是根据古希腊数学家丢番图而命名的，他写下了一些方程并将解限定在有理数域上。方程 ax+by=cax+by=cax+by=c （其中 a, b, ca,\\ b,\\ ca, b, c 是整数）被称为 关于两个变量的线性丢番图方程。 定理 3.23 下面的定理说明什么时候这类方程有解，当有解的时候又如何明确地描述它们。 定理 3.23：设 a, ba,\\ ba, b 是整数且 d=(a, b)d=(a,\\ b)d=(a, b) 。如果 d∤cd\\nmid cd∤c ，那么方程 ax+by=cax+by=cax+by=c 没有整数解。如果 d∣cd\\mid cd∣c ，那么存在无穷多个整数解。另外，如果 x=x0x=x_0x=x0​ ，y=y0y=y_0y=y0​ 是方程的一个特解，那么所有的解可以表示为 x=x0+(b/d)ny=y0−(a/d)n\\qquad\\qquad\\qquad\\qquad\\qquad x=x_0+(b/d)n \\qquad y=y_0-(a/d)nx=x0​+(b/d)ny=y0​−(a/d)n 其中 nnn 是整数。 证明：假设 x, yx,\\ yx, y 是整数满足 ax+by=cax+by=cax+by=c 。那么因为 d∣ad\\mid ad∣a ，d∣bd\\mid bd∣b ，由定理 1.9 同样有 d∣cd\\mid cd∣c 。因此如果 d∤cd\\nmid cd∤c ，那么这个方程就不存在整数解。 \\qquad现在假设 d∣cd\\mid cd∣c ，由定理 3.8 ，存在整数 s, ts,\\ ts, t 使得 d=as+bt(1)\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad d=as+bt \\qquad\\qquad\\qquad\\qquad (1)d=as+bt(1) 因为 d∣cd\\mid cd∣c ，有整数 eee 使得 de=cde=cde=c 。在（1）两边同时乘以 eee ，我们有 c=de=(as+bt)e=a(se)+b(te)c=de=(as+bt)e=a(se)+b(te)c=de=(as+bt)e=a(se)+b(te) 。 因此，x=x0x=x_0x=x0​ ，y=y0y=y_0y=y0​ ，就是方程的一个解，其中 x0=sex_0=sex0​=se ，y0=tey_0=tey0​=te 。 \\qquad为了证明方程存在无穷多个解，令 x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n ，y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n ，其中 nnn 是整数。首先为了证明任何一对整数 (x, y)(x,\\ y)(x, y) ，x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n ，y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n ，nnn 是整数，它是方程的解。然后再证明方程的任何一个解都具有这种形式。 \\qquad易知 (x, y)(x,\\ y)(x, y) 是解，这是因为 ax+by=ax0+a(b/d)n+by0−b(a/d)n=ax0+by0=cax+by=ax_0+a(b/d)n+by_0-b(a/d)n=ax_0+by_0=cax+by=ax0​+a(b/d)n+by0​−b(a/d)n=ax0​+by0​=c 。 \\qquad我们现在证明方程 ax+by=cax+by=cax+by=c 的解都具有定理中所描述的那种形式。假设整数 x, yx,\\ yx, y 满足 ax+by=cax+by=cax+by=c 。因为 ax0+by0=cax_0+by_0=cax0​+by0​=c ，做减法得到 (ax+by)−(ax0+by0)=0(ax+by)-(ax_0+by_0)=0(ax+by)−(ax0​+by0​)=0 ，这就说明 a(x−x0)+b(y−y0)=0a(x-x_0)+b(y-y_0)=0a(x−x0​)+b(y−y0​)=0 。因此 a(x−x0)=b(y0−y)a(x-x_0)=b(y_0-y)a(x−x0​)=b(y0​−y) 。两边同时除以 ddd ，得 (a/d)(x−x0)=(b/d)(y0−y)(a/d)(x-x_0)=(b/d)(y_0-y)(a/d)(x−x0​)=(b/d)(y0​−y) 。由定理 3.6 ， (a/d, b/d)=1(a/d,\\ b/d)=1(a/d, b/d)=1 。用引理 3.4 ，有 (a/d)∣(y0−y)(a/d)\\mid (y_0-y)(a/d)∣(y0​−y) 。因此，存在整数 nnn 使得 (a/d)n=(y0−y)(a/d)n=(y_0-y)(a/d)n=(y0​−y) 。这就意味着 y=y0−(a/d)ny=y_0-(a/d)ny=y0​−(a/d)n 。现在将这个 yyy 值代入方程 a(x−x0)=b(y0−y)a(x-x_0)=b(y_0-y)a(x−x0​)=b(y0​−y) ，我们得到 a(x−x0)=b(a/d)na(x-x_0)=b(a/d)na(x−x0​)=b(a/d)n 。这就得到了 x=x0+(b/d)nx=x_0+(b/d)nx=x0​+(b/d)n 。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 定理 3.24 可以将定理 3.23 推广为多个变量的线性丢番图方程。下面的定理给出了这个推广。 定理 3.24：如果 a1, a2,⋯ , ana_1,\\ a_2,\\cdots,\\ a_na1​, a2​,⋯, an​ 是非零整数，那么方程 a1x1+a2x2+⋯+anxn=ca_1x_1+a_2x_2+\\cdots+a_nx_n=ca1​x1​+a2​x2​+⋯+an​xn​=c 有整数解当且仅当 d=(a1,a2,⋯ ,an)d=(a_1,a_2,\\cdots,a_n)d=(a1​,a2​,⋯,an​) 整除 ccc 。另外当存在一个解的时候，方程有无穷多个解。 证明：如果存在整数 x1,x2,⋯ ,xnx_1,x_2,\\cdots,x_nx1​,x2​,⋯,xn​ 满足 a1x1+a2x2+⋯+anxn=ca_1x_1+a_2x_2+\\cdots+a_nx_n=ca1​x1​+a2​x2​+⋯+an​xn​=c ，则由于 ddd 整除 ai, i=1,2,⋯ ,na_i,\\ i=1,2,\\cdots,nai​, i=1,2,⋯,n ，故由定理 1.9 ，ddd 整除 ccc 。因此，如果 d∤cd\\nmid cd∤c ，则方程不存在解。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"第一章 整数","slug":"读书笔记/数学/初等数论及其应用/第一章 整数","date":"2021-08-22T16:00:00.000Z","updated":"2021-10-28T02:05:56.118Z","comments":true,"path":"2021/08/23/读书笔记/数学/初等数论及其应用/第一章 整数/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B4%E6%95%B0/","excerpt":"","text":"大纲 在最一般的意义下，数论研究各种数集合的性质。 在本章中我们讨论某些特别重要的 数的集合 ，包括整数、有理数和代数数集合。 我们将简单介绍 用有理数逼近实数 的概念，也介绍 序列 (特别是整数序列)的概念，包括古希腊人所研究的一些 垛积数序列 。 一个常见问题是如何由一些初始项来判定一个特别的整数序列。我们将简单讨论一下如何解决这种问题。 利用序列概念，我们定义 可数集合 并且证明 有理数集合是可数的 。我们还引进了求和符号 和 求积符号 ，并建立一些有用的求和公式。 数学归纳法 是数论(和许多数学分支)中最重要的证明方法之一。我们讨论数学归纳法的两种形式，说明如何用它们来证明各种结果，并且解释数学归纳法为什么是一种有效的证明手段。 然后我们介绍著名的 斐波那契 (Fibonacci)数序列，讲述引出这种数的原始问题。 我们将建立与斐波那契数有关的一些恒等式和不等式，其中有些证明就使用了数学归纳法。 本章最后一节讲述数论的一个基本概念：整除性 。 我们将建立整数除法的基本性质，包括带余除法，还将解释如何用 最大整数函数 来表示一个整数去除另一个整数的商和余数。（也讲述了最大整数函数许多有用的性质） 1.1 数和序列 本节将介绍一些基础知识，它们在本书中通篇使用。 特别地，我们将涉及数论中所研究的重要的数集合、整数序列的概念、求和与求积符号。 良序性质 良序性质：每个非空的正整数集合都有一个最小元。 良序性质可以作为定义正整数集合的 公理 ，或者由一组公理推导出来。 正整数集合 定理1.1-2\\sqrt{2}2​ 是无理数 定理1.1： 2\\sqrt{2}2​ 是无理数。 证明1：设 2=pq\\sqrt{2}=\\dfrac{p}{q}2​=qp​ 互质，证明 p,qp,qp,q 为偶数。 证明2：使用良序性。 定义：如果存在整数 p,q≠0p,q\\ne 0p,q=0 ，使得 r=p/qr=p/qr=p/q ，则称实数 rrr 是 有理数 。否则 rrr 为 无理数 。 整数集合、正整数集合、有理数集合和实数集合通常分别记为 \\Z,\\Z+,\\Q,\\R 。我们也用 x∈Sx\\in Sx∈S 来表示 xxx 属于集合 SSS 。 「最大整数函数」： xxx 中的最大整数记为 [x][x][x] ，是小于或等于 xxx 的最大整数，即 [x][x][x] 是满足 [x]≤x&lt;[x]+1[x]\\le x&lt;[x]+1[x]≤x&lt;[x]+1 的整数。最大整数函数也被称为取整函数（floor function）。在计算机科学中通常用记号 ⌊x⌋\\lfloor x \\rfloor⌊x⌋ 代替 [x][x][x] 。 「上整数函数」：记为 ⌈x⌉\\lceil x \\rceil⌈x⌉ ，是大于或等于 xxx 的最小整数。 例1.4：证明如果 nnn 是整数，则对于任意实数 xxx ，都有 [x+n]=[x]+n[x+n]=[x]+n[x+n]=[x]+n 。 定义：实数 zzz 的分数部分（fractional part）记为 {x}\\{x\\}{x} ，是 xxx 与 [x][x][x] 的差，即 {x}=x−[x]\\{x\\}=x-[x]{x}=x−[x] 。 丢番图逼近 我们知道一个实数和与之最接近的整数的距离不超过 12\\dfrac{1}{2}21​ 。但我们可否证明一个实数的前 kkk 个倍数中的某一个一定更接近某个整数？ 数论中一个很重要的部分称为丢番图逼近，它正是研究这类问题的。特别地，丢番图逼近着重研究用有理数逼近实数的问题。 我们将要证明在实数 $\\alpha $ 的前 nnn 个倍数中至少有一个实数与最接近它的整数的距离小于 1n\\dfrac{1}{n}n1​ 。 这个证明是基于德国数学家狄利克雷(Dirichlet)提出的鸽笼原理。 定理1.2-鸽笼原理 定理1.2 鸽笼原理：如果把 k+1k+1k+1 个或者更多的物体放入 kkk 个盒子中，那么至少有一个盒子中有两个或更多的物体。 证明： 如果 kkk 个盒子中的任何一个中都没有多于一个的物体，那么所有物体的总数至多为 kkk 。这个矛盾说明有一个盒子中至少有两个或者更多的物体。 定理1.3-狄利克雷逼近原理 现在我们来叙述并证明狄利克雷逼近定理，它能够保证一个实数的前 nnn 个倍数之一必定在某个整数的 1/n1/n1/n 邻域内。 定理1.3（狄利克雷逼近定理）：如果 α\\alphaα 是一个实数，nnn 是一个正整数，则存在整数 a,b,1≤a≤na,b,1\\le a\\le na,b,1≤a≤n，使得 ∣a×a−b∣&lt;1/n|a\\times a-b|&lt;1/n∣a×a−b∣&lt;1/n 。 考虑 n+1n+1n+1 个数 。这 n+1n+1n+1 个数是数 的分数部分，所以 。这 个数中的每一个都位于 个互不相交的区间中的一个。 对于定理 1.3 我们采取的是狄利克雷1834年的原始证明。把定理1.3中的 替换为 ,可以得到一个更强的结论。它的证明并不困难(见习题32)。进一步，在习题34中我们展示如何用狄利克雷逼近定理来证明对于一个无理数 ，存在无数多个不同的有理数 使得 。这是丢番图逼近定理中的一个重要结果。我们将在第12章再回到这个话题 序列：序列 {an}\\{ a_n\\}{an​} 是一列数 a1,a2,a3,⋯a_1,a_2,a_3,\\cdotsa1​,a2​,a3​,⋯ 。 数论中的一个常见问题是如何寻找构造序列的通项公式或者规则。 我们现在定义什么是可数集，并且证明：当且仅当一个集合的元素可以被列为一个序列时，它是可数的。 定义一个集合可数（countable），如果它是有限的或者是无穷的但与正整数集合之间存在一个一一映射。如果一个集合不是可数的，则称为不可数（uncountable）。 一个无穷集合是可数的当且仅当其中的元素可以被列为一个由正整数标记的序列。为了看到这一点，只需注意从正整数集合到一个集合 sss 的一一映射 fff 其实就是把集合中的元素列成序列 a1,a2,⋯ ,an,⋯a_1,a_2,\\cdots,a_n,\\cdotsa1​,a2​,⋯,an​,⋯ ，其中 ai=f(i)a_i=f(i)ai​=f(i) 。 定理1.4-有理数集合是可数的 定理1.4：有理数集合是可数的。 习题45将会证明实数集合不可数。 1.2 和与积 和的记号： ∑k=1nak=a1+a2+⋯+an\\displaystyle \\sum_{k=1}^{n}a_k=a_1+a_2+\\cdots+a_nk=1∑n​ak​=a1​+a2​+⋯+an​ 。字母 kkk 称为 求和下标（index of summation）。 三个和式 ∑j=mn(c×aj)=c∑j=mnaj\\displaystyle \\sum_{j=m}^{n}(c\\times a_j)=c\\sum_{j=m}^{n}a_jj=m∑n​(c×aj​)=cj=m∑n​aj​ ； ∑j=mn(aj+bj)=∑j=mnaj+∑j=mnbj\\displaystyle \\sum_{j=m}^{n}(a_j+b_j)=\\sum_{j=m}^{n}a_j+\\sum_{j=m}^{n}b_jj=m∑n​(aj​+bj​)=j=m∑n​aj​+j=m∑n​bj​ ； ∑i=mn∑j=pqaibj=(∑i=mnai)(∑j=pqbj)=∑j=pq∑i=mnaibj\\displaystyle \\sum_{i=m}^{n}\\sum_{j=p}^{q}a_ib_j= \\left(\\sum_{i=m}^{n}a_i \\right )\\left(\\sum_{j=p}^{q}b_j \\right)=\\sum_{j=p}^{q}\\sum_{i=m}^{n}a_ib_ji=m∑n​j=p∑q​ai​bj​=(i=m∑n​ai​)(j=p∑q​bj​)=j=p∑q​i=m∑n​ai​bj​ ； 例1.15 求等比数列 的前 n+1n+1n+1 项的和。 推导出 当 。 例1.17 证明：2 的前 nnn 个连续方幂之和比 2 的下一个方幂小 1。即 ∑i=0n2i=2n+1−1\\displaystyle \\sum_{i=0}^{n}2^i=2^{n+1}-1i=0∑n​2i=2n+1−1 。 证明： 形如 ∑i=1n(ai−ai−1)\\displaystyle \\sum_{i=1}^{n}(a_i-a_{i-1)}i=1∑n​(ai​−ai−1)​ 的和被称为是 叠进的 。其中 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 是一数列。 \\qquad\\qquad\\qquad ∑i=1n(ai−ai−1)=(an−an−1)+⋯+(a2−1)+(a1−a0)=an−a0\\displaystyle \\sum_{i=1}^{n}(a_i-a_{i-1})=(a_n-a_{n-1})+\\cdots +(a_2-_1)+(a_1-a_0)=a_n-a_0i=1∑n​(ai​−ai−1​)=(an​−an−1​)+⋯+(a2​−1​)+(a1​−a0​)=an​−a0​ 。 例1.18 三角数 t1,t2,t3,⋯ ,tk,⋯t_1,t_2,t_3,\\cdots,t_k,\\cdotst1​,t2​,t3​,⋯,tk​,⋯ 是一个数列，其中 tkt_ktk​ 为第 jjj 行有 jjj 个点的 kkk 行三角阵列中点的个数。 推导 tnt_ntn​ 的另一种求法见习题7。 与求和类似，我们也给乘积定义一个记号。数 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​ 的积记为 ∏k=1nak=a1×a2×⋯an\\displaystyle \\prod_{k=1}^{n}a_k=a_1\\times a_2\\times\\cdots a_nk=1∏n​ak​=a1​×a2​×⋯an​ 。 字母 jjj 为虚变量，可以用任意字母代替。 阶乘函数在数论中通篇出现。 定义：设 nnn 为正整数，则 n!n!n!（读作“ nnn 的阶乘”）是整数 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 的积。0!=10!=10!=1。采用乘积符号，我们有 n!=∏j=1njn!=\\displaystyle \\prod_{j=1}^{n}jn!=j=1∏n​j。 1.3 数学归纳法 定理1.5-数学归纳原理 使用数学归纳法证明一个特定命题对所有正整数都成立必须实现「两步」。 第一，设 SSS 为我们认为命题成立的那个正整数集合，必须说明 1 属于 SSS ；即命题对整数 1 为真。这叫做基础步骤。 第二，必须证明对每个正整数 nnn，如果 nnn 属于 SSS 则 n+1n+1n+1 也属于 SSS ；即如果这个命题对 nnn 为真，则对 n+1n+1n+1 也为真。这被称为归纳步骤。 一旦这两步都完成了，我们就可以由数学归纳原理得到结论：命题对所有正整数为真。 定理1.5（数学归纳原理）：一个包含整数 1 的正整数集合如果具有如下性质，即若其包含整数 kkk ，则其也包含整数 k+1k+1k+1 ，那么这个集合一定是所有正整数的集合。 证明 ：设 是包含整数 的正整数集合，并且如果它包含整数 ，则一定包含 。假定(为了推出矛盾) 不是所有正整数的集合。因此有某个正整数不包含在集合 中。由「良序性质」，由于不包含在 中的正整数集合是非空的，所以不包含于 中的所有正整数中存在一个最小的正整数，记为 。注意由于 在中，故 。 现在，由于 （因为不存在正整数 满足 ），故 是小于 的正整数，并且 一定在集合 中。但是因为包含 ，从而一定包含 。这与假定为不包含于 中的最小整数矛盾。这说明 一定是所有正整数的集合。 例：证明 : 对于正整数，有 基础步骤 :，所以这一步成立。 归纳步骤 :我们的归纳假设为公式对于 成立，即假定 .使用归纳假设，我们有 由于基础步骤和归纳步骤都完成了，我们知道结果成立。 例：证明 :，对任意正整数 成立。 基础步骤 归纳步骤 定理1.6-第二数学归纳原理 定理1.6（第二数学归纳原理）：对于包含 的正整数集合，如果它具有下述性质：对每一个正整数 。如果它包含全体正整数 ，则它也包含整数 ，那么这个集合一定是由所有正整数构成的集合。 证明：设是一个包含的整数集合，并且对任意正整数 ，如果它包含，则它也包含 。设 是所有正整数 的集合， 满足：小于等于 的正整数都在 中。则 在 中，并且，根据假设，我们看到如果 在 中，则 在 中。因此，由数学归纳法原理，必为所有正整数的集合，故显然 也是所有正整数的集合，因为 是 的一个子集。 1能使命题成立。 若 均使命题成立，则可推出 也使命题成立。 为了区别于数学归纳原理，第二数学归纳原理有时也称为强归纳，而数学归纳原理也 称为弱归纳。 递归定义 数学归纳原理提供了一种方法来定义函数在正整数处的值。我们不用明确给出函数在 nnn 处的值，而是给出其在 1 处的值，并且给出对于任意正整数 nnn ，从函数在 nnn 处的值来寻找在 n+1n+1n+1 处的值的规则。 定义：我们说函数 fff 是 递归定义 的，如果指定了 fff 在 1 处的值，而且对于任意正整数 nnn ，都提供了一个规则来根据 f(n)f(n)f(n) 确定 f(n+1)f(n+1)f(n+1) 。 数学归纳原理可以用来证明 递归定义的函数在每个正整数上都是唯一定义的（参看本节末尾的习题25）。 第二数学归纳原理也可以作为递归定义的基础。我们可以如下定义一个定义域为正整数集合的函数：首先指定它在 1 处的值，并且对每个正整数 nnn，给定一个根据 f(j),1≤j≤n−1f(j),1\\le j\\le n-1f(j),1≤j≤n−1 的值求 f(n)f(n)f(n) 的规则。这将是在1.4节中讨论的斐波那契数序列的定义的基础。 1.4 斐波那契数 定义：斐波那契序列有如下递归定义：f1=1,f2=1f_1=1,f_2=1f1​=1,f2​=1，且对 n≥3n\\ge 3n≥3，fn=fn−1+fn−2f_n=f_{n-1}+f_{n-2}fn​=fn−1​+fn−2​，这个序列中的项被称为斐波那契数。 斐波那契数满足相当多的恒等式 。 例1.27 如证明： ∑i=1nfk=fn+2−1\\displaystyle \\sum_{i=1}^{n}f_k=f_{n+2}-1i=1∑n​fk​=fn+2​−1 ，fnf_nfn​：第 n 个斐波那契数。 叠进和 数学归纳原理 本节末的习题要求你去证明许多关于斐波那契数的其他恒等式。 斐波那契数列增长有多快 ？下面的不等式说明斐波那契数比公比为 α=(1+5)/2\\alpha=(1+\\sqrt{5})/2α=(1+5​)/2 的等比数列增长的快，这一结论将在第 3 章中应用。 例1.28 用第二数学归纳原理证明对 n≥3n\\ge 3n≥3，有 fn&gt;αn−2f_n&gt;\\alpha^{n-2}fn​&gt;αn−2 。 定理1.7 我们用第 nnn 个斐波那契数的一个显式计算公式来结束本节。我们在正文中不给出证明，但是在本节末的习题41和习题42中概述了如何分别利用线性齐次递归关系和母函数来求这个公式。进一步，习题40要求通过说明这些项满足与斐波那契数相同的递归定义来证明这个恒等式，习题45要求用数学归纳法来证明。 前两个方法的优点是它们可以用来发现公式，而后两个方法却不能。 定理1.7 设 nnn 是正整数， α=1+52\\alpha=\\dfrac{1+\\sqrt{5}}{2}α=21+5​​， β=1−52\\beta=\\dfrac{1-\\sqrt{5}}{2}β=21−5​​ 则第 nnn 个斐波那契数 fnf_nfn​ 由该式给出： fn=15(αn−βn)f_n=\\dfrac{1}{\\sqrt{5}}(\\alpha^n-\\beta^n)fn​=5​1​(αn−βn) 。 1.5 整除性 一个整数可以被另一个整数整除的概念在数论中处于中心地位。 整除定义：如果 a,ba,ba,b 为整数且 a≠0a\\ne 0a=0 ，我们说 aaa 整除 bbb 是指存在整数 ccc 使得 b=a×cb=a\\times cb=a×c 。如果 aaa 整除 bbb，我们还称 aaa 是 bbb 的因子，且称 bbb 是 aaa 的倍数。 定理1.8 定理1.8：如果 a,b,ca,b,ca,b,c 是整数，且 a∣ba\\mid ba∣b，b∣cb\\mid cb∣c ，则 a∣ca\\mid ca∣c 。（ 若 bbb 是 ccc 的因子，则 bbb 的因子也是 ccc 的因子 证明： 定理1.9 定理1.9：如果 a,b,m,na,b,m,na,b,m,n 是整数，且 c∣ac\\mid ac∣a ，c∣bc\\mid bc∣b，则 c∣(ma+nb)c\\mid (ma+nb)c∣(ma+nb) ，ma+nbma+nbma+nb 是 a,ba,ba,b 的线性组合。 证明： 定理1.10 定理1.10（带余除法）：如果 a,ba,ba,b 是整数且 b&gt;0b&gt;0b&gt;0 ，则存在唯一的整数 qqq 和 rrr ，使得 a=bq+ra=b q+ra=bq+r ，0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。（ aaa 为被除数，bbb 为除数，qqq 为商Quotient，rrr 为余数Remainder） 用良序性证明带余除法。先证存在性（ TTT 中最小元 rrr 和 rrr 对应的 qqq 满足该要求），再证唯一性。 证明：如考虑形如 a−bka-bka−bk 的所有整数集合 SSS ，其中 kkk 为整数，即 S={a−bk∣k∈Z}S=\\{a-bk\\mid k\\in \\Z\\}S={a−bk∣k∈Z} 。设 TTT 是 SSS 中的所有非负整数构成的集合。TTT 是非空的，因为当 kkk 是满足 k&lt;a/bk&lt;a/bk&lt;a/b 的整数时，a−bka-bka−bk 是正的。 \\qquad由良序性质，TTT 中有最小元 r=a−bqr=a-bqr=a−bq 。根据 rrr 的构造可知 r≥0r\\ge 0r≥0 ，且容易证明 r&lt;br&lt;br&lt;b 。如果 r≥br\\ge br≥b ，则 r&gt;r−b=a−bq−b=a−b(q+1)r&gt;r-b=a-bq-b=a-b(q+1)r&gt;r−b=a−bq−b=a−b(q+1) ，这与我们选择 r=a−bqr=a-bqr=a−bq 为形如 a−bka-bka−bk 的整数中的最小元矛盾。因此 0≤r&lt;b0\\le r&lt;b0≤r&lt;b 。 \\qquad为了证明 qqq 和 rrr 的值是唯一的，我们假定有两个方程 a=bq1+r1a=bq_1+r_1a=bq1​+r1​ 和 a=bq2+r2a=bq_2+r_2a=bq2​+r2​ ，满足 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b 和 0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b。把第二个方程从第一个方程中减去，可得 0=b(q1−q2)+(r1−r2)\\qquad\\qquad\\qquad\\qquad\\qquad0=b(q_1-q_2)+(r_1-r_2)0=b(q1​−q2​)+(r1​−r2​) 因此，\\qquad\\qquad\\qquad\\qquadr2−r1=b(q1−q2)r_2-r_1=b(q_1-q_2)r2​−r1​=b(q1​−q2​) 由此可知 bbb 整除 r2−r1r_2-r_1r2​−r1​ 。因为 0≤r1&lt;b0\\le r_1&lt;b0≤r1​&lt;b，0≤r2&lt;b0\\le r_2&lt;b0≤r2​&lt;b ，故 −b&lt;r2−r1&lt;b-b&lt;r_2-r_1&lt;b−b&lt;r2​−r1​&lt;b 。因此 bbb 可以整除 r2−r1r_2-r_1r2​−r1​ 只有当 r2−r1=0r_2-r_1=0r2​−r1​=0 。我们还得到 q1=q2q_1=q_2q1​=q2​ 。这说明商 qqq 与余数 rrr 唯一的。■\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\blacksquare■ 因而 q=[a/b]q=[a/b]q=[a/b]，r=a−b×[a/b]r=a-b\\times [a/b]r=a−b×[a/b] 。 例1.36 证明：如果 是正整数，则当 为实数时 [x/n]=[[x]/n][x/n]=[[x]/n][x/n]=[[x]/n] 。 证明： 给定一个正整数 ddd ，可以根据整数被 ddd 除的余数把它们分类。 定义：如果 nnn 被 2 除的余数为 0 ，则对某个整数 kkk ，有 n=2kn=2kn=2k ，我们称 nnn 为偶数；而如果 nnn 被 2 除的余数为 1，则对某个整数 kkk ，有 n=2k+1n=2k+1n=2k+1 ，我们称 nnn 为奇数。 类似地，当 d=4d=4d=4 时，我们从带余除法中看到当整数被 4 除时，余数为 0，1，2，3。因此每个整数都形如 4k, 4k+1, 4k+2, 4k+34k,\\ 4k+1,\\ 4k+2,\\ 4k+34k, 4k+1, 4k+2, 4k+3 ，其中为正整数。 我们将在第4章继续讨论这个问题。 最大公因子 定义：不全为零的整数 a,ba,ba,b 的最大公因子是指能同时整除 a,ba,ba,b 的最大整数。 a,ba,ba,b 的最大公因子记为 (a,b)(a,b)(a,b) ，有时也记为 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 。 注意当 nnn 为正整数时， (0,n)=(n,0)=n(0,n)=(n,0)=n(0,n)=(n,0)=n 。 利用整数的有序性定义了整数的最大公因子。 虽然所有的正整数都能整除 0 ，我们是还定义 (0,0)=0(0,0)=0(0,0)=0 ，这样可以确保关于最大公因子的相关结论在所有的情况下均成立。 定义：设 a,ba,ba,b 均为非零整数，如果 a,ba,ba,b 的最大公因子 (a,b)=1(a,b)=1(a,b)=1 ，则称 a,ba,ba,b 互素 。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"贪心算法的证明","slug":"DS_Algorithm证明与讲解/贪心/贪心算法的证明","date":"2021-08-21T16:00:00.000Z","updated":"2021-08-22T09:45:55.046Z","comments":true,"path":"2021/08/22/DS_Algorithm证明与讲解/贪心/贪心算法的证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/22/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E/","excerpt":"","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"离散化","slug":"DS_Algorithm证明与讲解/基础算法/离散化","date":"2021-08-15T16:00:00.000Z","updated":"2021-09-22T01:54:28.300Z","comments":true,"path":"2021/08/16/DS_Algorithm证明与讲解/基础算法/离散化/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/16/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/","excerpt":"","text":"思路 保序 将所有值排序 去重 二分查找 无序 const int N = 1e5 + 10;unordered_map&lt;int, int&gt; hash;int p[N];int get(int x) // 无序离散化&#123; if(h.count(x) == 0) hash[x] = ++ n; return hash[x];&#125;int main()&#123; int cnt = 0; hash.clear(); for(int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; p[i] = get(l); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}]},{"title":"","slug":"DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford","date":"2021-08-15T03:19:20.673Z","updated":"2021-08-15T03:19:38.275Z","comments":true,"path":"2021/08/15/DS_Algorithm证明与讲解/图论/最短路/Bellman-Ford/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/Bellman-Ford/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BFS","slug":"题目/搜索/BFS","date":"2021-08-14T16:00:00.000Z","updated":"2021-09-04T06:08:19.731Z","comments":true,"path":"2021/08/15/题目/搜索/BFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/BFS/","excerpt":"","text":"多源BFS AcWing 173. 矩阵距离 最小步数模型 AcWing 1107. 魔板 双端队列广搜 AcWing 175. 电路维修 洛谷 P1948 [USACO08JAN]Telephone Lines S 洛谷 CF1063B Labyrinth 洛谷 CF1031D Minimum path 双向广搜 AcWing 190. 字串变换 A* AcWing 178. 第K短路：估价函数 AcWing 179. 八数码：估价函数","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Dijkstra","slug":"DS_Algorithm证明与讲解/图论/最短路/Dijkstra","date":"2021-08-14T16:00:00.000Z","updated":"2021-08-15T03:18:54.880Z","comments":true,"path":"2021/08/15/DS_Algorithm证明与讲解/图论/最短路/Dijkstra/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/15/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/Dijkstra/","excerpt":"","text":"Dijkstra证明 朴素版Dijkstra 堆优化版 Dijkstra","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://xiaoke-jin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"BFS求单源最短路证明","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS求单源最短路证明","date":"2021-08-13T16:00:00.000Z","updated":"2021-08-15T02:29:07.251Z","comments":true,"path":"2021/08/14/DS_Algorithm证明与讲解/搜索/BFS/BFS求单源最短路证明/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/14/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%E6%B1%82%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AF%81%E6%98%8E/","excerpt":"","text":"BFS求单源最短路证明 2021-08-15 算法导论 P364 挖个坑，日后补充。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"搜索讲解","slug":"DS_Algorithm证明与讲解/搜索/BFS&DFS","date":"2021-08-12T16:00:00.000Z","updated":"2021-10-07T09:27:06.013Z","comments":true,"path":"2021/08/13/DS_Algorithm证明与讲解/搜索/BFS&DFS/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/13/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS&DFS/","excerpt":"","text":"四联通与八联通 「四联通」 int dx[5] = &#123;-1, 0, 1, 0&#125;, dy[5] = &#123;0, 1, 0, -1&#125;;for(int i = 0; i &lt; 4; i++) for(int j = 0; j &lt; 4; j++)&#123; int nx = x + dx[i], ny = y + dy[j]; &#125; 「八连通」 // 1int dx[10] = &#123;-1, -1, 0, 1, 1, 1, 0, -1&#125;, dy[10] = &#123;0, 1, 1, 1, 0, -1, -1, -1&#125;;// 2for(int i = x - 1; i &lt;= x + 1; i++) for(int j = y - 1; j &lt;= y + 1; j++)&#123; if(i == x &amp;&amp; j == y)continue; // 遍历到自己，跳过&#125; 康托展开 P5367 【模板】康托展开","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"BFS求最短路","slug":"DS_Algorithm证明与讲解/搜索/BFS/BFS大纲","date":"2021-08-12T16:00:00.000Z","updated":"2021-09-05T15:36:13.680Z","comments":true,"path":"2021/08/13/DS_Algorithm证明与讲解/搜索/BFS/BFS大纲/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/13/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E6%90%9C%E7%B4%A2/BFS/BFS%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"本质：转换为Dijkstra 扩展 多源BFS 最小步数模型 双端队列广搜 双向广搜 A*","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"高精度板子","slug":"DS_Algorithm证明与讲解/基础算法/高精度板子","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:21:53.095Z","comments":true,"path":"2021/08/12/DS_Algorithm证明与讲解/基础算法/高精度板子/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%9D%BF%E5%AD%90/","excerpt":"","text":"加 ​ 减 ​ 乘 ​ 除 ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://xiaoke-jin.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"RMQ题目","slug":"题目/基础算法/RMQ","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-13T08:23:31.923Z","comments":true,"path":"2021/08/12/题目/基础算法/RMQ/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/RMQ/","excerpt":"","text":"AcWing 1273. 天才的记忆 离线算法 预处理：O(nlog⁡n)O(n\\log{n})O(nlogn)，查询：O(1)O(1)O(1)。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"}]},{"title":"并查集题目","slug":"题目/数据结构/并查集","date":"2021-08-11T16:00:00.000Z","updated":"2021-09-24T09:58:31.851Z","comments":true,"path":"2021/08/12/题目/数据结构/并查集/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/12/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"基础操作：查询，合并 洛谷 P3367 【模板】并查集 AcWing 1250. 格子游戏 洛谷 P1455 搭配购买 洛谷 P1955 程序自动分析 并查集扩展版 维护 size （集合中元素数量） AcWing 837. 连通块中点的数量 边带权 和 扩展域 洛谷 P2024 食物链 普通做法：扩展域 带权并查集的做法：AcWing 240. 食物链(带权并查集) 洛谷 P5937 [CEOI1999]Parity Game：注意与 洛谷 P1955 程序自动分析 的区别；是 洛谷 P2024 食物链 简化版 洛谷 P1196 [NOI2002] 银河英雄传说 Kruskal","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"数据结构","slug":"题目/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://xiaoke-jin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"STL与常用库函数","slug":"DS_Algorithm证明与讲解/基础算法/STL","date":"2021-08-10T16:00:00.000Z","updated":"2021-09-20T14:49:09.427Z","comments":true,"path":"2021/08/11/DS_Algorithm证明与讲解/基础算法/STL/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/11/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/STL/","excerpt":"","text":"常用库函数 reverse() sort pair 基本操作 pair&lt;int, int&gt; p;p.first; // 第一个元素p.second; // 第二个元素// 初始化pair&lt;int, int&gt; p = (1, 1);p = make_pair(10, &quot;yxc&quot;);p = (20, &quot;abc&quot;);// 使用 &#123;&#125;快速构造一个pairq.push_back(&#123;1, 1&#125;); 支持比较运算 以first为第一关键字，以second为第二关键字（字典序）。 vector 初始化 vector&lt;int&gt; a; // 定义一个vectorvector&lt;int&gt; a(n); // 定义一个长度为 n的vectorvector&lt;int&gt; a(10, 3); // 定义一个长度为 10,且每个元素值为 3的vectorvector&lt;int&gt; a[10]; // 定义 10个vector 函数 size(); // 返回vector中元素个数empty(); // 若vector为空,返回true; 否则返回 falseclear(); // 清空vectorpush_back()/pop_back(); // 在末尾插入/删除一个元素front()/begin(); // 返回第一个/最后一个元素// 返回向量头指针,指向第一个元素/返回向量尾指针,指向向量最后一个元素的「下一个位置」begin()/end();[]; // 支持数组操作; 下标从0开始 三种遍历方式 for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;// vector&lt;int&gt;::iterator可用 auto代替for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;for(auto x : a) cout &lt;&lt; x &lt;&lt; &quot; &quot;;cout &lt;&lt; endl; 支持比较运算 vector&lt;int&gt; a(4, 3), b(3, 4);// 按字典序比较if(a &lt; b) puts(&quot;a &lt; b&quot;); string 函数 size()/length() // 字母个数empty() // 是否为空clear() // 清空substr(n) // 返回从下标 n开始的子串substr(n, m) // 返回从下标 n开始, 长度为 m的子串; 若越界的话, 会输出到最后一个字符为止。printf(&quot;%s\\n&quot;, a.c_str()); // 使用 %s输出字符串 运算符 string a = &quot;yxc&quot;;a += &quot;nb&quot;; // 支持 +=操作a += &#x27;1&#x27;string b = &quot;1111&quot;;b[1] = &#x27;\\0&#x27;;b[2] = &#x27; &#x27;;cout &lt;&lt; b &lt;&lt; endl; // 输出 “1 1”，空格被输出;空字符跳过,不输出; 关于'\\0' std::string：标准中未规定需要'\\0'作为字符串结尾。编译器在实现时既可以在结尾加'\\0'，也可以不加。（因编译器不同） 但是，当通过c_str()或data()（二者在 C++11 及以后是等价的）来把std::string转换为const char *时，会发现最后一个字符是'\\0'。但是C++11，string字符串都是以'\\0'结尾。 Q：为什么C语言风格的字符串要以'\\0'结尾，C++可以不要？ A：C语言用char*指针作为字符串时，在读取字符串时需要一个特殊字符0来标记指针的结束位置，也就是通常认为的字符串结束标记。而C++语言则是面向对象的，长度信息直接被存储在了对象的成员中，读取字符串可以直接根据这个长度来读取，所以就没必要需要结束标记了。而且结束标记也不利于读取字符串中夹杂0字符的字符串。 queue 函数 size()empty()push()pop()front()back()q = queue&lt;int&gt;();// 重新构造一次即可清空队列; 没有 clear函数 priority_queue 定义 // 默认定义大根堆priority_queue&lt;int&gt; heap;// 定义小根堆// 1.插入负数// 2.priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; 函数 push()top()pop()// 无 clear() stack 函数 size()empty()push()pop()top() deque 函数 size()empty()clear()front()back()push_back()/pop_back()push_front()/pop_front()begin()/end()[] set 不能有重复元素 map multiset 可以有重复元素 multimap unordered_set unordered_map unordered_map&lt;key, T&gt; a; // key:键的类型, T:值的类型 unordered_multiset unordered_multimap bitset bitset&lt;n&gt; s; // 定义长度为 n的bool数组/* 支持位运算：~ &amp; | ^ &lt;&lt; &gt;&gt; * ==, != * [] */count() // 返回有多少个 1any() // 判断是否至少有一个 1none() // 判断是否全为 0set() // 把所有位置为 1set(k, v) // 将第k位变为 vreset() // 把所有位变成 0 flip() // 所有位取反flip(k) // 把第k位取反","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://xiaoke-jin.github.io/tags/STL/"}]},{"title":"洛谷名字颜色","slug":"杂文/洛谷名字颜色","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T05:07:28.636Z","comments":true,"path":"2021/08/10/杂文/洛谷名字颜色/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E6%9D%82%E6%96%87/%E6%B4%9B%E8%B0%B7%E5%90%8D%E5%AD%97%E9%A2%9C%E8%89%B2/","excerpt":"","text":"名字颜色规则 动态等级是根据用户在一段时间内的刷题、社区活跃、打卡、题解、违规情况，按照一定算法得出的结果，该算法不公开。动态等级比较准确的表现了用户一段时间内在洛谷的综合行为。 动态等级由 -1 到 4， 管理员的用户名颜色为 紫色\\color{purple}{紫色}紫色，不受动态等级影响。 用户名的颜色为分别对应为棕色、灰色、蓝色、绿色、橙色、红色。 -1 棕色\\color{brown}{棕色}棕色 作弊者 0 灰色\\color{Grey}{灰色}灰色 见习用户 即咕值&lt;100&lt;100&lt;100的用户 1 蓝色\\color{blue}{蓝色}蓝色 普通用户 即咕值在[100,119][100,119][100,119]的用户 2 绿色\\color{green}{绿色}绿色 算法爱好者 即咕值在[120,169][120,169][120,169]的用户 3 橙色\\color{orange}{橙色}橙色 刷题健将 即咕值在[170,229][170,229][170,229]的用户 4 红色\\color{RED}{红色}红色 虐题狂魔 即咕值&gt;229&gt;229&gt;229的用户 新用户的初始动态等级为 0，也就是 灰色\\color{Grey}{灰色}灰色 用户名。用户在洛谷中按照洛谷社区规则使用各项功能，会增加动态等级。如果长时间不使用洛谷或者有违规行为，可能会降级。除非用户有严重违规行为或者在长时间不使用洛谷且未进行实名认证的情况下，一旦用户达到蓝名，则不会掉到 灰色\\color{Grey}{灰色}灰色 。你可以在打卡之后在打卡结果中看到自己用户名的颜色。在犇犇或者讨论中询问颜色名字和咕值相关的一些问题将被和谐。 如果用户抄袭题解或非恶意比赛作弊，将降级至棕名及名字旁带有 Cheater\\color{brown}{Cheater}Cheater 标签，每次查到持续 15 日，并且在 90 日内不得在任何比赛获得排名。15 日后，变成 灰色\\color{Grey}{灰色}灰色 并清空所有 ACACAC 记录。（即，变为 Unaccepted 100Unaccepted\\ \\ \\ 100Unaccepted 100 分状态）。（注：棕名\\color{brown}{棕名}棕名用户是仅次于封号的最严厉警告，如果发生任何违反洛谷社区规则的事情，直接立刻封禁一年。） 动态等级影响洛谷内很多权限，例如创建比赛、团队、提交冷却时间、图床、下载数据等。灰名\\color{Grey}{灰名}灰名 会有较多的限制。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://xiaoke-jin.github.io/tags/%E6%B4%9B%E8%B0%B7/"}]},{"title":"LaTeX","slug":"语言/LaTeX","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-10T09:00:31.417Z","comments":true,"path":"2021/08/10/语言/LaTeX/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E8%AF%AD%E8%A8%80/LaTeX/","excerpt":"","text":"LaTeX入门 LaTeX入门 KaTeX KaTeX源码 其他网站 在线LaTeX编辑器","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://xiaoke-jin.github.io/tags/LaTeX/"}]},{"title":"Markdown","slug":"语言/Markdown","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-30T15:15:25.866Z","comments":true,"path":"2021/08/10/语言/Markdown/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E8%AF%AD%E8%A8%80/Markdown/","excerpt":"","text":"Markdown编辑器 Markdown语法 如何在Markdown中输入数学公式 Markdown KaTeX多个公式对齐 格式手册 行间公式 如果这些多行对齐的公式需要 编号，请用 align 或 equation 环境； 请使用 \\begin&#123;aligned&#125; ... \\end&#123;aligned&#125; 表示多行对齐的公式； 每行式子分别编号：使用 align d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{align} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{align} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​​ 一坨式子一个编号：使用 aligned d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d\\begin{aligned} &amp;d\\mid a\\text{且}d\\mid b\\\\ &amp;\\text{如果 }c\\text{ 是整数}\\text{且 }c\\mid a，c\\mid b，\\text{那么 }c\\mid d \\end{aligned} ​d∣a且d∣b如果 c 是整数且 c∣a，c∣b，那么 c∣d​ 不编号：align* a=b+c=e+f\\begin{align*} a&amp;=b+c\\\\ &amp;=e+f \\end{align*} a​=b+c=e+f​ 公式左对齐 \\begin{align*}\\label{2} & X(0) = x(0)W_{N}^{0\\cdot0} + x(1)W_{N}^{0\\cdot1} + \\cdots + x(N-1)W_{N}^{0\\cdot(N-1)}\\\\ & X(1) = x(0)W_{N}^{1\\cdot0} + x(1)W_{N}^{1\\cdot1} + \\cdots + x(N-1)W_{N}^{1\\cdot(N-1)} \\\\ & \\cdots \\\\ & X(N-1) = x(0)W_{N}^{(N-1)\\cdot0} + x(1)W_{N}^{(N-1)\\cdot1} + \\cdots + x(N-1)W_{N}^{(N-1)\\cdot(N-1)} \\\\ \\end{align*} 数学公式 数学公式中的中文文字 必须置于 \\text&#123;&#125; 命令之中，而变量、数字、运算符、函数名称则必须置于 \\text&#123;&#125; 命令之外。请不要在 \\text&#123;&#125; 命令中嵌套数学公式； 使用 array 环境时请注意 实际列数与对齐符号的数量保持一致。例如下面的公式中，数据实际有 3 列（&amp; 是列分隔符），因此需要 3 个对齐符号（l/r/c 分别表示左、右、居中对齐）。 F1={01,11}F2={01,12,11}\\begin{array}{lll} F_1=\\{\\frac{0}{1},&amp;&amp;\\frac{1}{1}\\}\\\\ F_2=\\{\\frac{0}{1},&amp;\\frac{1}{2},&amp;\\frac{1}{1}\\}\\\\ \\end{array} F1​={10​,F2​={10​,​21​,​11​}11​}​ 使用巨型运算符：加上 \\displaystyle $\\displaystyle \\sum_&#123;j=m&#125;^&#123;n&#125;ca_j=c\\sum_&#123;j=m&#125;^&#123;n&#125;a_j$ LaTeX公式的要求 使用 Roman 体表示常量和函数。使用 Italic 体表示变量。 如果遇到没有预先定义好的需要使用 Roman 体的 函数名，我们可以使用 $\\operatorname&#123;something&#125;$ 来产生，如我们可以使用 $\\operatorname&#123;lcm&#125;$ 产生正体的最小公倍数（函数）符号。 同理，产生 Roman 体的 常量 应用 $\\mathrm&#123;&#125;$；产生 Roman 体粗体符号应用 $\\mathbf&#123;&#125;$； 产生 Italic 体粗体符号应用 $\\boldsymbol&#123;&#125;$（如向量 ）。 对于多字母的变量，应当使用 $\\textit&#123;&#125;$。 其他非数学内容，包括英文、特殊符号等，一律使用 $\\text&#123;&#125;$。中文我们则建议不放在 LaTeX 公式中。 在行内使用分数的时候，请使用 $\\dfrac&#123;&#125;&#123;&#125;$。比如 $\\dfrac&#123;1&#125;&#123;2&#125;$，效果 12\\dfrac{1}{2}21​ ，而不是 $\\frac&#123;1&#125;&#123;2&#125;$，效果 12\\frac{1}{2}21​。 组合数请使用 \\dbinom&#123;n&#125;&#123;m&#125;，效果 (nm)\\dbinom{n}{m}(mn​)，而不是 &#123;n \\choose m&#125;（在 LaTeX 中这种写法已不推荐）；与上一条关于分数的约定相似，请不要使用 \\binom&#123;n&#125;&#123;m&#125;，效果 (nm)\\binom{n}{m}(mn​)。 在不会引起歧义的情况下，请用 $\\times$ 代替星号。叉乘请使用 $\\times$，点乘请使用 $\\cdot$。如 a×ba\\times ba×b，a⋅ba\\cdot ba⋅b ，而不是 a∗ba*ba∗b。 请注意，不要在非代码区域使用任何程序设计语言的表示方式，而是使用 LaTeX 公式。例如，使用 $=$ 而不是 $==$（如 a=ba=ba=b ，而不是 a==ba==ba==b ）、使用 a&lt;&lt;1 或者 $a\\times 2$ 而不是 $a&lt;&lt;1$、使用 $a\\bmod b$ 代替 $a\\%b$（如 a mod ba\\bmod bamodb，而不是 a%ba\\%ba%b ）等。 公式中不要使用中括号连缀（即 C++ 高维数组的表示方式）而多使用下标。 为了统一且书写方便，复杂度分析时大 OOO 记号请直接使用 $O()$ 而不是 $\\mathcal O()$。","categories":[{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://xiaoke-jin.github.io/tags/Markdown/"}]},{"title":"RMQ","slug":"DS_Algorithm证明与讲解/基础算法/RMQ","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-22T01:59:44.458Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/RMQ/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/RMQ/","excerpt":"","text":"RMQ RMQ ( Range Minimum/Maximum Query )，即区间最值查询。 RMQRMQRMQ 算法一般用较长时间做预处理，时间复杂度为 O(nlog⁡n)O(n\\log{n})O(nlogn)，然后可以在 O(1)O(1)O(1) 的时间内处理每次查询。 ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"}]},{"title":"二分","slug":"DS_Algorithm证明与讲解/基础算法/二分","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:12:12.350Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/二分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分本质 「二段性」 只要能确定目标一定在mid左边或右边。 ​ 注意事项 「边界问题」 小于所有元素，大于所有元素。即不属于查找范围内。 ​ 整数二分 while(l &lt; r) ​ 实数二分 「精度问题」：如果要求保留到n位，则while(r - l &gt; 1e-(n + 2))即可。 ​ ​ ​","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"前缀和与差分","slug":"DS_Algorithm证明与讲解/基础算法/前缀和与差分","date":"2021-08-09T16:00:00.000Z","updated":"2021-10-30T11:45:47.683Z","comments":true,"path":"2021/08/10/DS_Algorithm证明与讲解/基础算法/前缀和与差分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 一维前缀和 求前 n 个数的和 a[i] = a[i - 1] + a[i] 求某区间 [l,r][l, r][l,r] 的和 x = a[r] - a[l - 1] 二维前缀和 差分 应用：对区间进行加或减操作。 一维差分 概念：对数列 {an}\\{a_n\\}{an​} 有数列 {bn}\\{b_n\\}{bn​} ，使得 an=bn+bn−1+bn−2+⋯+b1a_n=b_n+b_{n-1}+b_{n-2}+\\cdots+b_1an​=bn​+bn−1​+bn−2​+⋯+b1​ 。 构造方式： an=(an−an−1)+(an−1−an−2)+⋯+(a1−a0)=an−a0=ana_n=(a_n-a_{n-1})+(a_{n-1}-a_{n-2})+\\cdots+(a_1-a_0)=a_n-a_0=a_nan​=(an​−an−1​)+(an−1​−an−2​)+⋯+(a1​−a0​)=an​−a0​=an​ 。 for(int i = 1; i &lt;= n; i++) b[i] = a[i] - a[i - 1]; 对区间 [l,r][l,r][l,r] 加或减 xxx：改变序列 {bn}\\{b_n\\}{bn​} 中的一个或两个数。 b[l] += x;b[r + 1] -= x; // 若r=n, 这一步可以省略 二维差分","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"}]},{"title":"排序题目","slug":"题目/基础算法/排序","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-13T08:22:35.154Z","comments":true,"path":"2021/08/10/题目/基础算法/排序/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/10/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序 AcWing 105. 七夕祭 AcWing 106. 动态中位数 求中位数 对顶堆 ==对顶思想== 逆序对 AcWing 788. 逆序对的数量 AcWing 107. 超快速排序 最少执行多少交换操作才能对给定的输入序列进行排序。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://xiaoke-jin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"小技巧","slug":"题目/小技巧","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-15T03:37:12.836Z","comments":true,"path":"2021/08/09/题目/小技巧/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"倒着来！！！ 字典序最小 AcWing 12. 背包问题求具体方案 记录方案 AcWing 1076. 迷宫问题","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"小技巧","slug":"题目/小技巧","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"感想","slug":"题目/感想","date":"2021-08-08T16:00:00.000Z","updated":"2021-10-24T11:55:23.305Z","comments":true,"path":"2021/08/09/题目/感想/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/","excerpt":"","text":"2021/08/10/22:41 拜服于大佬的精妙思想 ​ 2021/08/12 最难的不是数据结构与算法的学习，而是对题目进行深入分析，发掘其本质，将其转换为「易于求解的等价问题」。 2021/10/24 图论、数论、搜索、简单DP、数据结构、各类简单基础算法、字符串相关，嗯。基本入门了。 网络流、高难度DP，基本是放弃了。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"刷题注意事项","slug":"题目/注意事项","date":"2021-08-08T16:00:00.000Z","updated":"2021-10-08T04:16:42.537Z","comments":true,"path":"2021/08/09/题目/注意事项/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/09/%E9%A2%98%E7%9B%AE/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"需要特判的情况 搜索：起点和终点相同。 区间内第一个整除某素数的数不一定是合数，可能是其本身。 注意高精度、LL的坑 开了 long long记得用 %lld int 十进制：−231=−2147483648-2^{31}=-21 4748 3648−231=−2147483648 到 231−1=21474836472^{31}-1=21 4748 3647231−1=2147483647 。共10位，21亿。 求方案数； 逆序对数量； 数组下标需要从 1 开始 数组堆； 背包DP； 前缀和与差分； 输入字符 注意空字符； %c会读入换行符、空格； %s输入输出会略过空格、换行符； 输入「带空格」的字符矩阵 char g[N][N];for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; 2 * m; j++)&#123;//读入末尾换行符 char ch; scanf(&quot;%c&quot;, &amp;ch); if(ch == &#x27; &#x27; || ch == &#x27;\\n&#x27;) ; // 不进行任何操作 else g[i][j/2] = ch; // j/2 &#125; 输入「不带空格」的字符矩阵 输入为数字但「数字之间没有空格」，将其视为字符串。 char g[100][100];for(int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]); 输入单个字符 char op[2];scanf(&quot;%s&quot;, op); ​ 二分 (l + r) / 2 与 (l + r + 1) / 2； 考虑目标元素小于或大于区间内所有元素； ​ 双指针 防止指针越界 注意指针位置 ​","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}],"tags":[]},{"title":"递推与递归","slug":"题目/基础算法/递推与递归","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-08T14:20:16.399Z","comments":true,"path":"2021/08/08/题目/基础算法/递推与递归/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/08/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"递推 AcWing 95. 费解的开关 递归 AcWing 98. 分形之城","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递推与递归","slug":"递推与递归","permalink":"http://xiaoke-jin.github.io/tags/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/"}]},{"title":"位运算题目","slug":"题目/基础算法/位运算","date":"2021-08-06T16:00:00.000Z","updated":"2021-08-14T07:55:38.057Z","comments":true,"path":"2021/08/07/题目/基础算法/位运算/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/07/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"位运算 二进制枚举 快速幂，快速加 AcWing 90. 64位整数乘法 AcWing 875. 快速幂","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://xiaoke-jin.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"背包讲解","slug":"DS_Algorithm证明与讲解/DP/背包","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-13T01:13:17.488Z","comments":true,"path":"2021/08/06/DS_Algorithm证明与讲解/DP/背包/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/DS_Algorithm%E8%AF%81%E6%98%8E%E4%B8%8E%E8%AE%B2%E8%A7%A3/DP/%E8%83%8C%E5%8C%85/","excerpt":"","text":"01背包 AcWing 423. 采药【01背包DP模型+朴素优化】","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"前缀和与差分题目","slug":"题目/基础算法/前缀和与差分","date":"2021-08-05T16:00:00.000Z","updated":"2021-10-03T03:47:19.740Z","comments":true,"path":"2021/08/06/题目/基础算法/前缀和与差分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 AcWing 99. 激光炸弹 差分 AcWing 100. 增减序列 分析 三种类型的操作 贪心——尽快得到0 优先操作一(可以改变两个数)，然后再使用操作二、三补充。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"}]},{"title":"贪心题目","slug":"题目/贪心/贪心","date":"2021-08-05T16:00:00.000Z","updated":"2021-08-14T07:58:41.013Z","comments":true,"path":"2021/08/06/题目/贪心/贪心/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/06/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"贪心","slug":"题目/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"背包题目","slug":"题目/DP/背包","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-15T02:14:43.991Z","comments":true,"path":"2021/08/05/题目/DP/背包/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/05/%E9%A2%98%E7%9B%AE/DP/%E8%83%8C%E5%8C%85/","excerpt":"","text":"求方案数 物品选择顺序不影响方案数 求方案数 AcWing 278. 数字组合 AcWing 1023. 买书 AcWing 1021. 货币系统 求最小方案数 洛谷 P1679. 神奇的四次方数 求最优方案数 AcWing 11. 背包问题求方案数 物品选择顺序影响方案数 AcWing 3643. 上楼梯 求具体方案 要求字典序最小 AcWing 12. 背包问题求具体方案 求任意一个方案 1. 至多、恰好、至少 问题 至多 AcWing 423. 采药 AcWing 1019. 庆功会 洛谷 P1802 5倍经验日 至少 AcWing 1020. 潜水员 恰好 多维费用背包问题 AcWing 8. 二维费用的背包问题 AcWing 1022. 宠物小精灵之收服 墨染空的优化 链接 洛谷 P1509 找啊找啊找GF 分组背包 AcWing 1013. 机器分配 AcWing 487. 金明的预算方案 背包 + AcWing 734. 能量石","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"DP","slug":"题目/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/DP/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"二分题目","slug":"题目/基础算法/二分","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-13T08:15:31.708Z","comments":true,"path":"2021/08/05/题目/基础算法/二分/","link":"","permalink":"http://xiaoke-jin.github.io/2021/08/05/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分 AcWing_P790 浮点数二分 AcWing 102. 最佳牛围栏 平均值最大的问题，一般都可以转化为二分。 AcWing 113. 特殊排序 本题的解答过程事实上证明了：任意有向完全图（又称竞赛图）都存在Hamilton路径。","categories":[{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"}]}],"categories":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/categories/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoke-jin.github.io/categories/Hexo/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"初等数论及其应用","slug":"读书笔记/初等数论及其应用","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数据结构与算法/数论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"},{"name":"题目","slug":"题目","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/"},{"name":"constructive algorithms","slug":"题目/constructive-algorithms","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/constructive-algorithms/"},{"name":"工具","slug":"工具","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"浏览器","slug":"工具/浏览器","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"字符串","slug":"数据结构与算法/字符串","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"基础算法","slug":"题目/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"离散数学","slug":"读书笔记/离散数学","permalink":"http://xiaoke-jin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://xiaoke-jin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"搜索","slug":"数据结构与算法/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"VSCode","slug":"工具/VSCode","permalink":"http://xiaoke-jin.github.io/categories/%E5%B7%A5%E5%85%B7/VSCode/"},{"name":"贪心","slug":"数据结构与算法/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"},{"name":"离散化","slug":"数据结构与算法/离散化","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"搜索","slug":"题目/搜索","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"数据结构与算法/图论","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"数据结构与算法/图论/最短路","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"基础算法","slug":"数据结构与算法/基础算法","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"题目/数据结构","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂文","slug":"杂文","permalink":"http://xiaoke-jin.github.io/categories/%E6%9D%82%E6%96%87/"},{"name":"小技巧","slug":"题目/小技巧","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"感想","slug":"题目/感想","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E6%84%9F%E6%83%B3/"},{"name":"刷题注意事项","slug":"题目/刷题注意事项","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"DP","slug":"数据结构与算法/DP","permalink":"http://xiaoke-jin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/DP/"},{"name":"贪心","slug":"题目/贪心","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"题目/DP","permalink":"http://xiaoke-jin.github.io/categories/%E9%A2%98%E7%9B%AE/DP/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://xiaoke-jin.github.io/tags/Github/"},{"name":"数论","slug":"数论","permalink":"http://xiaoke-jin.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"构造题","slug":"构造题","permalink":"http://xiaoke-jin.github.io/tags/%E6%9E%84%E9%80%A0%E9%A2%98/"},{"name":"题单","slug":"题单","permalink":"http://xiaoke-jin.github.io/tags/%E9%A2%98%E5%8D%95/"},{"name":"字符串","slug":"字符串","permalink":"http://xiaoke-jin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"离散化","slug":"离散化","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"离散数学","slug":"离散数学","permalink":"http://xiaoke-jin.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"Java","slug":"Java","permalink":"http://xiaoke-jin.github.io/tags/Java/"},{"name":"搜索","slug":"搜索","permalink":"http://xiaoke-jin.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"贪心","slug":"贪心","permalink":"http://xiaoke-jin.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"最短路","slug":"最短路","permalink":"http://xiaoke-jin.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"高精度","slug":"高精度","permalink":"http://xiaoke-jin.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"RMQ","slug":"RMQ","permalink":"http://xiaoke-jin.github.io/tags/RMQ/"},{"name":"并查集","slug":"并查集","permalink":"http://xiaoke-jin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"STL","slug":"STL","permalink":"http://xiaoke-jin.github.io/tags/STL/"},{"name":"洛谷","slug":"洛谷","permalink":"http://xiaoke-jin.github.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://xiaoke-jin.github.io/tags/LaTeX/"},{"name":"Markdown","slug":"Markdown","permalink":"http://xiaoke-jin.github.io/tags/Markdown/"},{"name":"二分","slug":"二分","permalink":"http://xiaoke-jin.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"前缀和与差分","slug":"前缀和与差分","permalink":"http://xiaoke-jin.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"},{"name":"排序","slug":"排序","permalink":"http://xiaoke-jin.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"小技巧","slug":"小技巧","permalink":"http://xiaoke-jin.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"递推与递归","slug":"递推与递归","permalink":"http://xiaoke-jin.github.io/tags/%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/"},{"name":"位运算","slug":"位运算","permalink":"http://xiaoke-jin.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"背包","slug":"背包","permalink":"http://xiaoke-jin.github.io/tags/%E8%83%8C%E5%8C%85/"}]}